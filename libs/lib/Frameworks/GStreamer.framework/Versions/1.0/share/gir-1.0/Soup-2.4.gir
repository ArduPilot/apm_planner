<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="Gio" version="2.0"/>
  <package name="libsoup-2.4"/>
  <c:include name="libsoup/soup.h"/>
  <namespace name="Soup"
             version="2.4"
             shared-library="/Library/Frameworks/GStreamer.framework/Versions/1.0/lib/libsoup-2.4.1.dylib"
             c:identifier-prefixes="Soup"
             c:symbol-prefixes="soup">
    <constant name="ADDRESS_ANY_PORT" value="0" c:type="SOUP_ADDRESS_ANY_PORT">
      <doc xml:space="preserve">This can be passed to any #SoupAddress method that expects a port,
to indicate that you don't care what port is used.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ADDRESS_FAMILY"
              value="family"
              c:type="SOUP_ADDRESS_FAMILY">
      <doc xml:space="preserve">Alias for the #SoupAddress:family property. (The
#SoupAddressFamily for this address.)</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ADDRESS_NAME" value="name" c:type="SOUP_ADDRESS_NAME">
      <doc xml:space="preserve">Alias for the #SoupAddress:name property. (The hostname for
this address.)</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ADDRESS_PHYSICAL"
              value="physical"
              c:type="SOUP_ADDRESS_PHYSICAL">
      <doc xml:space="preserve">An alias for the #SoupAddress:physical property. (The
stringified IP address for this address.)</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ADDRESS_PORT" value="port" c:type="SOUP_ADDRESS_PORT">
      <doc xml:space="preserve">An alias for the #SoupAddress:port property. (The port for
this address.)</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ADDRESS_PROTOCOL"
              value="protocol"
              c:type="SOUP_ADDRESS_PROTOCOL">
      <doc xml:space="preserve">Alias for the #SoupAddress:protocol property. (The URI scheme
used with this address.)</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ADDRESS_SOCKADDR"
              value="sockaddr"
              c:type="SOUP_ADDRESS_SOCKADDR">
      <doc xml:space="preserve">An alias for the #SoupAddress:sockaddr property. (A pointer
to the struct sockaddr for this address.)</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUTH_DOMAIN_ADD_PATH"
              value="add-path"
              c:type="SOUP_AUTH_DOMAIN_ADD_PATH">
      <doc xml:space="preserve">Alias for the #SoupAuthDomain:add-path property. (Shortcut
for calling soup_auth_domain_add_path().)</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUTH_DOMAIN_BASIC_AUTH_CALLBACK"
              value="auth-callback"
              c:type="SOUP_AUTH_DOMAIN_BASIC_AUTH_CALLBACK">
      <doc xml:space="preserve">Alias for the #SoupAuthDomainBasic:auth-callback property.
(The #SoupAuthDomainBasicAuthCallback.)</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUTH_DOMAIN_BASIC_AUTH_DATA"
              value="auth-data"
              c:type="SOUP_AUTH_DOMAIN_BASIC_AUTH_DATA">
      <doc xml:space="preserve">Alias for the #SoupAuthDomainBasic:auth-data property.
(The data to pass to the #SoupAuthDomainBasicAuthCallback.)</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUTH_DOMAIN_BASIC_H"
              value="1"
              c:type="SOUP_AUTH_DOMAIN_BASIC_H">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="AUTH_DOMAIN_DIGEST_AUTH_CALLBACK"
              value="auth-callback"
              c:type="SOUP_AUTH_DOMAIN_DIGEST_AUTH_CALLBACK">
      <doc xml:space="preserve">Alias for the #SoupAuthDomainDigest:auth-callback property.
(The #SoupAuthDomainDigestAuthCallback.)</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUTH_DOMAIN_DIGEST_AUTH_DATA"
              value="auth-data"
              c:type="SOUP_AUTH_DOMAIN_DIGEST_AUTH_DATA">
      <doc xml:space="preserve">Alias for the #SoupAuthDomainDigest:auth-callback property.
(The #SoupAuthDomainDigestAuthCallback.)</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUTH_DOMAIN_DIGEST_H"
              value="1"
              c:type="SOUP_AUTH_DOMAIN_DIGEST_H">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="AUTH_DOMAIN_FILTER"
              value="filter"
              c:type="SOUP_AUTH_DOMAIN_FILTER">
      <doc xml:space="preserve">Alias for the #SoupAuthDomain:filter property. (The
#SoupAuthDomainFilter for the domain.)</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUTH_DOMAIN_FILTER_DATA"
              value="filter-data"
              c:type="SOUP_AUTH_DOMAIN_FILTER_DATA">
      <doc xml:space="preserve">Alias for the #SoupAuthDomain:filter-data property. (Data
to pass to the #SoupAuthDomainFilter.)</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUTH_DOMAIN_GENERIC_AUTH_CALLBACK"
              value="generic-auth-callback"
              c:type="SOUP_AUTH_DOMAIN_GENERIC_AUTH_CALLBACK">
      <doc xml:space="preserve">Alias for the #SoupAuthDomain:generic-auth-callback property.
(The #SoupAuthDomainGenericAuthCallback.)</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUTH_DOMAIN_GENERIC_AUTH_DATA"
              value="generic-auth-data"
              c:type="SOUP_AUTH_DOMAIN_GENERIC_AUTH_DATA">
      <doc xml:space="preserve">Alias for the #SoupAuthDomain:generic-auth-data property.
(The data to pass to the #SoupAuthDomainGenericAuthCallback.)</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUTH_DOMAIN_H" value="1" c:type="SOUP_AUTH_DOMAIN_H">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="AUTH_DOMAIN_PROXY"
              value="proxy"
              c:type="SOUP_AUTH_DOMAIN_PROXY">
      <doc xml:space="preserve">Alias for the #SoupAuthDomain:proxy property. (Whether or
not this is a proxy auth domain.)</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUTH_DOMAIN_REALM"
              value="realm"
              c:type="SOUP_AUTH_DOMAIN_REALM">
      <doc xml:space="preserve">Alias for the #SoupAuthDomain:realm property. (The realm of
this auth domain.)</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUTH_DOMAIN_REMOVE_PATH"
              value="remove-path"
              c:type="SOUP_AUTH_DOMAIN_REMOVE_PATH">
      <doc xml:space="preserve">Alias for the #SoupAuthDomain:remove-path property.
(Shortcut for calling soup_auth_domain_remove_path().)</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUTH_H" value="1" c:type="SOUP_AUTH_H">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="AUTH_HOST" value="host" c:type="SOUP_AUTH_HOST">
      <doc xml:space="preserve">An alias for the #SoupAuth:host property. (The
host being authenticated to.)</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUTH_IS_AUTHENTICATED"
              value="is-authenticated"
              c:type="SOUP_AUTH_IS_AUTHENTICATED">
      <doc xml:space="preserve">An alias for the #SoupAuth:is-authenticated property.
(Whether or not the auth has been authenticated.)</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUTH_IS_FOR_PROXY"
              value="is-for-proxy"
              c:type="SOUP_AUTH_IS_FOR_PROXY">
      <doc xml:space="preserve">An alias for the #SoupAuth:is-for-proxy property. (Whether
or not the auth is for a proxy server.)</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUTH_MANAGER_H" value="1" c:type="SOUP_AUTH_MANAGER_H">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="AUTH_REALM" value="realm" c:type="SOUP_AUTH_REALM">
      <doc xml:space="preserve">An alias for the #SoupAuth:realm property. (The
authentication realm.)</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUTH_SCHEME_NAME"
              value="scheme-name"
              c:type="SOUP_AUTH_SCHEME_NAME">
      <doc xml:space="preserve">An alias for the #SoupAuth:scheme-name property. (The
authentication scheme name.)</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <class name="Address"
           c:symbol-prefix="address"
           c:type="SoupAddress"
           parent="GObject.Object"
           glib:type-name="SoupAddress"
           glib:get-type="soup_address_get_type"
           glib:type-struct="AddressClass">
      <implements name="Gio.SocketConnectable"/>
      <constructor name="new" c:identifier="soup_address_new">
        <doc xml:space="preserve">Creates a #SoupAddress from @name and @port. The #SoupAddress's IP
address may not be available right away; the caller can call
soup_address_resolve_async() or soup_address_resolve_sync() to
force a DNS resolution.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #SoupAddress</doc>
          <type name="Address" c:type="SoupAddress*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">a hostname or physical address</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="port" transfer-ownership="none">
            <doc xml:space="preserve">a port number</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_any" c:identifier="soup_address_new_any">
        <doc xml:space="preserve">Returns a #SoupAddress corresponding to the "any" address
for @family (or %NULL if @family isn't supported), suitable for
using as a listening #SoupSocket.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the new #SoupAddress</doc>
          <type name="Address" c:type="SoupAddress*"/>
        </return-value>
        <parameters>
          <parameter name="family" transfer-ownership="none">
            <doc xml:space="preserve">the address family</doc>
            <type name="AddressFamily" c:type="SoupAddressFamily"/>
          </parameter>
          <parameter name="port" transfer-ownership="none">
            <doc xml:space="preserve">the port number (usually %SOUP_ADDRESS_ANY_PORT)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_sockaddr"
                   c:identifier="soup_address_new_from_sockaddr">
        <doc xml:space="preserve">Returns a #SoupAddress equivalent to @sa (or %NULL if @sa's
address family isn't supported)</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the new #SoupAddress</doc>
          <type name="Address" c:type="SoupAddress*"/>
        </return-value>
        <parameters>
          <parameter name="sa" transfer-ownership="none">
            <doc xml:space="preserve">a pointer to a sockaddr</doc>
            <type name="gpointer" c:type="sockaddr*"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">size of @sa</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="equal_by_ip"
              c:identifier="soup_address_equal_by_ip"
              version="2.26">
        <doc xml:space="preserve">Tests if @addr1 and @addr2 have the same IP address. This method
can be used with soup_address_hash_by_ip() to create a
#GHashTable that hashes on IP address.

This would be used to distinguish hosts in situations where
different virtual hosts on the same IP address should be considered
the same. Eg, if "www.example.com" and "www.example.net" have the
same IP address, then a single connection can be used to talk
to either of them.

See also soup_address_equal_by_name(), which compares by name
rather than by IP address.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether or not @addr1 and @addr2 have the same IP
address.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr1" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAddress with a resolved IP
  address</doc>
            <type name="Address" c:type="gconstpointer"/>
          </instance-parameter>
          <parameter name="addr2" transfer-ownership="none">
            <doc xml:space="preserve">another #SoupAddress with a resolved
  IP address</doc>
            <type name="Address" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="equal_by_name"
              c:identifier="soup_address_equal_by_name"
              version="2.26">
        <doc xml:space="preserve">Tests if @addr1 and @addr2 have the same "name". This method can be
used with soup_address_hash_by_name() to create a #GHashTable that
hashes on address "names".

Comparing by name normally means comparing the addresses by their
hostnames. But if the address was originally created using an IP
address literal, then it will be compared by that instead.

In particular, if "www.example.com" has the IP address 10.0.0.1,
and @addr1 was created with the name "www.example.com" and @addr2
was created with the name "10.0.0.1", then they will compare as
unequal for purposes of soup_address_equal_by_name().

This would be used to distinguish hosts in situations where
different virtual hosts on the same IP address should be considered
different. Eg, for purposes of HTTP authentication or cookies, two
hosts with the same IP address but different names are considered
to be different hosts.

See also soup_address_equal_by_ip(), which compares by IP address
rather than by name.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether or not @addr1 and @addr2 have the same name</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr1" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAddress with a resolved name</doc>
            <type name="Address" c:type="gconstpointer"/>
          </instance-parameter>
          <parameter name="addr2" transfer-ownership="none">
            <doc xml:space="preserve">another #SoupAddress with a resolved
  name</doc>
            <type name="Address" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_gsockaddr"
              c:identifier="soup_address_get_gsockaddr"
              version="2.32">
        <doc xml:space="preserve">Creates a new #GSocketAddress corresponding to @addr (which is assumed
to only have one socket address associated with it).</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GSocketAddress</doc>
          <type name="Gio.SocketAddress" c:type="GSocketAddress*"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAddress</doc>
            <type name="Address" c:type="SoupAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_name" c:identifier="soup_address_get_name">
        <doc xml:space="preserve">Returns the hostname associated with @addr.

This method is not thread-safe; if you call it while @addr is being
resolved in another thread, it may return garbage. You can use
soup_address_is_resolved() to safely test whether or not an address
is resolved before fetching its name or address.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the hostname, or %NULL if it is not known.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAddress</doc>
            <type name="Address" c:type="SoupAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_physical" c:identifier="soup_address_get_physical">
        <doc xml:space="preserve">Returns the physical address associated with @addr as a string.
(Eg, "127.0.0.1"). If the address is not yet known, returns %NULL.

This method is not thread-safe; if you call it while @addr is being
resolved in another thread, it may return garbage. You can use
soup_address_is_resolved() to safely test whether or not an address
is resolved before fetching its name or address.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the physical address, or %NULL</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAddress</doc>
            <type name="Address" c:type="SoupAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_port" c:identifier="soup_address_get_port">
        <doc xml:space="preserve">Returns the port associated with @addr.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the port</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAddress</doc>
            <type name="Address" c:type="SoupAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_sockaddr" c:identifier="soup_address_get_sockaddr">
        <doc xml:space="preserve">Returns the sockaddr associated with @addr, with its length in
*@len. If the sockaddr is not yet known, returns %NULL.

This method is not thread-safe; if you call it while @addr is being
resolved in another thread, it may return garbage. You can use
soup_address_is_resolved() to safely test whether or not an address
is resolved before fetching its name or address.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the sockaddr, or %NULL</doc>
          <type name="gpointer" c:type="sockaddr*"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAddress</doc>
            <type name="Address" c:type="SoupAddress*"/>
          </instance-parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">return location for sockaddr length</doc>
            <type name="gint" c:type="int*"/>
          </parameter>
        </parameters>
      </method>
      <method name="hash_by_ip"
              c:identifier="soup_address_hash_by_ip"
              version="2.26">
        <doc xml:space="preserve">A hash function (for #GHashTable) that corresponds to
soup_address_equal_by_ip(), qv</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the IP-based hash value for @addr.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAddress</doc>
            <type name="Address" c:type="gconstpointer"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="hash_by_name"
              c:identifier="soup_address_hash_by_name"
              version="2.26">
        <doc xml:space="preserve">A hash function (for #GHashTable) that corresponds to
soup_address_equal_by_name(), qv</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the named-based hash value for @addr.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAddress</doc>
            <type name="Address" c:type="gconstpointer"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_resolved" c:identifier="soup_address_is_resolved">
        <doc xml:space="preserve">Tests if @addr has already been resolved. Unlike the other
#SoupAddress "get" methods, this is safe to call when @addr might
be being resolved in another thread.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @addr has been resolved.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAddress</doc>
            <type name="Address" c:type="SoupAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="resolve_async" c:identifier="soup_address_resolve_async">
        <doc xml:space="preserve">Asynchronously resolves the missing half of @addr (its IP address
if it was created with soup_address_new(), or its hostname if it
was created with soup_address_new_from_sockaddr() or
soup_address_new_any().)

If @cancellable is non-%NULL, it can be used to cancel the
resolution. @callback will still be invoked in this case, with a
status of %SOUP_STATUS_CANCELLED.

It is safe to call this more than once on a given address, from the
same thread, with the same @async_context (and doing so will not
result in redundant DNS queries being made). But it is not safe to
call from multiple threads, or with different @async_contexts, or
mixed with calls to soup_address_resolve_sync().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAddress</doc>
            <type name="Address" c:type="SoupAddress*"/>
          </instance-parameter>
          <parameter name="async_context"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the #GMainContext to call @callback from</doc>
            <type name="GLib.MainContext" c:type="GMainContext*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">callback to call with the result</doc>
            <type name="AddressCallback" c:type="SoupAddressCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">data for @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="resolve_sync" c:identifier="soup_address_resolve_sync">
        <doc xml:space="preserve">Synchronously resolves the missing half of @addr, as with
soup_address_resolve_async().

If @cancellable is non-%NULL, it can be used to cancel the
resolution. soup_address_resolve_sync() will then return a status
of %SOUP_STATUS_CANCELLED.

It is safe to call this more than once, even from different
threads, but it is not safe to mix calls to
soup_address_resolve_sync() with calls to
soup_address_resolve_async() on the same address.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%SOUP_STATUS_OK, %SOUP_STATUS_CANT_RESOLVE, or
%SOUP_STATUS_CANCELLED.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAddress</doc>
            <type name="Address" c:type="SoupAddress*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <property name="family"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="AddressFamily"/>
      </property>
      <property name="name"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="physical" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="port"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="protocol"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="sockaddr"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <callback name="AddressCallback" c:type="SoupAddressCallback">
      <doc xml:space="preserve">The callback function passed to soup_address_resolve_async().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="addr" transfer-ownership="none">
          <doc xml:space="preserve">the #SoupAddress that was resolved</doc>
          <type name="Address" c:type="SoupAddress*"/>
        </parameter>
        <parameter name="status" transfer-ownership="none">
          <doc xml:space="preserve">%SOUP_STATUS_OK, %SOUP_STATUS_CANT_RESOLVE, or
%SOUP_STATUS_CANCELLED</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:space="preserve">the user data that was passed to
soup_address_resolve_async()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="AddressClass"
            c:type="SoupAddressClass"
            glib:is-gtype-struct-for="Address">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="_libsoup_reserved1" introspectable="0">
        <callback name="_libsoup_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_libsoup_reserved2" introspectable="0">
        <callback name="_libsoup_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_libsoup_reserved3" introspectable="0">
        <callback name="_libsoup_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_libsoup_reserved4" introspectable="0">
        <callback name="_libsoup_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="AddressFamily"
                 glib:type-name="SoupAddressFamily"
                 glib:get-type="soup_address_family_get_type"
                 c:type="SoupAddressFamily">
      <doc xml:space="preserve">The supported address families.</doc>
      <member name="invalid"
              value="-1"
              c:identifier="SOUP_ADDRESS_FAMILY_INVALID"
              glib:nick="invalid">
        <doc xml:space="preserve">an invalid %SoupAddress</doc>
      </member>
      <member name="ipv4"
              value="2"
              c:identifier="SOUP_ADDRESS_FAMILY_IPV4"
              glib:nick="ipv4">
        <doc xml:space="preserve">an IPv4 address</doc>
      </member>
      <member name="ipv6"
              value="30"
              c:identifier="SOUP_ADDRESS_FAMILY_IPV6"
              glib:nick="ipv6">
        <doc xml:space="preserve">an IPv6 address</doc>
      </member>
    </enumeration>
    <class name="Auth"
           c:symbol-prefix="auth"
           c:type="SoupAuth"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="SoupAuth"
           glib:get-type="soup_auth_get_type"
           glib:type-struct="AuthClass">
      <doc xml:space="preserve">The abstract base class for handling authentication. Specific HTTP
Authentication mechanisms are implemented by its subclasses, but
applications never need to be aware of the specific subclasses
being used.</doc>
      <constructor name="new" c:identifier="soup_auth_new">
        <doc xml:space="preserve">Creates a new #SoupAuth of type @type with the information from
@msg and @auth_header.

This is called by #SoupSession; you will normally not create auths
yourself.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the new #SoupAuth, or %NULL if it could
not be created</doc>
          <type name="Auth" c:type="SoupAuth*"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">the type of auth to create (a subtype of #SoupAuth)</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">the #SoupMessage the auth is being created for</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
          <parameter name="auth_header" transfer-ownership="none">
            <doc xml:space="preserve">the WWW-Authenticate/Proxy-Authenticate header</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="authenticate" invoker="authenticate">
        <doc xml:space="preserve">Call this on an auth to authenticate it; normally this will cause
the auth's message to be requeued with the new authentication info.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="auth" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuth</doc>
            <type name="Auth" c:type="SoupAuth*"/>
          </instance-parameter>
          <parameter name="username" transfer-ownership="none">
            <doc xml:space="preserve">the username provided by the user or client</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="password" transfer-ownership="none">
            <doc xml:space="preserve">the password provided by the user or client</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_authorization" invoker="get_authorization">
        <doc xml:space="preserve">Generates an appropriate "Authorization" header for @msg. (The
session will only call this if soup_auth_is_authenticated()
returned %TRUE.)</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the "Authorization" header, which must be freed.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="auth" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuth</doc>
            <type name="Auth" c:type="SoupAuth*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">the #SoupMessage to be authorized</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_protection_space"
                      invoker="get_protection_space">
        <doc xml:space="preserve">Returns a list of paths on the server which @auth extends over.
(All subdirectories of these paths are also assumed to be part
of @auth's protection space, unless otherwise discovered not to
be.)</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the list of
paths, which can be freed with soup_auth_free_protection_space().</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="utf8"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="auth" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuth</doc>
            <type name="Auth" c:type="SoupAuth*"/>
          </instance-parameter>
          <parameter name="source_uri" transfer-ownership="none">
            <doc xml:space="preserve">the URI of the request that @auth was generated in
response to.</doc>
            <type name="URI" c:type="SoupURI*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="is_authenticated" invoker="is_authenticated">
        <doc xml:space="preserve">Tests if @auth has been given a username and password</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @auth has been given a username and password</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="auth" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuth</doc>
            <type name="Auth" c:type="SoupAuth*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="is_ready" invoker="is_ready" version="2.42">
        <doc xml:space="preserve">Tests if @auth is ready to make a request for @msg with. For most
auths, this is equivalent to soup_auth_is_authenticated(), but for
some auth types (eg, NTLM), the auth may be sendable (eg, as an
authentication request) even before it is authenticated.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @auth is ready to make a request with.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="auth" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuth</doc>
            <type name="Auth" c:type="SoupAuth*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="update" invoker="update">
        <doc xml:space="preserve">Updates @auth with the information from @msg and @auth_header,
possibly un-authenticating it. As with soup_auth_new(), this is
normally only used by #SoupSession.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @auth is still a valid (but potentially
unauthenticated) #SoupAuth. %FALSE if something about @auth_params
could not be parsed or incorporated into @auth at all.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="auth" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuth</doc>
            <type name="Auth" c:type="SoupAuth*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">the #SoupMessage @auth is being updated for</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
          <parameter name="auth_header" transfer-ownership="none">
            <doc xml:space="preserve">the WWW-Authenticate/Proxy-Authenticate header</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="authenticate" c:identifier="soup_auth_authenticate">
        <doc xml:space="preserve">Call this on an auth to authenticate it; normally this will cause
the auth's message to be requeued with the new authentication info.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="auth" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuth</doc>
            <type name="Auth" c:type="SoupAuth*"/>
          </instance-parameter>
          <parameter name="username" transfer-ownership="none">
            <doc xml:space="preserve">the username provided by the user or client</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="password" transfer-ownership="none">
            <doc xml:space="preserve">the password provided by the user or client</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free_protection_space"
              c:identifier="soup_auth_free_protection_space"
              introspectable="0">
        <doc xml:space="preserve">Frees @space.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="auth" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuth</doc>
            <type name="Auth" c:type="SoupAuth*"/>
          </instance-parameter>
          <parameter name="space" transfer-ownership="none">
            <doc xml:space="preserve">the return value from soup_auth_get_protection_space()</doc>
            <type name="GLib.SList" c:type="GSList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="get_authorization"
              c:identifier="soup_auth_get_authorization">
        <doc xml:space="preserve">Generates an appropriate "Authorization" header for @msg. (The
session will only call this if soup_auth_is_authenticated()
returned %TRUE.)</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the "Authorization" header, which must be freed.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="auth" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuth</doc>
            <type name="Auth" c:type="SoupAuth*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">the #SoupMessage to be authorized</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_host" c:identifier="soup_auth_get_host">
        <doc xml:space="preserve">Returns the host that @auth is associated with.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the hostname</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="auth" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuth</doc>
            <type name="Auth" c:type="SoupAuth*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_info" c:identifier="soup_auth_get_info">
        <doc xml:space="preserve">Gets an opaque identifier for @auth, for use as a hash key or the
like. #SoupAuth objects from the same server with the same
identifier refer to the same authentication domain (eg, the URLs
associated with them take the same usernames and passwords).</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the identifier</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="auth" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuth</doc>
            <type name="Auth" c:type="SoupAuth*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_protection_space"
              c:identifier="soup_auth_get_protection_space">
        <doc xml:space="preserve">Returns a list of paths on the server which @auth extends over.
(All subdirectories of these paths are also assumed to be part
of @auth's protection space, unless otherwise discovered not to
be.)</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the list of
paths, which can be freed with soup_auth_free_protection_space().</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="utf8"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="auth" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuth</doc>
            <type name="Auth" c:type="SoupAuth*"/>
          </instance-parameter>
          <parameter name="source_uri" transfer-ownership="none">
            <doc xml:space="preserve">the URI of the request that @auth was generated in
response to.</doc>
            <type name="URI" c:type="SoupURI*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_realm" c:identifier="soup_auth_get_realm">
        <doc xml:space="preserve">Returns @auth's realm. This is an identifier that distinguishes
separate authentication spaces on a given server, and may be some
string that is meaningful to the user. (Although it is probably not
localized.)</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the realm name</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="auth" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuth</doc>
            <type name="Auth" c:type="SoupAuth*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_saved_password"
              c:identifier="soup_auth_get_saved_password">
        <return-value transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="auth" transfer-ownership="none">
            <type name="Auth" c:type="SoupAuth*"/>
          </instance-parameter>
          <parameter name="user" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_saved_users" c:identifier="soup_auth_get_saved_users">
        <return-value transfer-ownership="full">
          <type name="GLib.SList" c:type="GSList*">
            <type name="utf8"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="auth" transfer-ownership="none">
            <type name="Auth" c:type="SoupAuth*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_scheme_name" c:identifier="soup_auth_get_scheme_name">
        <doc xml:space="preserve">Returns @auth's scheme name. (Eg, "Basic", "Digest", or "NTLM")</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the scheme name</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="auth" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuth</doc>
            <type name="Auth" c:type="SoupAuth*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="has_saved_password"
              c:identifier="soup_auth_has_saved_password">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="auth" transfer-ownership="none">
            <type name="Auth" c:type="SoupAuth*"/>
          </instance-parameter>
          <parameter name="username" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="password" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_authenticated"
              c:identifier="soup_auth_is_authenticated">
        <doc xml:space="preserve">Tests if @auth has been given a username and password</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @auth has been given a username and password</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="auth" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuth</doc>
            <type name="Auth" c:type="SoupAuth*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_for_proxy" c:identifier="soup_auth_is_for_proxy">
        <doc xml:space="preserve">Tests whether or not @auth is associated with a proxy server rather
than an "origin" server.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE or %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="auth" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuth</doc>
            <type name="Auth" c:type="SoupAuth*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_ready" c:identifier="soup_auth_is_ready" version="2.42">
        <doc xml:space="preserve">Tests if @auth is ready to make a request for @msg with. For most
auths, this is equivalent to soup_auth_is_authenticated(), but for
some auth types (eg, NTLM), the auth may be sendable (eg, as an
authentication request) even before it is authenticated.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @auth is ready to make a request with.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="auth" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuth</doc>
            <type name="Auth" c:type="SoupAuth*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
        </parameters>
      </method>
      <method name="save_password" c:identifier="soup_auth_save_password">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="auth" transfer-ownership="none">
            <type name="Auth" c:type="SoupAuth*"/>
          </instance-parameter>
          <parameter name="username" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="password" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="update" c:identifier="soup_auth_update">
        <doc xml:space="preserve">Updates @auth with the information from @msg and @auth_header,
possibly un-authenticating it. As with soup_auth_new(), this is
normally only used by #SoupSession.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @auth is still a valid (but potentially
unauthenticated) #SoupAuth. %FALSE if something about @auth_params
could not be parsed or incorporated into @auth at all.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="auth" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuth</doc>
            <type name="Auth" c:type="SoupAuth*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">the #SoupMessage @auth is being updated for</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
          <parameter name="auth_header" transfer-ownership="none">
            <doc xml:space="preserve">the WWW-Authenticate/Proxy-Authenticate header</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <property name="host" writable="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="is-authenticated" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="is-for-proxy" writable="1" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="realm" writable="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="scheme-name" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="realm">
        <type name="utf8" c:type="char*"/>
      </field>
    </class>
    <class name="AuthBasic"
           c:symbol-prefix="auth_basic"
           parent="Auth"
           glib:type-name="SoupAuthBasic"
           glib:get-type="soup_auth_basic_get_type">
    </class>
    <record name="AuthClass"
            c:type="SoupAuthClass"
            glib:is-gtype-struct-for="Auth">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="scheme_name">
        <type name="utf8" c:type="const char*"/>
      </field>
      <field name="strength">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="update">
        <callback name="update">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if @auth is still a valid (but potentially
unauthenticated) #SoupAuth. %FALSE if something about @auth_params
could not be parsed or incorporated into @auth at all.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="auth" transfer-ownership="none">
              <doc xml:space="preserve">a #SoupAuth</doc>
              <type name="Auth" c:type="SoupAuth*"/>
            </parameter>
            <parameter name="msg" transfer-ownership="none">
              <doc xml:space="preserve">the #SoupMessage @auth is being updated for</doc>
              <type name="Message" c:type="SoupMessage*"/>
            </parameter>
            <parameter name="auth_header" transfer-ownership="none">
              <doc xml:space="preserve">the WWW-Authenticate/Proxy-Authenticate header</doc>
              <type name="GLib.HashTable" c:type="GHashTable*">
                <type name="gpointer" c:type="gpointer"/>
                <type name="gpointer" c:type="gpointer"/>
              </type>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_protection_space">
        <callback name="get_protection_space">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">the list of
paths, which can be freed with soup_auth_free_protection_space().</doc>
            <type name="GLib.SList" c:type="GSList*">
              <type name="utf8"/>
            </type>
          </return-value>
          <parameters>
            <parameter name="auth" transfer-ownership="none">
              <doc xml:space="preserve">a #SoupAuth</doc>
              <type name="Auth" c:type="SoupAuth*"/>
            </parameter>
            <parameter name="source_uri" transfer-ownership="none">
              <doc xml:space="preserve">the URI of the request that @auth was generated in
response to.</doc>
              <type name="URI" c:type="SoupURI*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="authenticate">
        <callback name="authenticate">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="auth" transfer-ownership="none">
              <doc xml:space="preserve">a #SoupAuth</doc>
              <type name="Auth" c:type="SoupAuth*"/>
            </parameter>
            <parameter name="username" transfer-ownership="none">
              <doc xml:space="preserve">the username provided by the user or client</doc>
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="password" transfer-ownership="none">
              <doc xml:space="preserve">the password provided by the user or client</doc>
              <type name="utf8" c:type="const char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="is_authenticated">
        <callback name="is_authenticated">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if @auth has been given a username and password</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="auth" transfer-ownership="none">
              <doc xml:space="preserve">a #SoupAuth</doc>
              <type name="Auth" c:type="SoupAuth*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_authorization">
        <callback name="get_authorization">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">the "Authorization" header, which must be freed.</doc>
            <type name="utf8" c:type="char*"/>
          </return-value>
          <parameters>
            <parameter name="auth" transfer-ownership="none">
              <doc xml:space="preserve">a #SoupAuth</doc>
              <type name="Auth" c:type="SoupAuth*"/>
            </parameter>
            <parameter name="msg" transfer-ownership="none">
              <doc xml:space="preserve">the #SoupMessage to be authorized</doc>
              <type name="Message" c:type="SoupMessage*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="is_ready">
        <callback name="is_ready">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if @auth is ready to make a request with.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="auth" transfer-ownership="none">
              <doc xml:space="preserve">a #SoupAuth</doc>
              <type name="Auth" c:type="SoupAuth*"/>
            </parameter>
            <parameter name="msg" transfer-ownership="none">
              <doc xml:space="preserve">a #SoupMessage</doc>
              <type name="Message" c:type="SoupMessage*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_libsoup_reserved2" introspectable="0">
        <callback name="_libsoup_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_libsoup_reserved3" introspectable="0">
        <callback name="_libsoup_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_libsoup_reserved4" introspectable="0">
        <callback name="_libsoup_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <class name="AuthDigest"
           c:symbol-prefix="auth_digest"
           parent="Auth"
           glib:type-name="SoupAuthDigest"
           glib:get-type="soup_auth_digest_get_type">
    </class>
    <class name="AuthDomain"
           c:symbol-prefix="auth_domain"
           c:type="SoupAuthDomain"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="SoupAuthDomain"
           glib:get-type="soup_auth_domain_get_type"
           glib:type-struct="AuthDomainClass">
      <virtual-method name="accepts">
        <return-value transfer-ownership="full">
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="domain" transfer-ownership="none">
            <type name="AuthDomain" c:type="SoupAuthDomain*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
          <parameter name="header" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="challenge">
        <return-value transfer-ownership="full">
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="domain" transfer-ownership="none">
            <type name="AuthDomain" c:type="SoupAuthDomain*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="check_password" invoker="check_password">
        <doc xml:space="preserve">Checks if @msg authenticates to @domain via @username and
@password. This would normally be called from a
#SoupAuthDomainGenericAuthCallback.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether or not the message is authenticated</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuthDomain</doc>
            <type name="AuthDomain" c:type="SoupAuthDomain*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
          <parameter name="username" transfer-ownership="none">
            <doc xml:space="preserve">a username</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="password" transfer-ownership="none">
            <doc xml:space="preserve">a password</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="accepts" c:identifier="soup_auth_domain_accepts">
        <doc xml:space="preserve">Checks if @msg contains appropriate authorization for @domain to
accept it. Mirroring soup_auth_domain_covers(), this does not check
whether or not @domain &lt;emphasis&gt;cares&lt;/emphasis&gt; if @msg is
authorized.

This is used by #SoupServer internally and is probably of no use to
anyone else.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the username that @msg has authenticated
as, if in fact it has authenticated. %NULL otherwise.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuthDomain</doc>
            <type name="AuthDomain" c:type="SoupAuthDomain*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_path" c:identifier="soup_auth_domain_add_path">
        <doc xml:space="preserve">Adds @path to @domain, such that requests under @path on @domain's
server will require authentication (unless overridden by
soup_auth_domain_remove_path() or soup_auth_domain_set_filter()).

You can also add paths by setting the %SOUP_AUTH_DOMAIN_ADD_PATH
property, which can also be used to add one or more paths at
construct time.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuthDomain</doc>
            <type name="AuthDomain" c:type="SoupAuthDomain*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the path to add to @domain</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="basic_set_auth_callback"
              c:identifier="soup_auth_domain_basic_set_auth_callback">
        <doc xml:space="preserve">Sets the callback that @domain will use to authenticate incoming
requests. For each request containing authorization, @domain will
invoke the callback, and then either accept or reject the request
based on @callback's return value.

You can also set the auth callback by setting the
%SOUP_AUTH_DOMAIN_BASIC_AUTH_CALLBACK and
%SOUP_AUTH_DOMAIN_BASIC_AUTH_DATA properties, which can also be
used to set the callback at construct time.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">the domain</doc>
            <type name="AuthDomain" c:type="SoupAuthDomain*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:space="preserve">the callback</doc>
            <type name="AuthDomainBasicAuthCallback"
                  c:type="SoupAuthDomainBasicAuthCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">data to pass to @auth_callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="dnotify" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">destroy notifier to free @user_data when @domain
is destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="challenge" c:identifier="soup_auth_domain_challenge">
        <doc xml:space="preserve">Adds a "WWW-Authenticate" or "Proxy-Authenticate" header to @msg,
requesting that the client authenticate, and sets @msg's status
accordingly.

This is used by #SoupServer internally and is probably of no use to
anyone else.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuthDomain</doc>
            <type name="AuthDomain" c:type="SoupAuthDomain*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
        </parameters>
      </method>
      <method name="check_password"
              c:identifier="soup_auth_domain_check_password">
        <doc xml:space="preserve">Checks if @msg authenticates to @domain via @username and
@password. This would normally be called from a
#SoupAuthDomainGenericAuthCallback.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether or not the message is authenticated</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuthDomain</doc>
            <type name="AuthDomain" c:type="SoupAuthDomain*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
          <parameter name="username" transfer-ownership="none">
            <doc xml:space="preserve">a username</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="password" transfer-ownership="none">
            <doc xml:space="preserve">a password</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="covers" c:identifier="soup_auth_domain_covers">
        <doc xml:space="preserve">Checks if @domain requires @msg to be authenticated (according to
its paths and filter function). This does not actually look at
whether @msg &lt;emphasis&gt;is&lt;/emphasis&gt; authenticated, merely whether
or not it needs to be.

This is used by #SoupServer internally and is probably of no use to
anyone else.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @domain requires @msg to be authenticated</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuthDomain</doc>
            <type name="AuthDomain" c:type="SoupAuthDomain*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
        </parameters>
      </method>
      <method name="digest_set_auth_callback"
              c:identifier="soup_auth_domain_digest_set_auth_callback">
        <doc xml:space="preserve">Sets the callback that @domain will use to authenticate incoming
requests. For each request containing authorization, @domain will
invoke the callback, and then either accept or reject the request
based on @callback's return value.

You can also set the auth callback by setting the
%SOUP_AUTH_DOMAIN_DIGEST_AUTH_CALLBACK and
%SOUP_AUTH_DOMAIN_DIGEST_AUTH_DATA properties, which can also be
used to set the callback at construct time.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">the domain</doc>
            <type name="AuthDomain" c:type="SoupAuthDomain*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:space="preserve">the callback</doc>
            <type name="AuthDomainDigestAuthCallback"
                  c:type="SoupAuthDomainDigestAuthCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">data to pass to @auth_callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="dnotify" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">destroy notifier to free @user_data when @domain
is destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_realm" c:identifier="soup_auth_domain_get_realm">
        <doc xml:space="preserve">Gets the realm name associated with @domain</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@domain's realm</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuthDomain</doc>
            <type name="AuthDomain" c:type="SoupAuthDomain*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="remove_path" c:identifier="soup_auth_domain_remove_path">
        <doc xml:space="preserve">Removes @path from @domain, such that requests under @path on
@domain's server will NOT require authentication.

This is not simply an undo-er for soup_auth_domain_add_path(); it
can be used to "carve out" a subtree that does not require
authentication inside a hierarchy that does. Note also that unlike
with soup_auth_domain_add_path(), this cannot be overridden by
adding a filter, as filters can only bypass authentication that
would otherwise be required, not require it where it would
otherwise be unnecessary.

You can also remove paths by setting the
%SOUP_AUTH_DOMAIN_REMOVE_PATH property, which can also be used to
remove one or more paths at construct time.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuthDomain</doc>
            <type name="AuthDomain" c:type="SoupAuthDomain*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the path to remove from @domain</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_filter" c:identifier="soup_auth_domain_set_filter">
        <doc xml:space="preserve">Adds @filter as an authentication filter to @domain. The filter
gets a chance to bypass authentication for certain requests that
would otherwise require it. Eg, it might check the message's path
in some way that is too complicated to do via the other methods, or
it might check the message's method, and allow GETs but not PUTs.

The filter function returns %TRUE if the request should still
require authentication, or %FALSE if authentication is unnecessary
for this request.

To help prevent security holes, your filter should return %TRUE by
default, and only return %FALSE under specifically-tested
circumstances, rather than the other way around. Eg, in the example
above, where you want to authenticate PUTs but not GETs, you should
check if the method is GET and return %FALSE in that case, and then
return %TRUE for all other methods (rather than returning %TRUE for
PUT and %FALSE for all other methods). This way if it turned out
(now or later) that some paths supported additional methods besides
GET and PUT, those methods would default to being NOT allowed for
unauthenticated users.

You can also set the filter by setting the %SOUP_AUTH_DOMAIN_FILTER
and %SOUP_AUTH_DOMAIN_FILTER_DATA properties, which can also be
used to set the filter at construct time.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuthDomain</doc>
            <type name="AuthDomain" c:type="SoupAuthDomain*"/>
          </instance-parameter>
          <parameter name="filter"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:space="preserve">the auth filter for @domain</doc>
            <type name="AuthDomainFilter" c:type="SoupAuthDomainFilter"/>
          </parameter>
          <parameter name="filter_data" transfer-ownership="none">
            <doc xml:space="preserve">data to pass to @filter</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="dnotify" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">destroy notifier to free @filter_data when @domain
is destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_generic_auth_callback"
              c:identifier="soup_auth_domain_set_generic_auth_callback">
        <doc xml:space="preserve">Sets @auth_callback as an authentication-handling callback for
@domain. Whenever a request comes in to @domain which cannot be
authenticated via a domain-specific auth callback (eg,
#SoupAuthDomainDigestAuthCallback), the generic auth callback
will be invoked. See #SoupAuthDomainGenericAuthCallback for information
on what the callback should do.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuthDomain</doc>
            <type name="AuthDomain" c:type="SoupAuthDomain*"/>
          </instance-parameter>
          <parameter name="auth_callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:space="preserve">the auth callback</doc>
            <type name="AuthDomainGenericAuthCallback"
                  c:type="SoupAuthDomainGenericAuthCallback"/>
          </parameter>
          <parameter name="auth_data" transfer-ownership="none">
            <doc xml:space="preserve">data to pass to @auth_callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="dnotify" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">destroy notifier to free @auth_data when @domain
is destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="try_generic_auth_callback"
              c:identifier="soup_auth_domain_try_generic_auth_callback">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="domain" transfer-ownership="none">
            <type name="AuthDomain" c:type="SoupAuthDomain*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
          <parameter name="username" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <property name="add-path"
                readable="0"
                writable="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="filter" writable="1" transfer-ownership="none">
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <property name="filter-data" writable="1" transfer-ownership="none">
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <property name="generic-auth-callback"
                writable="1"
                transfer-ownership="none">
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <property name="generic-auth-data"
                writable="1"
                transfer-ownership="none">
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <property name="proxy"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="realm"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="remove-path"
                readable="0"
                writable="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <class name="AuthDomainBasic"
           c:symbol-prefix="auth_domain_basic"
           c:type="SoupAuthDomainBasic"
           parent="AuthDomain"
           glib:type-name="SoupAuthDomainBasic"
           glib:get-type="soup_auth_domain_basic_get_type"
           glib:type-struct="AuthDomainBasicClass">
      <constructor name="new"
                   c:identifier="soup_auth_domain_basic_new"
                   introspectable="0">
        <doc xml:space="preserve">Creates a #SoupAuthDomainBasic. You must set the
%SOUP_AUTH_DOMAIN_REALM parameter, to indicate the realm name to be
returned with the authentication challenge to the client. Other
parameters are optional.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #SoupAuthDomain</doc>
          <type name="AuthDomain" c:type="SoupAuthDomain*"/>
        </return-value>
        <parameters>
          <parameter name="optname1" transfer-ownership="none">
            <doc xml:space="preserve">name of first option, or %NULL</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">option name/value pairs</doc>
            <varargs/>
          </parameter>
        </parameters>
      </constructor>
      <property name="auth-callback" writable="1" transfer-ownership="none">
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <property name="auth-data" writable="1" transfer-ownership="none">
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <field name="parent">
        <type name="AuthDomain" c:type="SoupAuthDomain"/>
      </field>
    </class>
    <callback name="AuthDomainBasicAuthCallback"
              c:type="SoupAuthDomainBasicAuthCallback">
      <doc xml:space="preserve">Callback used by #SoupAuthDomainBasic for authentication purposes.
The application should verify that @username and @password and valid
and return %TRUE or %FALSE.

If you are maintaining your own password database (rather than
using the password to authenticate against some other system like
PAM or a remote server), you should make sure you know what you are
doing. In particular, don't store cleartext passwords, or
easily-computed hashes of cleartext passwords, even if you don't
care that much about the security of your server, because users
will frequently use the same password for multiple sites, and so
compromising any site with a cleartext (or easily-cracked) password
database may give attackers access to other more-interesting sites
as well.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @username and @password are valid</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve">the domain</doc>
          <type name="AuthDomain" c:type="SoupAuthDomain*"/>
        </parameter>
        <parameter name="msg" transfer-ownership="none">
          <doc xml:space="preserve">the message being authenticated</doc>
          <type name="Message" c:type="SoupMessage*"/>
        </parameter>
        <parameter name="username" transfer-ownership="none">
          <doc xml:space="preserve">the username provided by the client</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="password" transfer-ownership="none">
          <doc xml:space="preserve">the password provided by the client</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="4">
          <doc xml:space="preserve">the data passed to soup_auth_domain_basic_set_auth_callback()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="AuthDomainBasicClass"
            c:type="SoupAuthDomainBasicClass"
            glib:is-gtype-struct-for="AuthDomainBasic">
      <field name="parent_class">
        <type name="AuthDomainClass" c:type="SoupAuthDomainClass"/>
      </field>
      <field name="_libsoup_reserved1" introspectable="0">
        <callback name="_libsoup_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_libsoup_reserved2" introspectable="0">
        <callback name="_libsoup_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_libsoup_reserved3" introspectable="0">
        <callback name="_libsoup_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_libsoup_reserved4" introspectable="0">
        <callback name="_libsoup_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="AuthDomainClass"
            c:type="SoupAuthDomainClass"
            glib:is-gtype-struct-for="AuthDomain">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="accepts">
        <callback name="accepts">
          <return-value transfer-ownership="full">
            <type name="utf8" c:type="char*"/>
          </return-value>
          <parameters>
            <parameter name="domain" transfer-ownership="none">
              <type name="AuthDomain" c:type="SoupAuthDomain*"/>
            </parameter>
            <parameter name="msg" transfer-ownership="none">
              <type name="Message" c:type="SoupMessage*"/>
            </parameter>
            <parameter name="header" transfer-ownership="none">
              <type name="utf8" c:type="const char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="challenge">
        <callback name="challenge">
          <return-value transfer-ownership="full">
            <type name="utf8" c:type="char*"/>
          </return-value>
          <parameters>
            <parameter name="domain" transfer-ownership="none">
              <type name="AuthDomain" c:type="SoupAuthDomain*"/>
            </parameter>
            <parameter name="msg" transfer-ownership="none">
              <type name="Message" c:type="SoupMessage*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="check_password">
        <callback name="check_password">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">whether or not the message is authenticated</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="domain" transfer-ownership="none">
              <doc xml:space="preserve">a #SoupAuthDomain</doc>
              <type name="AuthDomain" c:type="SoupAuthDomain*"/>
            </parameter>
            <parameter name="msg" transfer-ownership="none">
              <doc xml:space="preserve">a #SoupMessage</doc>
              <type name="Message" c:type="SoupMessage*"/>
            </parameter>
            <parameter name="username" transfer-ownership="none">
              <doc xml:space="preserve">a username</doc>
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="password" transfer-ownership="none">
              <doc xml:space="preserve">a password</doc>
              <type name="utf8" c:type="const char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_libsoup_reserved2" introspectable="0">
        <callback name="_libsoup_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_libsoup_reserved3" introspectable="0">
        <callback name="_libsoup_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_libsoup_reserved4" introspectable="0">
        <callback name="_libsoup_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <class name="AuthDomainDigest"
           c:symbol-prefix="auth_domain_digest"
           c:type="SoupAuthDomainDigest"
           parent="AuthDomain"
           glib:type-name="SoupAuthDomainDigest"
           glib:get-type="soup_auth_domain_digest_get_type"
           glib:type-struct="AuthDomainDigestClass">
      <constructor name="new"
                   c:identifier="soup_auth_domain_digest_new"
                   introspectable="0">
        <doc xml:space="preserve">Creates a #SoupAuthDomainDigest. You must set the
%SOUP_AUTH_DOMAIN_REALM parameter, to indicate the realm name to be
returned with the authentication challenge to the client. Other
parameters are optional.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #SoupAuthDomain</doc>
          <type name="AuthDomain" c:type="SoupAuthDomain*"/>
        </return-value>
        <parameters>
          <parameter name="optname1" transfer-ownership="none">
            <doc xml:space="preserve">name of first option, or %NULL</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">option name/value pairs</doc>
            <varargs/>
          </parameter>
        </parameters>
      </constructor>
      <function name="encode_password"
                c:identifier="soup_auth_domain_digest_encode_password">
        <doc xml:space="preserve">Encodes the username/realm/password triplet for Digest
authentication. (That is, it returns a stringified MD5 hash of
@username, @realm, and @password concatenated together). This is
the form that is needed as the return value of
#SoupAuthDomainDigest's auth handler.

For security reasons, you should store the encoded hash, rather
than storing the cleartext password itself and calling this method
only when you need to verify it. This way, if your server is
compromised, the attackers will not gain access to cleartext
passwords which might also be usable at other sites. (Note also
that the encoded password returned by this method is identical to
the encoded password stored in an Apache .htdigest file.)</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the encoded password</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <parameter name="username" transfer-ownership="none">
            <doc xml:space="preserve">a username</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="realm" transfer-ownership="none">
            <doc xml:space="preserve">an auth realm name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="password" transfer-ownership="none">
            <doc xml:space="preserve">the password for @username in @realm</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </function>
      <property name="auth-callback" writable="1" transfer-ownership="none">
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <property name="auth-data" writable="1" transfer-ownership="none">
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <field name="parent">
        <type name="AuthDomain" c:type="SoupAuthDomain"/>
      </field>
    </class>
    <callback name="AuthDomainDigestAuthCallback"
              c:type="SoupAuthDomainDigestAuthCallback">
      <doc xml:space="preserve">Callback used by #SoupAuthDomainDigest for authentication purposes.
The application should look up @username in its password database,
and return the corresponding encoded password (see
soup_auth_domain_digest_encode_password()).</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">the encoded password, or %NULL if
@username is not a valid user. @domain will free the password when
it is done with it.</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve">the domain</doc>
          <type name="AuthDomain" c:type="SoupAuthDomain*"/>
        </parameter>
        <parameter name="msg" transfer-ownership="none">
          <doc xml:space="preserve">the message being authenticated</doc>
          <type name="Message" c:type="SoupMessage*"/>
        </parameter>
        <parameter name="username" transfer-ownership="none">
          <doc xml:space="preserve">the username provided by the client</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="3">
          <doc xml:space="preserve">the data passed to soup_auth_domain_digest_set_auth_callback()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="AuthDomainDigestClass"
            c:type="SoupAuthDomainDigestClass"
            glib:is-gtype-struct-for="AuthDomainDigest">
      <field name="parent_class">
        <type name="AuthDomainClass" c:type="SoupAuthDomainClass"/>
      </field>
      <field name="_libsoup_reserved1" introspectable="0">
        <callback name="_libsoup_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_libsoup_reserved2" introspectable="0">
        <callback name="_libsoup_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_libsoup_reserved3" introspectable="0">
        <callback name="_libsoup_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_libsoup_reserved4" introspectable="0">
        <callback name="_libsoup_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <callback name="AuthDomainFilter" c:type="SoupAuthDomainFilter">
      <doc xml:space="preserve">The prototype for a #SoupAuthDomain filter; see
soup_auth_domain_set_filter() for details.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @msg requires authentication, %FALSE if not.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve">a #SoupAuthDomain</doc>
          <type name="AuthDomain" c:type="SoupAuthDomain*"/>
        </parameter>
        <parameter name="msg" transfer-ownership="none">
          <doc xml:space="preserve">a #SoupMessage</doc>
          <type name="Message" c:type="SoupMessage*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:space="preserve">the data passed to soup_auth_domain_set_filter()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="AuthDomainGenericAuthCallback"
              c:type="SoupAuthDomainGenericAuthCallback">
      <doc xml:space="preserve">The prototype for a #SoupAuthDomain generic authentication callback.

The callback should look up the user's password, call
soup_auth_domain_check_password(), and use the return value from
that method as its own return value.

In general, for security reasons, it is preferable to use the
auth-domain-specific auth callbacks (eg,
#SoupAuthDomainBasicAuthCallback and
#SoupAuthDomainDigestAuthCallback), because they don't require
keeping a cleartext password database. Most users will use the same
password for many different sites, meaning if any site with a
cleartext password database is compromised, accounts on other
servers might be compromised as well. For many of the cases where
#SoupServer is used, this is not really relevant, but it may still
be worth considering.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @msg is authenticated, %FALSE if not.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve">a #SoupAuthDomain</doc>
          <type name="AuthDomain" c:type="SoupAuthDomain*"/>
        </parameter>
        <parameter name="msg" transfer-ownership="none">
          <doc xml:space="preserve">the #SoupMessage being authenticated</doc>
          <type name="Message" c:type="SoupMessage*"/>
        </parameter>
        <parameter name="username" transfer-ownership="none">
          <doc xml:space="preserve">the username from @msg</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="3">
          <doc xml:space="preserve">the data passed to
soup_auth_domain_set_generic_auth_callback()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="AuthManager"
           c:symbol-prefix="auth_manager"
           c:type="SoupAuthManager"
           parent="GObject.Object"
           glib:type-name="SoupAuthManager"
           glib:get-type="soup_auth_manager_get_type"
           glib:type-struct="AuthManagerClass">
      <implements name="SessionFeature"/>
      <virtual-method name="authenticate">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="manager" transfer-ownership="none">
            <type name="AuthManager" c:type="SoupAuthManager*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
          <parameter name="auth" transfer-ownership="none">
            <type name="Auth" c:type="SoupAuth*"/>
          </parameter>
          <parameter name="retrying" transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="use_auth"
              c:identifier="soup_auth_manager_use_auth"
              version="2.42">
        <doc xml:space="preserve">Records that @auth is to be used under @uri, as though a
WWW-Authenticate header had been received at that URI. This can be
used to "preload" @manager's auth cache, to avoid an extra HTTP
round trip in the case where you know ahead of time that a 401
response will be returned.

This is only useful for authentication types where the initial
Authorization header does not depend on any additional information
from the server. (Eg, Basic or NTLM, but not Digest.)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="manager" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuthManager</doc>
            <type name="AuthManager" c:type="SoupAuthManager*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">the #SoupURI under which @auth is to be used</doc>
            <type name="URI" c:type="SoupURI*"/>
          </parameter>
          <parameter name="auth" transfer-ownership="none">
            <doc xml:space="preserve">the #SoupAuth to use</doc>
            <type name="Auth" c:type="SoupAuth*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="AuthManagerPrivate" c:type="SoupAuthManagerPrivate*"/>
      </field>
      <glib:signal name="authenticate" when="first">
        <doc xml:space="preserve">Emitted when the manager requires the application to
provide authentication credentials.

#SoupSession connects to this signal and emits its own
#SoupSession::authenticate signal when it is emitted, so
you shouldn't need to use this signal directly.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">the #SoupMessage being sent</doc>
            <type name="Message"/>
          </parameter>
          <parameter name="auth" transfer-ownership="none">
            <doc xml:space="preserve">the #SoupAuth to authenticate</doc>
            <type name="Auth"/>
          </parameter>
          <parameter name="retrying" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if this is the second (or later) attempt</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="AuthManagerClass"
            c:type="SoupAuthManagerClass"
            glib:is-gtype-struct-for="AuthManager">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="authenticate">
        <callback name="authenticate">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="manager" transfer-ownership="none">
              <type name="AuthManager" c:type="SoupAuthManager*"/>
            </parameter>
            <parameter name="msg" transfer-ownership="none">
              <type name="Message" c:type="SoupMessage*"/>
            </parameter>
            <parameter name="auth" transfer-ownership="none">
              <type name="Auth" c:type="SoupAuth*"/>
            </parameter>
            <parameter name="retrying" transfer-ownership="none">
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <record name="AuthManagerPrivate"
            c:type="SoupAuthManagerPrivate"
            disguised="1">
    </record>
    <class name="AuthNTLM"
           c:symbol-prefix="auth_ntlm"
           parent="Auth"
           glib:type-name="SoupAuthNTLM"
           glib:get-type="soup_auth_ntlm_get_type">
    </class>
    <record name="Buffer"
            c:type="SoupBuffer"
            glib:type-name="SoupBuffer"
            glib:get-type="soup_buffer_get_type"
            c:symbol-prefix="buffer">
      <doc xml:space="preserve">A data buffer, generally used to represent a chunk of a
#SoupMessageBody.

@data is a #char because that's generally convenient; in some
situations you may need to cast it to #guchar or another type.</doc>
      <field name="data" writable="1">
        <doc xml:space="preserve">the data</doc>
        <type name="gpointer"/>
      </field>
      <field name="length" writable="1">
        <doc xml:space="preserve">length of @data</doc>
        <type name="gsize" c:type="gsize"/>
      </field>
      <constructor name="new"
                   c:identifier="soup_buffer_new"
                   shadowed-by="new_take">
        <doc xml:space="preserve">Creates a new #SoupBuffer containing @length bytes from @data.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #SoupBuffer.</doc>
          <type name="Buffer" c:type="SoupBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="use" transfer-ownership="none">
            <doc xml:space="preserve">how @data is to be used by the buffer</doc>
            <type name="MemoryUse" c:type="SoupMemoryUse"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">data</doc>
            <array length="2" zero-terminated="0" c:type="gconstpointer">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">length of @data</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_take"
                   c:identifier="soup_buffer_new_take"
                   shadows="new"
                   version="2.32">
        <doc xml:space="preserve">Creates a new #SoupBuffer containing @length bytes from @data.

This function is exactly equivalent to soup_buffer_new() with
%SOUP_MEMORY_TAKE as first argument; it exists mainly for
convenience and simplifying language bindings.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #SoupBuffer.</doc>
          <type name="Buffer" c:type="SoupBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="full">
            <doc xml:space="preserve">data</doc>
            <array length="1" zero-terminated="0" c:type="guchar*">
              <type name="guint8" c:type="guchar"/>
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">length of @data</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_owner"
                   c:identifier="soup_buffer_new_with_owner">
        <doc xml:space="preserve">Creates a new #SoupBuffer containing @length bytes from @data. When
the #SoupBuffer is freed, it will call @owner_dnotify, passing
@owner to it. You must ensure that @data will remain valid until
@owner_dnotify is called.

For example, you could use this to create a buffer containing data
returned from libxml without needing to do an extra copy:

&lt;informalexample&gt;&lt;programlisting&gt;
xmlDocDumpMemory (doc, &amp;xmlbody, &amp;len);
return soup_buffer_new_with_owner (xmlbody, len, xmlbody,
                                   (GDestroyNotify)xmlFree);
&lt;/programlisting&gt;&lt;/informalexample&gt;

In this example, @data and @owner are the same, but in other cases
they would be different (eg, @owner would be a object, and @data
would be a pointer to one of the object's fields).</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #SoupBuffer.</doc>
          <type name="Buffer" c:type="SoupBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">data</doc>
            <array length="1" zero-terminated="0" c:type="gconstpointer">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">length of @data</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="owner" transfer-ownership="none">
            <doc xml:space="preserve">pointer to an object that owns @data</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="owner_dnotify"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async">
            <doc xml:space="preserve">a function to free/unref @owner when
the buffer is freed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="copy" c:identifier="soup_buffer_copy">
        <doc xml:space="preserve">Makes a copy of @buffer. In reality, #SoupBuffer is a refcounted
type, and calling soup_buffer_copy() will normally just increment
the refcount on @buffer and return it. However, if @buffer was
created with #SOUP_MEMORY_TEMPORARY memory, then soup_buffer_copy()
will actually return a copy of it, so that the data in the copy
will remain valid after the temporary buffer is freed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new (or newly-reffed) buffer</doc>
          <type name="Buffer" c:type="SoupBuffer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupBuffer</doc>
            <type name="Buffer" c:type="SoupBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="soup_buffer_free">
        <doc xml:space="preserve">Frees @buffer. (In reality, as described in the documentation for
soup_buffer_copy(), this is actually an "unref" operation, and may
or may not actually free @buffer.)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupBuffer</doc>
            <type name="Buffer" c:type="SoupBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_as_bytes"
              c:identifier="soup_buffer_get_as_bytes"
              version="2.40">
        <doc xml:space="preserve">Creates a #GBytes pointing to the same memory as @buffer. The
#GBytes will hold a reference on @buffer to ensure that it is not
freed while the #GBytes is still valid.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GBytes which has the same content
as the #SoupBuffer.</doc>
          <type name="GLib.Bytes" c:type="GBytes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupBuffer</doc>
            <type name="Buffer" c:type="SoupBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_data"
              c:identifier="soup_buffer_get_data"
              version="2.32">
        <doc xml:space="preserve">This function exists for use by language bindings, because it's not
currently possible to get the right effect by annotating the fields
of #SoupBuffer.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupBuffer</doc>
            <type name="Buffer" c:type="SoupBuffer*"/>
          </instance-parameter>
          <parameter name="data"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:space="preserve">the pointer
to the buffer data is stored here</doc>
            <array length="1" zero-terminated="0" c:type="guint8**">
              <type name="guint8" c:type="guint8*"/>
            </array>
          </parameter>
          <parameter name="length"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">the length of the buffer data is stored here</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_owner" c:identifier="soup_buffer_get_owner">
        <doc xml:space="preserve">Gets the "owner" object for a buffer created with
soup_buffer_new_with_owner().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the owner pointer</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupBuffer created with soup_buffer_new_with_owner()</doc>
            <type name="Buffer" c:type="SoupBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="new_subbuffer" c:identifier="soup_buffer_new_subbuffer">
        <doc xml:space="preserve">Creates a new #SoupBuffer containing @length bytes "copied" from
@parent starting at @offset. (Normally this will not actually copy
any data, but will instead simply reference the same data as
@parent does.)</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #SoupBuffer.</doc>
          <type name="Buffer" c:type="SoupBuffer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="parent" transfer-ownership="none">
            <doc xml:space="preserve">the parent #SoupBuffer</doc>
            <type name="Buffer" c:type="SoupBuffer*"/>
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve">offset within @parent to start at</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">number of bytes to copy from @parent</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <glib:boxed glib:name="ByteArray"
                c:symbol-prefix="byte_array"
                glib:type-name="SoupByteArray"
                glib:get-type="soup_byte_array_get_type">
    </glib:boxed>
    <constant name="CACHE_H" value="1" c:type="SOUP_CACHE_H">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CHAR_HTTP_CTL" value="16" c:type="SOUP_CHAR_HTTP_CTL">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CHAR_HTTP_SEPARATOR"
              value="8"
              c:type="SOUP_CHAR_HTTP_SEPARATOR">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CHAR_URI_GEN_DELIMS"
              value="2"
              c:type="SOUP_CHAR_URI_GEN_DELIMS">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CHAR_URI_PERCENT_ENCODED"
              value="1"
              c:type="SOUP_CHAR_URI_PERCENT_ENCODED">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CHAR_URI_SUB_DELIMS"
              value="4"
              c:type="SOUP_CHAR_URI_SUB_DELIMS">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CONTENT_DECODER_H"
              value="1"
              c:type="SOUP_CONTENT_DECODER_H">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CONTENT_SNIFFER_H"
              value="1"
              c:type="SOUP_CONTENT_SNIFFER_H">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="COOKIE_H" value="1" c:type="SOUP_COOKIE_H">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="COOKIE_JAR_ACCEPT_POLICY"
              value="accept-policy"
              c:type="SOUP_COOKIE_JAR_ACCEPT_POLICY"
              version="2.30">
      <doc xml:space="preserve">Alias for the #SoupCookieJar:accept-policy property.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="COOKIE_JAR_H" value="1" c:type="SOUP_COOKIE_JAR_H">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="COOKIE_JAR_READ_ONLY"
              value="read-only"
              c:type="SOUP_COOKIE_JAR_READ_ONLY">
      <doc xml:space="preserve">Alias for the #SoupCookieJar:read-only property. (Whether
or not the cookie jar is read-only.)</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="COOKIE_JAR_TEXT_FILENAME"
              value="filename"
              c:type="SOUP_COOKIE_JAR_TEXT_FILENAME">
      <doc xml:space="preserve">Alias for the #SoupCookieJarText:filename property. (The
cookie-storage filename.)</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="COOKIE_JAR_TEXT_H"
              value="1"
              c:type="SOUP_COOKIE_JAR_TEXT_H">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="COOKIE_MAX_AGE_ONE_DAY"
              value="0"
              c:type="SOUP_COOKIE_MAX_AGE_ONE_DAY"
              version="2.24">
      <doc xml:space="preserve">A constant corresponding to 1 day, for use with soup_cookie_new()
and soup_cookie_set_max_age().</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="COOKIE_MAX_AGE_ONE_HOUR"
              value="3600"
              c:type="SOUP_COOKIE_MAX_AGE_ONE_HOUR"
              version="2.24">
      <doc xml:space="preserve">A constant corresponding to 1 hour, for use with soup_cookie_new()
and soup_cookie_set_max_age().</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="COOKIE_MAX_AGE_ONE_WEEK"
              value="0"
              c:type="SOUP_COOKIE_MAX_AGE_ONE_WEEK"
              version="2.24">
      <doc xml:space="preserve">A constant corresponding to 1 week, for use with soup_cookie_new()
and soup_cookie_set_max_age().</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="COOKIE_MAX_AGE_ONE_YEAR"
              value="0"
              c:type="SOUP_COOKIE_MAX_AGE_ONE_YEAR"
              version="2.24">
      <doc xml:space="preserve">A constant corresponding to 1 year, for use with soup_cookie_new()
and soup_cookie_set_max_age().</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <class name="Cache"
           c:symbol-prefix="cache"
           c:type="SoupCache"
           parent="GObject.Object"
           glib:type-name="SoupCache"
           glib:get-type="soup_cache_get_type"
           glib:type-struct="CacheClass">
      <implements name="SessionFeature"/>
      <constructor name="new" c:identifier="soup_cache_new" version="2.34">
        <doc xml:space="preserve">Creates a new #SoupCache.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #SoupCache</doc>
          <type name="Cache" c:type="SoupCache*"/>
        </return-value>
        <parameters>
          <parameter name="cache_dir" transfer-ownership="none">
            <doc xml:space="preserve">the directory to store the cached data, or %NULL to use the default one</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="cache_type" transfer-ownership="none">
            <doc xml:space="preserve">the #SoupCacheType of the cache</doc>
            <type name="CacheType" c:type="SoupCacheType"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="get_cacheability">
        <return-value transfer-ownership="none">
          <type name="Cacheability" c:type="SoupCacheability"/>
        </return-value>
        <parameters>
          <instance-parameter name="cache" transfer-ownership="none">
            <type name="Cache" c:type="SoupCache*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="clear" c:identifier="soup_cache_clear" version="2.34">
        <doc xml:space="preserve">Will remove all entries in the @cache plus all the cache files.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cache" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCache</doc>
            <type name="Cache" c:type="SoupCache*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dump" c:identifier="soup_cache_dump" version="2.34.">
        <doc xml:space="preserve">Synchronously writes the cache index out to disk. Contrast with
soup_cache_flush(), which writes pending cache
&lt;emphasis&gt;entries&lt;/emphasis&gt; to disk.

You must call this before exiting if you want your cache data to
persist between sessions.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cache" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCache</doc>
            <type name="Cache" c:type="SoupCache*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="flush" c:identifier="soup_cache_flush" version="2.34">
        <doc xml:space="preserve">This function will force all pending writes in the @cache to be
committed to disk. For doing so it will iterate the #GMainContext
associated with @cache's session as long as needed.

Contrast with soup_cache_dump(), which writes out the cache index
file.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cache" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCache</doc>
            <type name="Cache" c:type="SoupCache*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_max_size"
              c:identifier="soup_cache_get_max_size"
              version="2.34">
        <doc xml:space="preserve">Gets the maximum size of the cache.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the maximum size of the cache, in bytes.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="cache" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCache</doc>
            <type name="Cache" c:type="SoupCache*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="load" c:identifier="soup_cache_load" version="2.34">
        <doc xml:space="preserve">Loads the contents of @cache's index into memory.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cache" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCache</doc>
            <type name="Cache" c:type="SoupCache*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_max_size"
              c:identifier="soup_cache_set_max_size"
              version="2.34">
        <doc xml:space="preserve">Sets the maximum size of the cache.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cache" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCache</doc>
            <type name="Cache" c:type="SoupCache*"/>
          </instance-parameter>
          <parameter name="max_size" transfer-ownership="none">
            <doc xml:space="preserve">the maximum size of the cache, in bytes</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <property name="cache-dir"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="cache-type"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="CacheType"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="CachePrivate" c:type="SoupCachePrivate*"/>
      </field>
    </class>
    <record name="CacheClass"
            c:type="SoupCacheClass"
            glib:is-gtype-struct-for="Cache">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="get_cacheability">
        <callback name="get_cacheability">
          <return-value transfer-ownership="none">
            <type name="Cacheability" c:type="SoupCacheability"/>
          </return-value>
          <parameters>
            <parameter name="cache" transfer-ownership="none">
              <type name="Cache" c:type="SoupCache*"/>
            </parameter>
            <parameter name="msg" transfer-ownership="none">
              <type name="Message" c:type="SoupMessage*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_libsoup_reserved1" introspectable="0">
        <callback name="_libsoup_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_libsoup_reserved2" introspectable="0">
        <callback name="_libsoup_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_libsoup_reserved3" introspectable="0">
        <callback name="_libsoup_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="CachePrivate" c:type="SoupCachePrivate" disguised="1">
    </record>
    <enumeration name="CacheResponse"
                 glib:type-name="SoupCacheResponse"
                 glib:get-type="soup_cache_response_get_type"
                 c:type="SoupCacheResponse">
      <member name="fresh"
              value="0"
              c:identifier="SOUP_CACHE_RESPONSE_FRESH"
              glib:nick="fresh">
      </member>
      <member name="needs_validation"
              value="1"
              c:identifier="SOUP_CACHE_RESPONSE_NEEDS_VALIDATION"
              glib:nick="needs-validation">
      </member>
      <member name="stale"
              value="2"
              c:identifier="SOUP_CACHE_RESPONSE_STALE"
              glib:nick="stale">
      </member>
    </enumeration>
    <enumeration name="CacheType"
                 version="2.34"
                 glib:type-name="SoupCacheType"
                 glib:get-type="soup_cache_type_get_type"
                 c:type="SoupCacheType">
      <doc xml:space="preserve">The type of cache; this affects what kinds of responses will be
saved.</doc>
      <member name="single_user"
              value="0"
              c:identifier="SOUP_CACHE_SINGLE_USER"
              glib:nick="single-user">
        <doc xml:space="preserve">a single-user cache</doc>
      </member>
      <member name="shared"
              value="1"
              c:identifier="SOUP_CACHE_SHARED"
              glib:nick="shared">
        <doc xml:space="preserve">a shared cache</doc>
      </member>
    </enumeration>
    <bitfield name="Cacheability"
              glib:type-name="SoupCacheability"
              glib:get-type="soup_cacheability_get_type"
              c:type="SoupCacheability">
      <member name="cacheable"
              value="1"
              c:identifier="SOUP_CACHE_CACHEABLE"
              glib:nick="cacheable">
      </member>
      <member name="uncacheable"
              value="2"
              c:identifier="SOUP_CACHE_UNCACHEABLE"
              glib:nick="uncacheable">
      </member>
      <member name="invalidates"
              value="4"
              c:identifier="SOUP_CACHE_INVALIDATES"
              glib:nick="invalidates">
      </member>
      <member name="validates"
              value="8"
              c:identifier="SOUP_CACHE_VALIDATES"
              glib:nick="validates">
      </member>
    </bitfield>
    <callback name="ChunkAllocator" c:type="SoupChunkAllocator" deprecated="1">
      <doc xml:space="preserve">The prototype for a chunk allocation callback. This should allocate
a new #SoupBuffer and return it for the I/O layer to read message
body data off the network into.

If @max_len is non-0, it indicates the maximum number of bytes that
could be read, based on what is known about the message size. Note
that this might be a very large number, and you should not simply
try to allocate that many bytes blindly. If @max_len is 0, that
means that libsoup does not know how many bytes remain to be read,
and the allocator should return a buffer of a size that it finds
convenient.

If the allocator returns %NULL, the message will be paused. It is
up to the application to make sure that it gets unpaused when it
becomes possible to allocate a new buffer.</doc>
      <doc-deprecated xml:space="preserve">Use #SoupRequest if you want to read into your
own buffers.</doc-deprecated>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">the new buffer (or %NULL)</doc>
        <type name="Buffer" c:type="SoupBuffer*"/>
      </return-value>
      <parameters>
        <parameter name="msg" transfer-ownership="none">
          <doc xml:space="preserve">the #SoupMessage the chunk is being allocated for</doc>
          <type name="Message" c:type="SoupMessage*"/>
        </parameter>
        <parameter name="max_len" transfer-ownership="none">
          <doc xml:space="preserve">the maximum length that will be read, or 0.</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:space="preserve">the data passed to soup_message_set_chunk_allocator()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="ClientContext"
            c:type="SoupClientContext"
            glib:type-name="SoupClientContext"
            glib:get-type="soup_client_context_get_type"
            c:symbol-prefix="client_context">
      <doc xml:space="preserve">A #SoupClientContext provides additional information about the
client making a particular request. In particular, you can use
soup_client_context_get_auth_domain() and
soup_client_context_get_auth_user() to determine if HTTP
authentication was used successfully.

soup_client_context_get_remote_address() and/or
soup_client_context_get_host() can be used to get information for
logging or debugging purposes. soup_client_context_get_gsocket() may
also be of use in some situations (eg, tracking when multiple
requests are made on the same connection).</doc>
      <method name="get_address"
              c:identifier="soup_client_context_get_address"
              deprecated="1">
        <doc xml:space="preserve">Retrieves the #SoupAddress associated with the remote end
of a connection.</doc>
        <doc-deprecated xml:space="preserve">Use soup_client_context_get_remote_address(), which returns
a #GSocketAddress.</doc-deprecated>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the #SoupAddress
associated with the remote end of a connection, it may be
%NULL if you used soup_server_accept_iostream().</doc>
          <type name="Address" c:type="SoupAddress*"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupClientContext</doc>
            <type name="ClientContext" c:type="SoupClientContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_auth_domain"
              c:identifier="soup_client_context_get_auth_domain">
        <doc xml:space="preserve">Checks whether the request associated with @client has been
authenticated, and if so returns the #SoupAuthDomain that
authenticated it.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">a #SoupAuthDomain, or
%NULL if the request was not authenticated.</doc>
          <type name="AuthDomain" c:type="SoupAuthDomain*"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupClientContext</doc>
            <type name="ClientContext" c:type="SoupClientContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_auth_user"
              c:identifier="soup_client_context_get_auth_user">
        <doc xml:space="preserve">Checks whether the request associated with @client has been
authenticated, and if so returns the username that the client
authenticated as.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the authenticated-as user, or %NULL if
the request was not authenticated.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupClientContext</doc>
            <type name="ClientContext" c:type="SoupClientContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_gsocket"
              c:identifier="soup_client_context_get_gsocket"
              version="2.48">
        <doc xml:space="preserve">Retrieves the #GSocket that @client is associated with.

If you are using this method to observe when multiple requests are
made on the same persistent HTTP connection (eg, as the ntlm-test
test program does), you will need to pay attention to socket
destruction as well (eg, by using weak references), so that you do
not get fooled when the allocator reuses the memory address of a
previously-destroyed socket to represent a new socket.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the #GSocket that @client is
associated with, %NULL if you used soup_server_accept_iostream().</doc>
          <type name="Gio.Socket" c:type="GSocket*"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupClientContext</doc>
            <type name="ClientContext" c:type="SoupClientContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_host" c:identifier="soup_client_context_get_host">
        <doc xml:space="preserve">Retrieves the IP address associated with the remote end of a
connection.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the IP address associated with the remote
end of a connection, it may be %NULL if you used
soup_server_accept_iostream().</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupClientContext</doc>
            <type name="ClientContext" c:type="SoupClientContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_local_address"
              c:identifier="soup_client_context_get_local_address"
              version="2.48">
        <doc xml:space="preserve">Retrieves the #GSocketAddress associated with the local end
of a connection.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the #GSocketAddress
associated with the local end of a connection, it may be
%NULL if you used soup_server_accept_iostream().</doc>
          <type name="Gio.SocketAddress" c:type="GSocketAddress*"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupClientContext</doc>
            <type name="ClientContext" c:type="SoupClientContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_remote_address"
              c:identifier="soup_client_context_get_remote_address"
              version="2.48">
        <doc xml:space="preserve">Retrieves the #GSocketAddress associated with the remote end
of a connection.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the #GSocketAddress
associated with the remote end of a connection, it may be
%NULL if you used soup_server_accept_iostream().</doc>
          <type name="Gio.SocketAddress" c:type="GSocketAddress*"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupClientContext</doc>
            <type name="ClientContext" c:type="SoupClientContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_socket"
              c:identifier="soup_client_context_get_socket"
              deprecated="1">
        <doc xml:space="preserve">Retrieves the #SoupSocket that @client is associated with.

If you are using this method to observe when multiple requests are
made on the same persistent HTTP connection (eg, as the ntlm-test
test program does), you will need to pay attention to socket
destruction as well (either by using weak references, or by
connecting to the #SoupSocket::disconnected signal), so that you do
not get fooled when the allocator reuses the memory address of a
previously-destroyed socket to represent a new socket.</doc>
        <doc-deprecated xml:space="preserve">use soup_client_context_get_gsocket(), which returns
a #GSocket.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #SoupSocket that @client is
associated with.</doc>
          <type name="Socket" c:type="SoupSocket*"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupClientContext</doc>
            <type name="ClientContext" c:type="SoupClientContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="steal_connection"
              c:identifier="soup_client_context_steal_connection"
              version="2.50">
        <doc xml:space="preserve">"Steals" the HTTP connection associated with @client from its
#SoupServer. This happens immediately, regardless of the current
state of the connection; if the response to the current
#SoupMessage has not yet finished being sent, then it will be
discarded; you can steal the connection from a
#SoupMessage:wrote-informational or #SoupMessage:wrote-body signal
handler if you need to wait for part or all of the response to be
sent.

Note that when calling this function from C, @client will most
likely be freed as a side effect.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the #GIOStream formerly associated
  with @client (or %NULL if @client was no longer associated with a
  connection). No guarantees are made about what kind of #GIOStream
  is returned.</doc>
          <type name="Gio.IOStream" c:type="GIOStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupClientContext</doc>
            <type name="ClientContext" c:type="SoupClientContext*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <record name="Connection" c:type="SoupConnection" disguised="1">
    </record>
    <enumeration name="ConnectionState"
                 glib:type-name="SoupConnectionState"
                 glib:get-type="soup_connection_state_get_type"
                 c:type="SoupConnectionState">
      <member name="new"
              value="0"
              c:identifier="SOUP_CONNECTION_NEW"
              glib:nick="new">
      </member>
      <member name="connecting"
              value="1"
              c:identifier="SOUP_CONNECTION_CONNECTING"
              glib:nick="connecting">
      </member>
      <member name="idle"
              value="2"
              c:identifier="SOUP_CONNECTION_IDLE"
              glib:nick="idle">
      </member>
      <member name="in_use"
              value="3"
              c:identifier="SOUP_CONNECTION_IN_USE"
              glib:nick="in-use">
      </member>
      <member name="remote_disconnected"
              value="4"
              c:identifier="SOUP_CONNECTION_REMOTE_DISCONNECTED"
              glib:nick="remote-disconnected">
      </member>
      <member name="disconnected"
              value="5"
              c:identifier="SOUP_CONNECTION_DISCONNECTED"
              glib:nick="disconnected">
      </member>
    </enumeration>
    <class name="ContentDecoder"
           c:symbol-prefix="content_decoder"
           c:type="SoupContentDecoder"
           parent="GObject.Object"
           glib:type-name="SoupContentDecoder"
           glib:get-type="soup_content_decoder_get_type"
           glib:type-struct="ContentDecoderClass">
      <implements name="SessionFeature"/>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="ContentDecoderPrivate"
              c:type="SoupContentDecoderPrivate*"/>
      </field>
    </class>
    <record name="ContentDecoderClass"
            c:type="SoupContentDecoderClass"
            glib:is-gtype-struct-for="ContentDecoder">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="_libsoup_reserved1" introspectable="0">
        <callback name="_libsoup_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_libsoup_reserved2" introspectable="0">
        <callback name="_libsoup_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_libsoup_reserved3" introspectable="0">
        <callback name="_libsoup_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_libsoup_reserved4" introspectable="0">
        <callback name="_libsoup_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_libsoup_reserved5" introspectable="0">
        <callback name="_libsoup_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="ContentDecoderPrivate"
            c:type="SoupContentDecoderPrivate"
            disguised="1">
    </record>
    <class name="ContentSniffer"
           c:symbol-prefix="content_sniffer"
           c:type="SoupContentSniffer"
           parent="GObject.Object"
           glib:type-name="SoupContentSniffer"
           glib:get-type="soup_content_sniffer_get_type"
           glib:type-struct="ContentSnifferClass">
      <implements name="SessionFeature"/>
      <constructor name="new"
                   c:identifier="soup_content_sniffer_new"
                   version="2.28">
        <doc xml:space="preserve">Creates a new #SoupContentSniffer.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #SoupContentSniffer</doc>
          <type name="ContentSniffer" c:type="SoupContentSniffer*"/>
        </return-value>
      </constructor>
      <virtual-method name="get_buffer_size"
                      invoker="get_buffer_size"
                      version="2.28">
        <doc xml:space="preserve">Gets the number of bytes @sniffer needs in order to properly sniff
a buffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of bytes to sniff</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <instance-parameter name="sniffer" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupContentSniffer</doc>
            <type name="ContentSniffer" c:type="SoupContentSniffer*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="sniff" invoker="sniff" version="2.28">
        <doc xml:space="preserve">Sniffs @buffer to determine its Content-Type. The result may also
be influenced by the Content-Type declared in @msg's response
headers.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the sniffed Content-Type of @buffer; this will never be %NULL,
  but may be "application/octet-stream".</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="sniffer" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupContentSniffer</doc>
            <type name="ContentSniffer" c:type="SoupContentSniffer*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">the message to sniff</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">a buffer containing the start of @msg's response body</doc>
            <type name="Buffer" c:type="SoupBuffer*"/>
          </parameter>
          <parameter name="params"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">return
  location for Content-Type parameters (eg, "charset"), or %NULL</doc>
            <type name="GLib.HashTable" c:type="GHashTable**">
              <type name="utf8"/>
              <type name="utf8"/>
            </type>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_buffer_size"
              c:identifier="soup_content_sniffer_get_buffer_size"
              version="2.28">
        <doc xml:space="preserve">Gets the number of bytes @sniffer needs in order to properly sniff
a buffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of bytes to sniff</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <instance-parameter name="sniffer" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupContentSniffer</doc>
            <type name="ContentSniffer" c:type="SoupContentSniffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="sniff"
              c:identifier="soup_content_sniffer_sniff"
              version="2.28">
        <doc xml:space="preserve">Sniffs @buffer to determine its Content-Type. The result may also
be influenced by the Content-Type declared in @msg's response
headers.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the sniffed Content-Type of @buffer; this will never be %NULL,
  but may be "application/octet-stream".</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="sniffer" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupContentSniffer</doc>
            <type name="ContentSniffer" c:type="SoupContentSniffer*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">the message to sniff</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">a buffer containing the start of @msg's response body</doc>
            <type name="Buffer" c:type="SoupBuffer*"/>
          </parameter>
          <parameter name="params"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">return
  location for Content-Type parameters (eg, "charset"), or %NULL</doc>
            <type name="GLib.HashTable" c:type="GHashTable**">
              <type name="utf8"/>
              <type name="utf8"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="ContentSnifferPrivate"
              c:type="SoupContentSnifferPrivate*"/>
      </field>
    </class>
    <record name="ContentSnifferClass"
            c:type="SoupContentSnifferClass"
            glib:is-gtype-struct-for="ContentSniffer">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="sniff">
        <callback name="sniff">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">the sniffed Content-Type of @buffer; this will never be %NULL,
  but may be "application/octet-stream".</doc>
            <type name="utf8" c:type="char*"/>
          </return-value>
          <parameters>
            <parameter name="sniffer" transfer-ownership="none">
              <doc xml:space="preserve">a #SoupContentSniffer</doc>
              <type name="ContentSniffer" c:type="SoupContentSniffer*"/>
            </parameter>
            <parameter name="msg" transfer-ownership="none">
              <doc xml:space="preserve">the message to sniff</doc>
              <type name="Message" c:type="SoupMessage*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <doc xml:space="preserve">a buffer containing the start of @msg's response body</doc>
              <type name="Buffer" c:type="SoupBuffer*"/>
            </parameter>
            <parameter name="params"
                       direction="out"
                       caller-allocates="0"
                       transfer-ownership="full"
                       optional="1"
                       allow-none="1">
              <doc xml:space="preserve">return
  location for Content-Type parameters (eg, "charset"), or %NULL</doc>
              <type name="GLib.HashTable" c:type="GHashTable**">
                <type name="utf8"/>
                <type name="utf8"/>
              </type>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_buffer_size">
        <callback name="get_buffer_size">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes to sniff</doc>
            <type name="gsize" c:type="gsize"/>
          </return-value>
          <parameters>
            <parameter name="sniffer" transfer-ownership="none">
              <doc xml:space="preserve">a #SoupContentSniffer</doc>
              <type name="ContentSniffer" c:type="SoupContentSniffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_libsoup_reserved1" introspectable="0">
        <callback name="_libsoup_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_libsoup_reserved2" introspectable="0">
        <callback name="_libsoup_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_libsoup_reserved3" introspectable="0">
        <callback name="_libsoup_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_libsoup_reserved4" introspectable="0">
        <callback name="_libsoup_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_libsoup_reserved5" introspectable="0">
        <callback name="_libsoup_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="ContentSnifferPrivate"
            c:type="SoupContentSnifferPrivate"
            disguised="1">
    </record>
    <record name="Cookie"
            c:type="SoupCookie"
            version="2.24"
            glib:type-name="SoupCookie"
            glib:get-type="soup_cookie_get_type"
            c:symbol-prefix="cookie">
      <doc xml:space="preserve">An HTTP cookie.

@name and @value will be set for all cookies. If the cookie is
generated from a string that appears to have no name, then @name
will be the empty string.

@domain and @path give the host or domain, and path within that
host/domain, to restrict this cookie to. If @domain starts with
".", that indicates a domain (which matches the string after the
".", or any hostname that has @domain as a suffix). Otherwise, it
is a hostname and must match exactly.

@expires will be non-%NULL if the cookie uses either the original
"expires" attribute, or the newer "max-age" attribute. If @expires
is %NULL, it indicates that neither "expires" nor "max-age" was
specified, and the cookie expires at the end of the session.

If @http_only is set, the cookie should not be exposed to untrusted
code (eg, javascript), so as to minimize the danger posed by
cross-site scripting attacks.</doc>
      <field name="name" writable="1">
        <doc xml:space="preserve">the cookie name</doc>
        <type name="utf8" c:type="char*"/>
      </field>
      <field name="value" writable="1">
        <doc xml:space="preserve">the cookie value</doc>
        <type name="utf8" c:type="char*"/>
      </field>
      <field name="domain" writable="1">
        <doc xml:space="preserve">the "domain" attribute, or else the hostname that the
cookie came from.</doc>
        <type name="utf8" c:type="char*"/>
      </field>
      <field name="path" writable="1">
        <doc xml:space="preserve">the "path" attribute, or %NULL</doc>
        <type name="utf8" c:type="char*"/>
      </field>
      <field name="expires" writable="1">
        <doc xml:space="preserve">the cookie expiration time, or %NULL for a session cookie</doc>
        <type name="Date" c:type="SoupDate*"/>
      </field>
      <field name="secure" writable="1">
        <doc xml:space="preserve">%TRUE if the cookie should only be tranferred over SSL</doc>
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="http_only" writable="1">
        <doc xml:space="preserve">%TRUE if the cookie should not be exposed to scripts</doc>
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <constructor name="new" c:identifier="soup_cookie_new" version="2.24">
        <doc xml:space="preserve">Creates a new #SoupCookie with the given attributes. (Use
soup_cookie_set_secure() and soup_cookie_set_http_only() if you
need to set those attributes on the returned cookie.)

If @domain starts with ".", that indicates a domain (which matches
the string after the ".", or any hostname that has @domain as a
suffix). Otherwise, it is a hostname and must match exactly.

@max_age is used to set the "expires" attribute on the cookie; pass
-1 to not include the attribute (indicating that the cookie expires
with the current session), 0 for an already-expired cookie, or a
lifetime in seconds. You can use the constants
%SOUP_COOKIE_MAX_AGE_ONE_HOUR, %SOUP_COOKIE_MAX_AGE_ONE_DAY,
%SOUP_COOKIE_MAX_AGE_ONE_WEEK and %SOUP_COOKIE_MAX_AGE_ONE_YEAR (or
multiples thereof) to calculate this value. (If you really care
about setting the exact time that the cookie will expire, use
soup_cookie_set_expires().)</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #SoupCookie.</doc>
          <type name="Cookie" c:type="SoupCookie*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">cookie name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">cookie value</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">cookie domain or hostname</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">cookie path, or %NULL</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="max_age" transfer-ownership="none">
            <doc xml:space="preserve">max age of the cookie, or -1 for a session cookie</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="applies_to_uri"
              c:identifier="soup_cookie_applies_to_uri"
              version="2.24">
        <doc xml:space="preserve">Tests if @cookie should be sent to @uri.

(At the moment, this does not check that @cookie's domain matches
@uri, because it assumes that the caller has already done that.
But don't rely on that; it may change in the future.)</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @cookie should be sent to @uri, %FALSE if
not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="cookie" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookie</doc>
            <type name="Cookie" c:type="SoupCookie*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupURI</doc>
            <type name="URI" c:type="SoupURI*"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy" c:identifier="soup_cookie_copy" version="2.24">
        <doc xml:space="preserve">Copies @cookie.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a copy of @cookie</doc>
          <type name="Cookie" c:type="SoupCookie*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cookie" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookie</doc>
            <type name="Cookie" c:type="SoupCookie*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="domain_matches"
              c:identifier="soup_cookie_domain_matches"
              version="2.30">
        <doc xml:space="preserve">Checks if the @cookie's domain and @host match in the sense that
@cookie should be sent when making a request to @host, or that
@cookie should be accepted when receiving a response from @host.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the domains match, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="cookie" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookie</doc>
            <type name="Cookie" c:type="SoupCookie*"/>
          </instance-parameter>
          <parameter name="host" transfer-ownership="none">
            <doc xml:space="preserve">a URI</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="equal" c:identifier="soup_cookie_equal" version="2.24">
        <doc xml:space="preserve">Tests if @cookie1 and @cookie2 are equal.

Note that currently, this does not check that the cookie domains
match. This may change in the future.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether the cookies are equal.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="cookie1" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookie</doc>
            <type name="Cookie" c:type="SoupCookie*"/>
          </instance-parameter>
          <parameter name="cookie2" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookie</doc>
            <type name="Cookie" c:type="SoupCookie*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="soup_cookie_free" version="2.24">
        <doc xml:space="preserve">Frees @cookie</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cookie" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookie</doc>
            <type name="Cookie" c:type="SoupCookie*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_domain"
              c:identifier="soup_cookie_get_domain"
              version="2.32">
        <doc xml:space="preserve">Gets @cookie's domain</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@cookie's domain</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cookie" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookie</doc>
            <type name="Cookie" c:type="SoupCookie*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_expires"
              c:identifier="soup_cookie_get_expires"
              version="2.32">
        <doc xml:space="preserve">Gets @cookie's expiration time</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@cookie's expiration time, which is
owned by @cookie and should not be modified or freed.</doc>
          <type name="Date" c:type="SoupDate*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cookie" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookie</doc>
            <type name="Cookie" c:type="SoupCookie*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_http_only"
              c:identifier="soup_cookie_get_http_only"
              version="2.32">
        <doc xml:space="preserve">Gets @cookie's HttpOnly attribute</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@cookie's HttpOnly attribute</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="cookie" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookie</doc>
            <type name="Cookie" c:type="SoupCookie*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_name"
              c:identifier="soup_cookie_get_name"
              version="2.32">
        <doc xml:space="preserve">Gets @cookie's name</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@cookie's name</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cookie" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookie</doc>
            <type name="Cookie" c:type="SoupCookie*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_path"
              c:identifier="soup_cookie_get_path"
              version="2.32">
        <doc xml:space="preserve">Gets @cookie's path</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@cookie's path</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cookie" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookie</doc>
            <type name="Cookie" c:type="SoupCookie*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_secure"
              c:identifier="soup_cookie_get_secure"
              version="2.32">
        <doc xml:space="preserve">Gets @cookie's secure attribute</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@cookie's secure attribute</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="cookie" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookie</doc>
            <type name="Cookie" c:type="SoupCookie*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_value"
              c:identifier="soup_cookie_get_value"
              version="2.32">
        <doc xml:space="preserve">Gets @cookie's value</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@cookie's value</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cookie" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookie</doc>
            <type name="Cookie" c:type="SoupCookie*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_domain"
              c:identifier="soup_cookie_set_domain"
              version="2.24">
        <doc xml:space="preserve">Sets @cookie's domain to @domain</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cookie" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookie</doc>
            <type name="Cookie" c:type="SoupCookie*"/>
          </instance-parameter>
          <parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">the new domain</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_expires"
              c:identifier="soup_cookie_set_expires"
              version="2.24">
        <doc xml:space="preserve">Sets @cookie's expiration time to @expires. If @expires is %NULL,
@cookie will be a session cookie and will expire at the end of the
client's session.

(This sets the same property as soup_cookie_set_max_age().)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cookie" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookie</doc>
            <type name="Cookie" c:type="SoupCookie*"/>
          </instance-parameter>
          <parameter name="expires" transfer-ownership="none">
            <doc xml:space="preserve">the new expiration time, or %NULL</doc>
            <type name="Date" c:type="SoupDate*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_http_only"
              c:identifier="soup_cookie_set_http_only"
              version="2.24">
        <doc xml:space="preserve">Sets @cookie's HttpOnly attribute to @http_only. If %TRUE, @cookie
will be marked as "http only", meaning it should not be exposed to
web page scripts or other untrusted code.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cookie" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookie</doc>
            <type name="Cookie" c:type="SoupCookie*"/>
          </instance-parameter>
          <parameter name="http_only" transfer-ownership="none">
            <doc xml:space="preserve">the new value for the HttpOnly attribute</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_max_age"
              c:identifier="soup_cookie_set_max_age"
              version="2.24">
        <doc xml:space="preserve">Sets @cookie's max age to @max_age. If @max_age is -1, the cookie
is a session cookie, and will expire at the end of the client's
session. Otherwise, it is the number of seconds until the cookie
expires. You can use the constants %SOUP_COOKIE_MAX_AGE_ONE_HOUR,
%SOUP_COOKIE_MAX_AGE_ONE_DAY, %SOUP_COOKIE_MAX_AGE_ONE_WEEK and
%SOUP_COOKIE_MAX_AGE_ONE_YEAR (or multiples thereof) to calculate
this value. (A value of 0 indicates that the cookie should be
considered already-expired.)

(This sets the same property as soup_cookie_set_expires().)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cookie" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookie</doc>
            <type name="Cookie" c:type="SoupCookie*"/>
          </instance-parameter>
          <parameter name="max_age" transfer-ownership="none">
            <doc xml:space="preserve">the new max age</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_name"
              c:identifier="soup_cookie_set_name"
              version="2.24">
        <doc xml:space="preserve">Sets @cookie's name to @name</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cookie" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookie</doc>
            <type name="Cookie" c:type="SoupCookie*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the new name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_path"
              c:identifier="soup_cookie_set_path"
              version="2.24">
        <doc xml:space="preserve">Sets @cookie's path to @path</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cookie" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookie</doc>
            <type name="Cookie" c:type="SoupCookie*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the new path</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_secure"
              c:identifier="soup_cookie_set_secure"
              version="2.24">
        <doc xml:space="preserve">Sets @cookie's secure attribute to @secure. If %TRUE, @cookie will
only be transmitted from the client to the server over secure
(https) connections.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cookie" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookie</doc>
            <type name="Cookie" c:type="SoupCookie*"/>
          </instance-parameter>
          <parameter name="secure" transfer-ownership="none">
            <doc xml:space="preserve">the new value for the secure attribute</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_value"
              c:identifier="soup_cookie_set_value"
              version="2.24">
        <doc xml:space="preserve">Sets @cookie's value to @value</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cookie" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookie</doc>
            <type name="Cookie" c:type="SoupCookie*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the new value</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_cookie_header"
              c:identifier="soup_cookie_to_cookie_header"
              version="2.24">
        <doc xml:space="preserve">Serializes @cookie in the format used by the Cookie header (ie, for
returning a cookie from a #SoupSession to a server).</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the header</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cookie" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookie</doc>
            <type name="Cookie" c:type="SoupCookie*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="to_set_cookie_header"
              c:identifier="soup_cookie_to_set_cookie_header"
              version="2.24">
        <doc xml:space="preserve">Serializes @cookie in the format used by the Set-Cookie header
(ie, for sending a cookie from a #SoupServer to a client).</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the header</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cookie" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookie</doc>
            <type name="Cookie" c:type="SoupCookie*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="parse" c:identifier="soup_cookie_parse" version="2.24">
        <doc xml:space="preserve">Parses @header and returns a #SoupCookie. (If @header contains
multiple cookies, only the first one will be parsed.)

If @header does not have "path" or "domain" attributes, they will
be defaulted from @origin. If @origin is %NULL, path will default
to "/", but domain will be left as %NULL. Note that this is not a
valid state for a #SoupCookie, and you will need to fill in some
appropriate string for the domain if you want to actually make use
of the cookie.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a new #SoupCookie, or %NULL if it could
not be parsed, or contained an illegal "domain" attribute for a
cookie originating from @origin.</doc>
          <type name="Cookie" c:type="SoupCookie*"/>
        </return-value>
        <parameters>
          <parameter name="header" transfer-ownership="none">
            <doc xml:space="preserve">a cookie string (eg, the value of a Set-Cookie header)</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="origin" transfer-ownership="none">
            <doc xml:space="preserve">origin of the cookie, or %NULL</doc>
            <type name="URI" c:type="SoupURI*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <class name="CookieJar"
           c:symbol-prefix="cookie_jar"
           c:type="SoupCookieJar"
           parent="GObject.Object"
           glib:type-name="SoupCookieJar"
           glib:get-type="soup_cookie_jar_get_type"
           glib:type-struct="CookieJarClass">
      <implements name="SessionFeature"/>
      <constructor name="new"
                   c:identifier="soup_cookie_jar_new"
                   version="2.24">
        <doc xml:space="preserve">Creates a new #SoupCookieJar. The base #SoupCookieJar class does
not support persistent storage of cookies; use a subclass for that.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #SoupCookieJar</doc>
          <type name="CookieJar" c:type="SoupCookieJar*"/>
        </return-value>
      </constructor>
      <virtual-method name="changed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="jar" transfer-ownership="none">
            <type name="CookieJar" c:type="SoupCookieJar*"/>
          </instance-parameter>
          <parameter name="old_cookie" transfer-ownership="none">
            <type name="Cookie" c:type="SoupCookie*"/>
          </parameter>
          <parameter name="new_cookie" transfer-ownership="none">
            <type name="Cookie" c:type="SoupCookie*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="is_persistent"
                      invoker="is_persistent"
                      version="2.40">
        <doc xml:space="preserve">Gets whether @jar stores cookies persistenly.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @jar storage is persistent or %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="jar" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookieJar</doc>
            <type name="CookieJar" c:type="SoupCookieJar*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="save" invoker="save" version="2.24" deprecated="1">
        <doc xml:space="preserve">This function exists for backward compatibility, but does not do
anything any more; cookie jars are saved automatically when they
are changed.</doc>
        <doc-deprecated xml:space="preserve">This is a no-op.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="jar" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookieJar</doc>
            <type name="CookieJar" c:type="SoupCookieJar*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="add_cookie"
              c:identifier="soup_cookie_jar_add_cookie"
              version="2.26">
        <doc xml:space="preserve">Adds @cookie to @jar, emitting the 'changed' signal if we are modifying
an existing cookie or adding a valid new cookie ('valid' means
that the cookie's expire date is not in the past).

@cookie will be 'stolen' by the jar, so don't free it afterwards.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="jar" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookieJar</doc>
            <type name="CookieJar" c:type="SoupCookieJar*"/>
          </instance-parameter>
          <parameter name="cookie" transfer-ownership="full">
            <doc xml:space="preserve">a #SoupCookie</doc>
            <type name="Cookie" c:type="SoupCookie*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_cookie_with_first_party"
              c:identifier="soup_cookie_jar_add_cookie_with_first_party"
              version="2.40">
        <doc xml:space="preserve">Adds @cookie to @jar, emitting the 'changed' signal if we are modifying
an existing cookie or adding a valid new cookie ('valid' means
that the cookie's expire date is not in the past).

@first_party will be used to reject cookies coming from third party
resources in case such a security policy is set in the @jar.

@cookie will be 'stolen' by the jar, so don't free it afterwards.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="jar" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookieJar</doc>
            <type name="CookieJar" c:type="SoupCookieJar*"/>
          </instance-parameter>
          <parameter name="first_party" transfer-ownership="none">
            <doc xml:space="preserve">the URI for the main document</doc>
            <type name="URI" c:type="SoupURI*"/>
          </parameter>
          <parameter name="cookie" transfer-ownership="full">
            <doc xml:space="preserve">a #SoupCookie</doc>
            <type name="Cookie" c:type="SoupCookie*"/>
          </parameter>
        </parameters>
      </method>
      <method name="all_cookies"
              c:identifier="soup_cookie_jar_all_cookies"
              version="2.26">
        <doc xml:space="preserve">Constructs a #GSList with every cookie inside the @jar.
The cookies in the list are a copy of the original, so
you have to free them when you are done with them.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GSList
with all the cookies in the @jar.</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="Cookie"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="jar" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookieJar</doc>
            <type name="CookieJar" c:type="SoupCookieJar*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="delete_cookie"
              c:identifier="soup_cookie_jar_delete_cookie"
              version="2.26">
        <doc xml:space="preserve">Deletes @cookie from @jar, emitting the 'changed' signal.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="jar" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookieJar</doc>
            <type name="CookieJar" c:type="SoupCookieJar*"/>
          </instance-parameter>
          <parameter name="cookie" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookie</doc>
            <type name="Cookie" c:type="SoupCookie*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_accept_policy"
              c:identifier="soup_cookie_jar_get_accept_policy"
              version="2.30">
        <doc xml:space="preserve">Gets @jar's #SoupCookieJarAcceptPolicy</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #SoupCookieJarAcceptPolicy set in the @jar</doc>
          <type name="CookieJarAcceptPolicy"
                c:type="SoupCookieJarAcceptPolicy"/>
        </return-value>
        <parameters>
          <instance-parameter name="jar" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookieJar</doc>
            <type name="CookieJar" c:type="SoupCookieJar*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_cookie_list"
              c:identifier="soup_cookie_jar_get_cookie_list"
              version="2.40">
        <doc xml:space="preserve">Retrieves the list of cookies that would be sent with a request to @uri
as a #GSList of #SoupCookie objects.

If @for_http is %TRUE, the return value will include cookies marked
"HttpOnly" (that is, cookies that the server wishes to keep hidden
from client-side scripting operations such as the JavaScript
document.cookies property). Since #SoupCookieJar sets the Cookie
header itself when making the actual HTTP request, you should
almost certainly be setting @for_http to %FALSE if you are calling
this.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GSList
with the cookies in the @jar that would be sent with a request to @uri.</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="Cookie"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="jar" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookieJar</doc>
            <type name="CookieJar" c:type="SoupCookieJar*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupURI</doc>
            <type name="URI" c:type="SoupURI*"/>
          </parameter>
          <parameter name="for_http" transfer-ownership="none">
            <doc xml:space="preserve">whether or not the return value is being passed directly
to an HTTP operation</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_cookies"
              c:identifier="soup_cookie_jar_get_cookies"
              version="2.24">
        <doc xml:space="preserve">Retrieves (in Cookie-header form) the list of cookies that would
be sent with a request to @uri.

If @for_http is %TRUE, the return value will include cookies marked
"HttpOnly" (that is, cookies that the server wishes to keep hidden
from client-side scripting operations such as the JavaScript
document.cookies property). Since #SoupCookieJar sets the Cookie
header itself when making the actual HTTP request, you should
almost certainly be setting @for_http to %FALSE if you are calling
this.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the cookies, in string form, or %NULL if
there are no cookies for @uri.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="jar" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookieJar</doc>
            <type name="CookieJar" c:type="SoupCookieJar*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupURI</doc>
            <type name="URI" c:type="SoupURI*"/>
          </parameter>
          <parameter name="for_http" transfer-ownership="none">
            <doc xml:space="preserve">whether or not the return value is being passed directly
to an HTTP operation</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_persistent"
              c:identifier="soup_cookie_jar_is_persistent"
              version="2.40">
        <doc xml:space="preserve">Gets whether @jar stores cookies persistenly.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @jar storage is persistent or %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="jar" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookieJar</doc>
            <type name="CookieJar" c:type="SoupCookieJar*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="save"
              c:identifier="soup_cookie_jar_save"
              version="2.24"
              deprecated="1">
        <doc xml:space="preserve">This function exists for backward compatibility, but does not do
anything any more; cookie jars are saved automatically when they
are changed.</doc>
        <doc-deprecated xml:space="preserve">This is a no-op.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="jar" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookieJar</doc>
            <type name="CookieJar" c:type="SoupCookieJar*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_accept_policy"
              c:identifier="soup_cookie_jar_set_accept_policy"
              version="2.30">
        <doc xml:space="preserve">Sets @policy as the cookie acceptance policy for @jar.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="jar" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookieJar</doc>
            <type name="CookieJar" c:type="SoupCookieJar*"/>
          </instance-parameter>
          <parameter name="policy" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookieJarAcceptPolicy</doc>
            <type name="CookieJarAcceptPolicy"
                  c:type="SoupCookieJarAcceptPolicy"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_cookie"
              c:identifier="soup_cookie_jar_set_cookie"
              version="2.24">
        <doc xml:space="preserve">Adds @cookie to @jar, exactly as though it had appeared in a
Set-Cookie header returned from a request to @uri.

Keep in mind that if the #SoupCookieJarAcceptPolicy
%SOUP_COOKIE_JAR_ACCEPT_NO_THIRD_PARTY is set you'll need to use
soup_cookie_jar_set_cookie_with_first_party(), otherwise the jar
will have no way of knowing if the cookie is being set by a third
party or not.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="jar" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookieJar</doc>
            <type name="CookieJar" c:type="SoupCookieJar*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">the URI setting the cookie</doc>
            <type name="URI" c:type="SoupURI*"/>
          </parameter>
          <parameter name="cookie" transfer-ownership="none">
            <doc xml:space="preserve">the stringified cookie to set</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_cookie_with_first_party"
              c:identifier="soup_cookie_jar_set_cookie_with_first_party"
              version="2.30">
        <doc xml:space="preserve">Adds @cookie to @jar, exactly as though it had appeared in a
Set-Cookie header returned from a request to @uri. @first_party
will be used to reject cookies coming from third party resources in
case such a security policy is set in the @jar.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="jar" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookieJar</doc>
            <type name="CookieJar" c:type="SoupCookieJar*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">the URI setting the cookie</doc>
            <type name="URI" c:type="SoupURI*"/>
          </parameter>
          <parameter name="first_party" transfer-ownership="none">
            <doc xml:space="preserve">the URI for the main document</doc>
            <type name="URI" c:type="SoupURI*"/>
          </parameter>
          <parameter name="cookie" transfer-ownership="none">
            <doc xml:space="preserve">the stringified cookie to set</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <property name="accept-policy"
                version="2.30"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The policy the jar should follow to accept or reject cookies</doc>
        <type name="CookieJarAcceptPolicy"/>
      </property>
      <property name="read-only"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <glib:signal name="changed" when="first">
        <doc xml:space="preserve">Emitted when @jar changes. If a cookie has been added,
@new_cookie will contain the newly-added cookie and
@old_cookie will be %NULL. If a cookie has been deleted,
@old_cookie will contain the to-be-deleted cookie and
@new_cookie will be %NULL. If a cookie has been changed,
@old_cookie will contain its old value, and @new_cookie its
new value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="old_cookie" transfer-ownership="none">
            <doc xml:space="preserve">the old #SoupCookie value</doc>
            <type name="Cookie"/>
          </parameter>
          <parameter name="new_cookie" transfer-ownership="none">
            <doc xml:space="preserve">the new #SoupCookie value</doc>
            <type name="Cookie"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <enumeration name="CookieJarAcceptPolicy"
                 version="2.30"
                 glib:type-name="SoupCookieJarAcceptPolicy"
                 glib:get-type="soup_cookie_jar_accept_policy_get_type"
                 c:type="SoupCookieJarAcceptPolicy">
      <doc xml:space="preserve">The policy for accepting or rejecting cookies returned in
responses.</doc>
      <member name="always"
              value="0"
              c:identifier="SOUP_COOKIE_JAR_ACCEPT_ALWAYS"
              glib:nick="always">
        <doc xml:space="preserve">accept all cookies unconditionally.</doc>
      </member>
      <member name="never"
              value="1"
              c:identifier="SOUP_COOKIE_JAR_ACCEPT_NEVER"
              glib:nick="never">
        <doc xml:space="preserve">reject all cookies unconditionally.</doc>
      </member>
      <member name="no_third_party"
              value="2"
              c:identifier="SOUP_COOKIE_JAR_ACCEPT_NO_THIRD_PARTY"
              glib:nick="no-third-party">
        <doc xml:space="preserve">accept all cookies set by
the main document loaded in the application using libsoup. An
example of the most common case, web browsers, would be: If
http://www.example.com is the page loaded, accept all cookies set
by example.com, but if a resource from http://www.third-party.com
is loaded from that page reject any cookie that it could try to
set. For libsoup to be able to tell apart first party cookies from
the rest, the application must call soup_message_set_first_party()
on each outgoing #SoupMessage, setting the #SoupURI of the main
document. If no first party is set in a message when this policy is
in effect, cookies will be assumed to be third party by default.</doc>
      </member>
    </enumeration>
    <record name="CookieJarClass"
            c:type="SoupCookieJarClass"
            glib:is-gtype-struct-for="CookieJar">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="save">
        <callback name="save">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="jar" transfer-ownership="none">
              <doc xml:space="preserve">a #SoupCookieJar</doc>
              <type name="CookieJar" c:type="SoupCookieJar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="is_persistent">
        <callback name="is_persistent">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if @jar storage is persistent or %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="jar" transfer-ownership="none">
              <doc xml:space="preserve">a #SoupCookieJar</doc>
              <type name="CookieJar" c:type="SoupCookieJar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="changed">
        <callback name="changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="jar" transfer-ownership="none">
              <type name="CookieJar" c:type="SoupCookieJar*"/>
            </parameter>
            <parameter name="old_cookie" transfer-ownership="none">
              <type name="Cookie" c:type="SoupCookie*"/>
            </parameter>
            <parameter name="new_cookie" transfer-ownership="none">
              <type name="Cookie" c:type="SoupCookie*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_libsoup_reserved1" introspectable="0">
        <callback name="_libsoup_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_libsoup_reserved2" introspectable="0">
        <callback name="_libsoup_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <class name="CookieJarText"
           c:symbol-prefix="cookie_jar_text"
           c:type="SoupCookieJarText"
           parent="CookieJar"
           glib:type-name="SoupCookieJarText"
           glib:get-type="soup_cookie_jar_text_get_type"
           glib:type-struct="CookieJarTextClass">
      <implements name="SessionFeature"/>
      <constructor name="new"
                   c:identifier="soup_cookie_jar_text_new"
                   version="2.26">
        <doc xml:space="preserve">Creates a #SoupCookieJarText.

@filename will be read in at startup to create an initial set of
cookies. If @read_only is %FALSE, then the non-session cookies will
be written to @filename when the 'changed' signal is emitted from
the jar. (If @read_only is %TRUE, then the cookie jar will only be
used for this session, and changes made to it will be lost when the
jar is destroyed.)</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #SoupCookieJar</doc>
          <type name="CookieJar" c:type="SoupCookieJar*"/>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve">the filename to read to/write from</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="read_only" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if @filename is read-only</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </constructor>
      <property name="filename"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="CookieJar" c:type="SoupCookieJar"/>
      </field>
    </class>
    <record name="CookieJarTextClass"
            c:type="SoupCookieJarTextClass"
            glib:is-gtype-struct-for="CookieJarText">
      <field name="parent_class">
        <type name="CookieJarClass" c:type="SoupCookieJarClass"/>
      </field>
      <field name="_libsoup_reserved1" introspectable="0">
        <callback name="_libsoup_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_libsoup_reserved2" introspectable="0">
        <callback name="_libsoup_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_libsoup_reserved3" introspectable="0">
        <callback name="_libsoup_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_libsoup_reserved4" introspectable="0">
        <callback name="_libsoup_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <constant name="DATE_H" value="1" c:type="SOUP_DATE_H">
      <type name="gint" c:type="gint"/>
    </constant>
    <record name="Date"
            c:type="SoupDate"
            glib:type-name="SoupDate"
            glib:get-type="soup_date_get_type"
            c:symbol-prefix="date">
      <doc xml:space="preserve">A date and time. The date is assumed to be in the (proleptic)
Gregorian calendar. The time is in UTC if @utc is %TRUE. Otherwise,
the time is a local time, and @offset gives the offset from UTC in
minutes (such that adding @offset to the time would give the
correct UTC time). If @utc is %FALSE and @offset is 0, then the
%SoupDate represents a "floating" time with no associated timezone
information.</doc>
      <field name="year" writable="1">
        <doc xml:space="preserve">the year, 1 to 9999</doc>
        <type name="gint" c:type="int"/>
      </field>
      <field name="month" writable="1">
        <doc xml:space="preserve">the month, 1 to 12</doc>
        <type name="gint" c:type="int"/>
      </field>
      <field name="day" writable="1">
        <doc xml:space="preserve">day of the month, 1 to 31</doc>
        <type name="gint" c:type="int"/>
      </field>
      <field name="hour" writable="1">
        <doc xml:space="preserve">hour of the day, 0 to 23</doc>
        <type name="gint" c:type="int"/>
      </field>
      <field name="minute" writable="1">
        <doc xml:space="preserve">minute, 0 to 59</doc>
        <type name="gint" c:type="int"/>
      </field>
      <field name="second" writable="1">
        <doc xml:space="preserve">second, 0 to 59 (or up to 61 in the case of leap seconds)</doc>
        <type name="gint" c:type="int"/>
      </field>
      <field name="utc" writable="1">
        <doc xml:space="preserve">%TRUE if the date is in UTC</doc>
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="offset" writable="1">
        <doc xml:space="preserve">offset from UTC</doc>
        <type name="gint" c:type="int"/>
      </field>
      <constructor name="new" c:identifier="soup_date_new">
        <doc xml:space="preserve">Creates a #SoupDate representing the indicated time, UTC.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #SoupDate</doc>
          <type name="Date" c:type="SoupDate*"/>
        </return-value>
        <parameters>
          <parameter name="year" transfer-ownership="none">
            <doc xml:space="preserve">the year (1-9999)</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="month" transfer-ownership="none">
            <doc xml:space="preserve">the month (1-12)</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="day" transfer-ownership="none">
            <doc xml:space="preserve">the day of the month (1-31, as appropriate for @month)</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="hour" transfer-ownership="none">
            <doc xml:space="preserve">the hour (0-23)</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="minute" transfer-ownership="none">
            <doc xml:space="preserve">the minute (0-59)</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="second" transfer-ownership="none">
            <doc xml:space="preserve">the second (0-59, or up to 61 for leap seconds)</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_now" c:identifier="soup_date_new_from_now">
        <doc xml:space="preserve">Creates a #SoupDate representing a time @offset_seconds after the
current time (or before it, if @offset_seconds is negative). If
offset_seconds is 0, returns the current time.

If @offset_seconds would indicate a time not expressible as a
&lt;type&gt;time_t&lt;/type&gt;, the return value will be clamped into range.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #SoupDate</doc>
          <type name="Date" c:type="SoupDate*"/>
        </return-value>
        <parameters>
          <parameter name="offset_seconds" transfer-ownership="none">
            <doc xml:space="preserve">offset from current time</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_string"
                   c:identifier="soup_date_new_from_string">
        <doc xml:space="preserve">Parses @date_string and tries to extract a date from it. This
recognizes all of the "HTTP-date" formats from RFC 2616, all ISO
8601 formats containing both a time and a date, RFC 2822 dates,
and reasonable approximations thereof. (Eg, it is lenient about
whitespace, leading "0"s, etc.)</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a new #SoupDate, or %NULL if @date_string
could not be parsed.</doc>
          <type name="Date" c:type="SoupDate*"/>
        </return-value>
        <parameters>
          <parameter name="date_string" transfer-ownership="none">
            <doc xml:space="preserve">the date in some plausible format</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_time_t"
                   c:identifier="soup_date_new_from_time_t">
        <doc xml:space="preserve">Creates a #SoupDate corresponding to @when</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #SoupDate</doc>
          <type name="Date" c:type="SoupDate*"/>
        </return-value>
        <parameters>
          <parameter name="when" transfer-ownership="none">
            <doc xml:space="preserve">a &lt;type&gt;time_t&lt;/type&gt;</doc>
            <type name="glong" c:type="time_t"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="copy" c:identifier="soup_date_copy" version="2.24">
        <doc xml:space="preserve">Copies @date.</doc>
        <return-value transfer-ownership="full">
          <type name="Date" c:type="SoupDate*"/>
        </return-value>
        <parameters>
          <instance-parameter name="date" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupDate</doc>
            <type name="Date" c:type="SoupDate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="soup_date_free" version="2.24">
        <doc xml:space="preserve">Frees @date.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="date" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupDate</doc>
            <type name="Date" c:type="SoupDate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_day" c:identifier="soup_date_get_day" version="2.32">
        <doc xml:space="preserve">Gets @date's day.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@date's day</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="date" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupDate</doc>
            <type name="Date" c:type="SoupDate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hour" c:identifier="soup_date_get_hour" version="2.32">
        <doc xml:space="preserve">Gets @date's hour.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@date's hour</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="date" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupDate</doc>
            <type name="Date" c:type="SoupDate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_minute"
              c:identifier="soup_date_get_minute"
              version="2.32">
        <doc xml:space="preserve">Gets @date's minute.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@date's minute</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="date" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupDate</doc>
            <type name="Date" c:type="SoupDate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_month"
              c:identifier="soup_date_get_month"
              version="2.32">
        <doc xml:space="preserve">Gets @date's month.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@date's month</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="date" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupDate</doc>
            <type name="Date" c:type="SoupDate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_offset"
              c:identifier="soup_date_get_offset"
              version="2.32">
        <doc xml:space="preserve">Gets @date's offset from UTC.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@date's offset from UTC. If soup_date_get_utc()
returns %FALSE but soup_date_get_offset() returns 0, that means the
date is a "floating" time with no associated offset information.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="date" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupDate</doc>
            <type name="Date" c:type="SoupDate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_second"
              c:identifier="soup_date_get_second"
              version="2.32">
        <doc xml:space="preserve">Gets @date's second.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@date's second</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="date" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupDate</doc>
            <type name="Date" c:type="SoupDate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_utc" c:identifier="soup_date_get_utc" version="2.32">
        <doc xml:space="preserve">Gets @date's UTC flag</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @date is UTC.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="date" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupDate</doc>
            <type name="Date" c:type="SoupDate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_year" c:identifier="soup_date_get_year" version="2.32">
        <doc xml:space="preserve">Gets @date's year.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@date's year</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="date" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupDate</doc>
            <type name="Date" c:type="SoupDate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_past" c:identifier="soup_date_is_past" version="2.24">
        <doc xml:space="preserve">Determines if @date is in the past.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @date is in the past</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="date" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupDate</doc>
            <type name="Date" c:type="SoupDate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="to_string" c:identifier="soup_date_to_string">
        <doc xml:space="preserve">Converts @date to a string in the format described by @format.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">@date as a string</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="date" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupDate</doc>
            <type name="Date" c:type="SoupDate*"/>
          </instance-parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">the format to generate the date in</doc>
            <type name="DateFormat" c:type="SoupDateFormat"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_time_t" c:identifier="soup_date_to_time_t">
        <doc xml:space="preserve">Converts @date to a &lt;type&gt;time_t&lt;/type&gt;.

If @date is not representable as a &lt;type&gt;time_t&lt;/type&gt;, it will be
clamped into range. (In particular, some HTTP cookies have
expiration dates after "Y2.038k" (2038-01-19T03:14:07Z).)</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@date as a &lt;type&gt;time_t&lt;/type&gt;</doc>
          <type name="glong" c:type="time_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="date" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupDate</doc>
            <type name="Date" c:type="SoupDate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="to_timeval"
              c:identifier="soup_date_to_timeval"
              version="2.24">
        <doc xml:space="preserve">Converts @date to a #GTimeVal.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="date" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupDate</doc>
            <type name="Date" c:type="SoupDate*"/>
          </instance-parameter>
          <parameter name="time"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">a #GTimeVal structure in which to store the converted time.</doc>
            <type name="GLib.TimeVal" c:type="GTimeVal*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <enumeration name="DateFormat"
                 glib:type-name="SoupDateFormat"
                 glib:get-type="soup_date_format_get_type"
                 c:type="SoupDateFormat">
      <doc xml:space="preserve">Date formats that soup_date_to_string() can use.

@SOUP_DATE_HTTP and @SOUP_DATE_COOKIE always coerce the time to
UTC. @SOUP_DATE_ISO8601_XMLRPC uses the time as given, ignoring the
offset completely. @SOUP_DATE_RFC2822 and the other ISO 8601
variants use the local time, appending the offset information if
available.

This enum may be extended with more values in future releases.</doc>
      <member name="http"
              value="1"
              c:identifier="SOUP_DATE_HTTP"
              glib:nick="http">
        <doc xml:space="preserve">RFC 1123 format, used by the HTTP "Date" header. Eg
"Sun, 06 Nov 1994 08:49:37 GMT"</doc>
      </member>
      <member name="cookie"
              value="2"
              c:identifier="SOUP_DATE_COOKIE"
              glib:nick="cookie">
        <doc xml:space="preserve">The format for the "Expires" timestamp in the
Netscape cookie specification. Eg, "Sun, 06-Nov-1994 08:49:37 GMT".</doc>
      </member>
      <member name="rfc2822"
              value="3"
              c:identifier="SOUP_DATE_RFC2822"
              glib:nick="rfc2822">
        <doc xml:space="preserve">RFC 2822 format, eg "Sun, 6 Nov 1994 09:49:37 -0100"</doc>
      </member>
      <member name="iso8601_compact"
              value="4"
              c:identifier="SOUP_DATE_ISO8601_COMPACT"
              glib:nick="iso8601-compact">
        <doc xml:space="preserve">ISO 8601 date/time with no optional
punctuation. Eg, "19941106T094937-0100".</doc>
      </member>
      <member name="iso8601_full"
              value="5"
              c:identifier="SOUP_DATE_ISO8601_FULL"
              glib:nick="iso8601-full">
        <doc xml:space="preserve">ISO 8601 date/time with all optional
punctuation. Eg, "1994-11-06T09:49:37-01:00".</doc>
      </member>
      <member name="iso8601"
              value="5"
              c:identifier="SOUP_DATE_ISO8601"
              glib:nick="iso8601">
        <doc xml:space="preserve">An alias for @SOUP_DATE_ISO8601_FULL.</doc>
      </member>
      <member name="iso8601_xmlrpc"
              value="6"
              c:identifier="SOUP_DATE_ISO8601_XMLRPC"
              glib:nick="iso8601-xmlrpc">
        <doc xml:space="preserve">ISO 8601 date/time as used by XML-RPC.
Eg, "19941106T09:49:37".</doc>
      </member>
    </enumeration>
    <enumeration name="Encoding"
                 glib:type-name="SoupEncoding"
                 glib:get-type="soup_encoding_get_type"
                 c:type="SoupEncoding">
      <doc xml:space="preserve">How a message body is encoded for transport</doc>
      <member name="unrecognized"
              value="0"
              c:identifier="SOUP_ENCODING_UNRECOGNIZED"
              glib:nick="unrecognized">
        <doc xml:space="preserve">unknown / error</doc>
      </member>
      <member name="none"
              value="1"
              c:identifier="SOUP_ENCODING_NONE"
              glib:nick="none">
        <doc xml:space="preserve">no body is present (which is not the same as a
0-length body, and only occurs in certain places)</doc>
      </member>
      <member name="content_length"
              value="2"
              c:identifier="SOUP_ENCODING_CONTENT_LENGTH"
              glib:nick="content-length">
        <doc xml:space="preserve">Content-Length encoding</doc>
      </member>
      <member name="eof"
              value="3"
              c:identifier="SOUP_ENCODING_EOF"
              glib:nick="eof">
        <doc xml:space="preserve">Response body ends when the connection is closed</doc>
      </member>
      <member name="chunked"
              value="4"
              c:identifier="SOUP_ENCODING_CHUNKED"
              glib:nick="chunked">
        <doc xml:space="preserve">chunked encoding (currently only supported
for response)</doc>
      </member>
      <member name="byteranges"
              value="5"
              c:identifier="SOUP_ENCODING_BYTERANGES"
              glib:nick="byteranges">
        <doc xml:space="preserve">multipart/byteranges (Reserved for future
use: NOT CURRENTLY IMPLEMENTED)</doc>
      </member>
    </enumeration>
    <bitfield name="Expectation"
              glib:type-name="SoupExpectation"
              glib:get-type="soup_expectation_get_type"
              c:type="SoupExpectation">
      <doc xml:space="preserve">Represents the parsed value of the "Expect" header.</doc>
      <member name="unrecognized"
              value="1"
              c:identifier="SOUP_EXPECTATION_UNRECOGNIZED"
              glib:nick="unrecognized">
        <doc xml:space="preserve">any unrecognized expectation</doc>
      </member>
      <member name="continue"
              value="2"
              c:identifier="SOUP_EXPECTATION_CONTINUE"
              glib:nick="continue">
        <doc xml:space="preserve">"100-continue"</doc>
      </member>
    </bitfield>
    <constant name="FORM_H" value="1" c:type="SOUP_FORM_H">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="FORM_MIME_TYPE_MULTIPART"
              value="multipart/form-data"
              c:type="SOUP_FORM_MIME_TYPE_MULTIPART"
              version="2.26">
      <doc xml:space="preserve">A macro containing the value
&lt;literal&gt;"multipart/form-data"&lt;/literal&gt;; the MIME type used for
posting form data that contains files to be uploaded.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FORM_MIME_TYPE_URLENCODED"
              value="application/x-www-form-urlencoded"
              c:type="SOUP_FORM_MIME_TYPE_URLENCODED"
              version="2.26">
      <doc xml:space="preserve">A macro containing the value
&lt;literal&gt;"application/x-www-form-urlencoded"&lt;/literal&gt;; the default
MIME type for POSTing HTML form data.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="HEADERS_H" value="1" c:type="SOUP_HEADERS_H">
      <type name="gint" c:type="gint"/>
    </constant>
    <enumeration name="HTTPVersion"
                 glib:type-name="SoupHTTPVersion"
                 glib:get-type="soup_http_version_get_type"
                 c:type="SoupHTTPVersion">
      <doc xml:space="preserve">Indicates the HTTP protocol version being used.</doc>
      <member name="http_1_0"
              value="0"
              c:identifier="SOUP_HTTP_1_0"
              glib:nick="http-1-0">
        <doc xml:space="preserve">HTTP 1.0 (RFC 1945)</doc>
      </member>
      <member name="http_1_1"
              value="1"
              c:identifier="SOUP_HTTP_1_1"
              glib:nick="http-1-1">
        <doc xml:space="preserve">HTTP 1.1 (RFC 2616)</doc>
      </member>
    </enumeration>
    <enumeration name="KnownStatusCode"
                 glib:type-name="SoupKnownStatusCode"
                 glib:get-type="soup_known_status_code_get_type"
                 c:type="SoupKnownStatusCode">
      <member name="none"
              value="0"
              c:identifier="SOUP_KNOWN_STATUS_CODE_NONE"
              glib:nick="none">
      </member>
      <member name="cancelled"
              value="1"
              c:identifier="SOUP_KNOWN_STATUS_CODE_CANCELLED"
              glib:nick="cancelled">
      </member>
      <member name="cant_resolve"
              value="2"
              c:identifier="SOUP_KNOWN_STATUS_CODE_CANT_RESOLVE"
              glib:nick="cant-resolve">
      </member>
      <member name="cant_resolve_proxy"
              value="3"
              c:identifier="SOUP_KNOWN_STATUS_CODE_CANT_RESOLVE_PROXY"
              glib:nick="cant-resolve-proxy">
      </member>
      <member name="cant_connect"
              value="4"
              c:identifier="SOUP_KNOWN_STATUS_CODE_CANT_CONNECT"
              glib:nick="cant-connect">
      </member>
      <member name="cant_connect_proxy"
              value="5"
              c:identifier="SOUP_KNOWN_STATUS_CODE_CANT_CONNECT_PROXY"
              glib:nick="cant-connect-proxy">
      </member>
      <member name="ssl_failed"
              value="6"
              c:identifier="SOUP_KNOWN_STATUS_CODE_SSL_FAILED"
              glib:nick="ssl-failed">
      </member>
      <member name="io_error"
              value="7"
              c:identifier="SOUP_KNOWN_STATUS_CODE_IO_ERROR"
              glib:nick="io-error">
      </member>
      <member name="malformed"
              value="8"
              c:identifier="SOUP_KNOWN_STATUS_CODE_MALFORMED"
              glib:nick="malformed">
      </member>
      <member name="try_again"
              value="9"
              c:identifier="SOUP_KNOWN_STATUS_CODE_TRY_AGAIN"
              glib:nick="try-again">
      </member>
      <member name="too_many_redirects"
              value="10"
              c:identifier="SOUP_KNOWN_STATUS_CODE_TOO_MANY_REDIRECTS"
              glib:nick="too-many-redirects">
      </member>
      <member name="tls_failed"
              value="11"
              c:identifier="SOUP_KNOWN_STATUS_CODE_TLS_FAILED"
              glib:nick="tls-failed">
      </member>
      <member name="continue"
              value="100"
              c:identifier="SOUP_KNOWN_STATUS_CODE_CONTINUE"
              glib:nick="continue">
      </member>
      <member name="switching_protocols"
              value="101"
              c:identifier="SOUP_KNOWN_STATUS_CODE_SWITCHING_PROTOCOLS"
              glib:nick="switching-protocols">
      </member>
      <member name="processing"
              value="102"
              c:identifier="SOUP_KNOWN_STATUS_CODE_PROCESSING"
              glib:nick="processing">
      </member>
      <member name="ok"
              value="200"
              c:identifier="SOUP_KNOWN_STATUS_CODE_OK"
              glib:nick="ok">
      </member>
      <member name="created"
              value="201"
              c:identifier="SOUP_KNOWN_STATUS_CODE_CREATED"
              glib:nick="created">
      </member>
      <member name="accepted"
              value="202"
              c:identifier="SOUP_KNOWN_STATUS_CODE_ACCEPTED"
              glib:nick="accepted">
      </member>
      <member name="non_authoritative"
              value="203"
              c:identifier="SOUP_KNOWN_STATUS_CODE_NON_AUTHORITATIVE"
              glib:nick="non-authoritative">
      </member>
      <member name="no_content"
              value="204"
              c:identifier="SOUP_KNOWN_STATUS_CODE_NO_CONTENT"
              glib:nick="no-content">
      </member>
      <member name="reset_content"
              value="205"
              c:identifier="SOUP_KNOWN_STATUS_CODE_RESET_CONTENT"
              glib:nick="reset-content">
      </member>
      <member name="partial_content"
              value="206"
              c:identifier="SOUP_KNOWN_STATUS_CODE_PARTIAL_CONTENT"
              glib:nick="partial-content">
      </member>
      <member name="multi_status"
              value="207"
              c:identifier="SOUP_KNOWN_STATUS_CODE_MULTI_STATUS"
              glib:nick="multi-status">
      </member>
      <member name="multiple_choices"
              value="300"
              c:identifier="SOUP_KNOWN_STATUS_CODE_MULTIPLE_CHOICES"
              glib:nick="multiple-choices">
      </member>
      <member name="moved_permanently"
              value="301"
              c:identifier="SOUP_KNOWN_STATUS_CODE_MOVED_PERMANENTLY"
              glib:nick="moved-permanently">
      </member>
      <member name="found"
              value="302"
              c:identifier="SOUP_KNOWN_STATUS_CODE_FOUND"
              glib:nick="found">
      </member>
      <member name="moved_temporarily"
              value="302"
              c:identifier="SOUP_KNOWN_STATUS_CODE_MOVED_TEMPORARILY"
              glib:nick="moved-temporarily">
      </member>
      <member name="see_other"
              value="303"
              c:identifier="SOUP_KNOWN_STATUS_CODE_SEE_OTHER"
              glib:nick="see-other">
      </member>
      <member name="not_modified"
              value="304"
              c:identifier="SOUP_KNOWN_STATUS_CODE_NOT_MODIFIED"
              glib:nick="not-modified">
      </member>
      <member name="use_proxy"
              value="305"
              c:identifier="SOUP_KNOWN_STATUS_CODE_USE_PROXY"
              glib:nick="use-proxy">
      </member>
      <member name="not_appearing_in_this_protocol"
              value="306"
              c:identifier="SOUP_KNOWN_STATUS_CODE_NOT_APPEARING_IN_THIS_PROTOCOL"
              glib:nick="not-appearing-in-this-protocol">
      </member>
      <member name="temporary_redirect"
              value="307"
              c:identifier="SOUP_KNOWN_STATUS_CODE_TEMPORARY_REDIRECT"
              glib:nick="temporary-redirect">
      </member>
      <member name="bad_request"
              value="400"
              c:identifier="SOUP_KNOWN_STATUS_CODE_BAD_REQUEST"
              glib:nick="bad-request">
      </member>
      <member name="unauthorized"
              value="401"
              c:identifier="SOUP_KNOWN_STATUS_CODE_UNAUTHORIZED"
              glib:nick="unauthorized">
      </member>
      <member name="payment_required"
              value="402"
              c:identifier="SOUP_KNOWN_STATUS_CODE_PAYMENT_REQUIRED"
              glib:nick="payment-required">
      </member>
      <member name="forbidden"
              value="403"
              c:identifier="SOUP_KNOWN_STATUS_CODE_FORBIDDEN"
              glib:nick="forbidden">
      </member>
      <member name="not_found"
              value="404"
              c:identifier="SOUP_KNOWN_STATUS_CODE_NOT_FOUND"
              glib:nick="not-found">
      </member>
      <member name="method_not_allowed"
              value="405"
              c:identifier="SOUP_KNOWN_STATUS_CODE_METHOD_NOT_ALLOWED"
              glib:nick="method-not-allowed">
      </member>
      <member name="not_acceptable"
              value="406"
              c:identifier="SOUP_KNOWN_STATUS_CODE_NOT_ACCEPTABLE"
              glib:nick="not-acceptable">
      </member>
      <member name="proxy_authentication_required"
              value="407"
              c:identifier="SOUP_KNOWN_STATUS_CODE_PROXY_AUTHENTICATION_REQUIRED"
              glib:nick="proxy-authentication-required">
      </member>
      <member name="proxy_unauthorized"
              value="407"
              c:identifier="SOUP_KNOWN_STATUS_CODE_PROXY_UNAUTHORIZED"
              glib:nick="proxy-unauthorized">
      </member>
      <member name="request_timeout"
              value="408"
              c:identifier="SOUP_KNOWN_STATUS_CODE_REQUEST_TIMEOUT"
              glib:nick="request-timeout">
      </member>
      <member name="conflict"
              value="409"
              c:identifier="SOUP_KNOWN_STATUS_CODE_CONFLICT"
              glib:nick="conflict">
      </member>
      <member name="gone"
              value="410"
              c:identifier="SOUP_KNOWN_STATUS_CODE_GONE"
              glib:nick="gone">
      </member>
      <member name="length_required"
              value="411"
              c:identifier="SOUP_KNOWN_STATUS_CODE_LENGTH_REQUIRED"
              glib:nick="length-required">
      </member>
      <member name="precondition_failed"
              value="412"
              c:identifier="SOUP_KNOWN_STATUS_CODE_PRECONDITION_FAILED"
              glib:nick="precondition-failed">
      </member>
      <member name="request_entity_too_large"
              value="413"
              c:identifier="SOUP_KNOWN_STATUS_CODE_REQUEST_ENTITY_TOO_LARGE"
              glib:nick="request-entity-too-large">
      </member>
      <member name="request_uri_too_long"
              value="414"
              c:identifier="SOUP_KNOWN_STATUS_CODE_REQUEST_URI_TOO_LONG"
              glib:nick="request-uri-too-long">
      </member>
      <member name="unsupported_media_type"
              value="415"
              c:identifier="SOUP_KNOWN_STATUS_CODE_UNSUPPORTED_MEDIA_TYPE"
              glib:nick="unsupported-media-type">
      </member>
      <member name="requested_range_not_satisfiable"
              value="416"
              c:identifier="SOUP_KNOWN_STATUS_CODE_REQUESTED_RANGE_NOT_SATISFIABLE"
              glib:nick="requested-range-not-satisfiable">
      </member>
      <member name="invalid_range"
              value="416"
              c:identifier="SOUP_KNOWN_STATUS_CODE_INVALID_RANGE"
              glib:nick="invalid-range">
      </member>
      <member name="expectation_failed"
              value="417"
              c:identifier="SOUP_KNOWN_STATUS_CODE_EXPECTATION_FAILED"
              glib:nick="expectation-failed">
      </member>
      <member name="unprocessable_entity"
              value="422"
              c:identifier="SOUP_KNOWN_STATUS_CODE_UNPROCESSABLE_ENTITY"
              glib:nick="unprocessable-entity">
      </member>
      <member name="locked"
              value="423"
              c:identifier="SOUP_KNOWN_STATUS_CODE_LOCKED"
              glib:nick="locked">
      </member>
      <member name="failed_dependency"
              value="424"
              c:identifier="SOUP_KNOWN_STATUS_CODE_FAILED_DEPENDENCY"
              glib:nick="failed-dependency">
      </member>
      <member name="internal_server_error"
              value="500"
              c:identifier="SOUP_KNOWN_STATUS_CODE_INTERNAL_SERVER_ERROR"
              glib:nick="internal-server-error">
      </member>
      <member name="not_implemented"
              value="501"
              c:identifier="SOUP_KNOWN_STATUS_CODE_NOT_IMPLEMENTED"
              glib:nick="not-implemented">
      </member>
      <member name="bad_gateway"
              value="502"
              c:identifier="SOUP_KNOWN_STATUS_CODE_BAD_GATEWAY"
              glib:nick="bad-gateway">
      </member>
      <member name="service_unavailable"
              value="503"
              c:identifier="SOUP_KNOWN_STATUS_CODE_SERVICE_UNAVAILABLE"
              glib:nick="service-unavailable">
      </member>
      <member name="gateway_timeout"
              value="504"
              c:identifier="SOUP_KNOWN_STATUS_CODE_GATEWAY_TIMEOUT"
              glib:nick="gateway-timeout">
      </member>
      <member name="http_version_not_supported"
              value="505"
              c:identifier="SOUP_KNOWN_STATUS_CODE_HTTP_VERSION_NOT_SUPPORTED"
              glib:nick="http-version-not-supported">
      </member>
      <member name="insufficient_storage"
              value="507"
              c:identifier="SOUP_KNOWN_STATUS_CODE_INSUFFICIENT_STORAGE"
              glib:nick="insufficient-storage">
      </member>
      <member name="not_extended"
              value="510"
              c:identifier="SOUP_KNOWN_STATUS_CODE_NOT_EXTENDED"
              glib:nick="not-extended">
      </member>
    </enumeration>
    <constant name="LOGGER_H" value="1" c:type="SOUP_LOGGER_H">
      <type name="gint" c:type="gint"/>
    </constant>
    <class name="Logger"
           c:symbol-prefix="logger"
           c:type="SoupLogger"
           parent="GObject.Object"
           glib:type-name="SoupLogger"
           glib:get-type="soup_logger_get_type"
           glib:type-struct="LoggerClass">
      <implements name="SessionFeature"/>
      <constructor name="new" c:identifier="soup_logger_new">
        <doc xml:space="preserve">Creates a new #SoupLogger with the given debug level. If @level is
%SOUP_LOGGER_LOG_BODY, @max_body_size gives the maximum number of
bytes of the body that will be logged. (-1 means "no limit".)

If you need finer control over what message parts are and aren't
logged, use soup_logger_set_request_filter() and
soup_logger_set_response_filter().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #SoupLogger</doc>
          <type name="Logger" c:type="SoupLogger*"/>
        </return-value>
        <parameters>
          <parameter name="level" transfer-ownership="none">
            <doc xml:space="preserve">the debug level</doc>
            <type name="LoggerLogLevel" c:type="SoupLoggerLogLevel"/>
          </parameter>
          <parameter name="max_body_size" transfer-ownership="none">
            <doc xml:space="preserve">the maximum body size to output, or -1</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="attach" c:identifier="soup_logger_attach" deprecated="1">
        <doc xml:space="preserve">Sets @logger to watch @session and print debug information for
its messages.

(The session will take a reference on @logger, which will be
removed when you call soup_logger_detach(), or when the session is
destroyed.)</doc>
        <doc-deprecated xml:space="preserve">Use soup_session_add_feature() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="logger" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupLogger</doc>
            <type name="Logger" c:type="SoupLogger*"/>
          </instance-parameter>
          <parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </parameter>
        </parameters>
      </method>
      <method name="detach" c:identifier="soup_logger_detach" deprecated="1">
        <doc xml:space="preserve">Stops @logger from watching @session.</doc>
        <doc-deprecated xml:space="preserve">Use soup_session_remove_feature() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="logger" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupLogger</doc>
            <type name="Logger" c:type="SoupLogger*"/>
          </instance-parameter>
          <parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_printer" c:identifier="soup_logger_set_printer">
        <doc xml:space="preserve">Sets up an alternate log printing routine, if you don't want
the log to go to &lt;literal&gt;stdout&lt;/literal&gt;.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="logger" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupLogger</doc>
            <type name="Logger" c:type="SoupLogger*"/>
          </instance-parameter>
          <parameter name="printer"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:space="preserve">the callback for printing logging output</doc>
            <type name="LoggerPrinter" c:type="SoupLoggerPrinter"/>
          </parameter>
          <parameter name="printer_data" transfer-ownership="none">
            <doc xml:space="preserve">data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">a #GDestroyNotify to free @printer_data</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_request_filter"
              c:identifier="soup_logger_set_request_filter">
        <doc xml:space="preserve">Sets up a filter to determine the log level for a given request.
For each HTTP request @logger will invoke @request_filter to
determine how much (if any) of that request to log. (If you do not
set a request filter, @logger will just always log requests at the
level passed to soup_logger_new().)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="logger" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupLogger</doc>
            <type name="Logger" c:type="SoupLogger*"/>
          </instance-parameter>
          <parameter name="request_filter"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:space="preserve">the callback for request debugging</doc>
            <type name="LoggerFilter" c:type="SoupLoggerFilter"/>
          </parameter>
          <parameter name="filter_data" transfer-ownership="none">
            <doc xml:space="preserve">data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">a #GDestroyNotify to free @filter_data</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_response_filter"
              c:identifier="soup_logger_set_response_filter">
        <doc xml:space="preserve">Sets up a filter to determine the log level for a given response.
For each HTTP response @logger will invoke @response_filter to
determine how much (if any) of that response to log. (If you do not
set a response filter, @logger will just always log responses at
the level passed to soup_logger_new().)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="logger" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupLogger</doc>
            <type name="Logger" c:type="SoupLogger*"/>
          </instance-parameter>
          <parameter name="response_filter"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:space="preserve">the callback for response debugging</doc>
            <type name="LoggerFilter" c:type="SoupLoggerFilter"/>
          </parameter>
          <parameter name="filter_data" transfer-ownership="none">
            <doc xml:space="preserve">data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">a #GDestroyNotify to free @filter_data</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <record name="LoggerClass"
            c:type="SoupLoggerClass"
            glib:is-gtype-struct-for="Logger">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="_libsoup_reserved1" introspectable="0">
        <callback name="_libsoup_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_libsoup_reserved2" introspectable="0">
        <callback name="_libsoup_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_libsoup_reserved3" introspectable="0">
        <callback name="_libsoup_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_libsoup_reserved4" introspectable="0">
        <callback name="_libsoup_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <callback name="LoggerFilter" c:type="SoupLoggerFilter">
      <doc xml:space="preserve">The prototype for a logging filter. The filter callback will be
invoked for each request or response, and should analyze it and
return a #SoupLoggerLogLevel value indicating how much of the
message to log. Eg, it might choose between %SOUP_LOGGER_LOG_BODY
and %SOUP_LOGGER_LOG_HEADERS depending on the Content-Type.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a #SoupLoggerLogLevel value indicating how much of
the message to log</doc>
        <type name="LoggerLogLevel" c:type="SoupLoggerLogLevel"/>
      </return-value>
      <parameters>
        <parameter name="logger" transfer-ownership="none">
          <doc xml:space="preserve">the #SoupLogger</doc>
          <type name="Logger" c:type="SoupLogger*"/>
        </parameter>
        <parameter name="msg" transfer-ownership="none">
          <doc xml:space="preserve">the message being logged</doc>
          <type name="Message" c:type="SoupMessage*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:space="preserve">the data passed to soup_logger_set_request_filter()
or soup_logger_set_response_filter()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="LoggerLogLevel"
                 glib:type-name="SoupLoggerLogLevel"
                 glib:get-type="soup_logger_log_level_get_type"
                 c:type="SoupLoggerLogLevel">
      <doc xml:space="preserve">Describes the level of logging output to provide.</doc>
      <member name="none"
              value="0"
              c:identifier="SOUP_LOGGER_LOG_NONE"
              glib:nick="none">
        <doc xml:space="preserve">No logging</doc>
      </member>
      <member name="minimal"
              value="1"
              c:identifier="SOUP_LOGGER_LOG_MINIMAL"
              glib:nick="minimal">
        <doc xml:space="preserve">Log the Request-Line or Status-Line and
the Soup-Debug pseudo-headers</doc>
      </member>
      <member name="headers"
              value="2"
              c:identifier="SOUP_LOGGER_LOG_HEADERS"
              glib:nick="headers">
        <doc xml:space="preserve">Log the full request/response headers</doc>
      </member>
      <member name="body"
              value="3"
              c:identifier="SOUP_LOGGER_LOG_BODY"
              glib:nick="body">
        <doc xml:space="preserve">Log the full headers and request/response
bodies.</doc>
      </member>
    </enumeration>
    <callback name="LoggerPrinter" c:type="SoupLoggerPrinter">
      <doc xml:space="preserve">The prototype for a custom printing callback.

@level indicates what kind of information is being printed. Eg, it
will be %SOUP_LOGGER_LOG_HEADERS if @data is header data.

@direction is either '&lt;', '&gt;', or ' ', and @data is the single line
to print; the printer is expected to add a terminating newline.

To get the effect of the default printer, you would do:

&lt;informalexample&gt;&lt;programlisting&gt;
printf ("%c %s\n", direction, data);
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="logger" transfer-ownership="none">
          <doc xml:space="preserve">the #SoupLogger</doc>
          <type name="Logger" c:type="SoupLogger*"/>
        </parameter>
        <parameter name="level" transfer-ownership="none">
          <doc xml:space="preserve">the level of the information being printed.</doc>
          <type name="LoggerLogLevel" c:type="SoupLoggerLogLevel"/>
        </parameter>
        <parameter name="direction" transfer-ownership="none">
          <doc xml:space="preserve">a single-character prefix to @data</doc>
          <type name="gchar" c:type="char"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:space="preserve">data to print</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="4">
          <doc xml:space="preserve">the data passed to soup_logger_set_printer()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <constant name="MESSAGE_BODY_H" value="1" c:type="SOUP_MESSAGE_BODY_H">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="MESSAGE_FIRST_PARTY"
              value="first-party"
              c:type="SOUP_MESSAGE_FIRST_PARTY"
              version="2.30">
      <doc xml:space="preserve">Alias for the #SoupMessage:first-party property. (The
#SoupURI loaded in the application when the message was
queued.)</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="MESSAGE_FLAGS" value="flags" c:type="SOUP_MESSAGE_FLAGS">
      <doc xml:space="preserve">Alias for the #SoupMessage:flags property. (The message's
#SoupMessageFlags.)</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="MESSAGE_H" value="1" c:type="SOUP_MESSAGE_H">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="MESSAGE_HEADERS_H"
              value="1"
              c:type="SOUP_MESSAGE_HEADERS_H">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="MESSAGE_HTTP_VERSION"
              value="http-version"
              c:type="SOUP_MESSAGE_HTTP_VERSION">
      <doc xml:space="preserve">Alias for the #SoupMessage:http-version property. (The
message's #SoupHTTPVersion.)</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="MESSAGE_METHOD"
              value="method"
              c:type="SOUP_MESSAGE_METHOD">
      <doc xml:space="preserve">Alias for the #SoupMessage:method property. (The message's
HTTP method.)</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="MESSAGE_PRIORITY"
              value="priority"
              c:type="SOUP_MESSAGE_PRIORITY"
              version="2.44">
      <doc xml:space="preserve">Sets the priority of the #SoupMessage. See
soup_message_set_priority() for further details.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="MESSAGE_REASON_PHRASE"
              value="reason-phrase"
              c:type="SOUP_MESSAGE_REASON_PHRASE">
      <doc xml:space="preserve">Alias for the #SoupMessage:reason-phrase property. (The
message's HTTP response reason phrase.)</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="MESSAGE_REQUEST_BODY"
              value="request-body"
              c:type="SOUP_MESSAGE_REQUEST_BODY">
      <doc xml:space="preserve">Alias for the #SoupMessage:request-body property. (The
message's HTTP request body.)</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="MESSAGE_REQUEST_BODY_DATA"
              value="request-body-data"
              c:type="SOUP_MESSAGE_REQUEST_BODY_DATA"
              version="2.46">
      <doc xml:space="preserve">Alias for the #SoupMessage:request-body-data property. (The
message's HTTP request body, as a #GBytes.)</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="MESSAGE_REQUEST_HEADERS"
              value="request-headers"
              c:type="SOUP_MESSAGE_REQUEST_HEADERS">
      <doc xml:space="preserve">Alias for the #SoupMessage:request-headers property. (The
message's HTTP request headers.)</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="MESSAGE_RESPONSE_BODY"
              value="response-body"
              c:type="SOUP_MESSAGE_RESPONSE_BODY">
      <doc xml:space="preserve">Alias for the #SoupMessage:response-body property. (The
message's HTTP response body.)</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="MESSAGE_RESPONSE_BODY_DATA"
              value="response-body-data"
              c:type="SOUP_MESSAGE_RESPONSE_BODY_DATA"
              version="2.46">
      <doc xml:space="preserve">Alias for the #SoupMessage:response-body-data property. (The
message's HTTP response body, as a #GBytes.)</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="MESSAGE_RESPONSE_HEADERS"
              value="response-headers"
              c:type="SOUP_MESSAGE_RESPONSE_HEADERS">
      <doc xml:space="preserve">Alias for the #SoupMessage:response-headers property. (The
message's HTTP response headers.)</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="MESSAGE_SERVER_SIDE"
              value="server-side"
              c:type="SOUP_MESSAGE_SERVER_SIDE">
      <doc xml:space="preserve">Alias for the #SoupMessage:server-side property. (%TRUE if
the message was created by #SoupServer.)</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="MESSAGE_STATUS_CODE"
              value="status-code"
              c:type="SOUP_MESSAGE_STATUS_CODE">
      <doc xml:space="preserve">Alias for the #SoupMessage:status-code property. (The
message's HTTP response status code.)</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="MESSAGE_TLS_CERTIFICATE"
              value="tls-certificate"
              c:type="SOUP_MESSAGE_TLS_CERTIFICATE"
              version="2.34">
      <doc xml:space="preserve">Alias for the #SoupMessage:tls-certificate property. (The
TLS certificate associated with the message, if any.)</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="MESSAGE_TLS_ERRORS"
              value="tls-errors"
              c:type="SOUP_MESSAGE_TLS_ERRORS"
              version="2.34">
      <doc xml:space="preserve">Alias for the #SoupMessage:tls-errors property. (The
verification errors on #SoupMessage:tls-certificate.)</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="MESSAGE_URI" value="uri" c:type="SOUP_MESSAGE_URI">
      <doc xml:space="preserve">Alias for the #SoupMessage:uri property. (The message's
#SoupURI.)</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="METHOD_H" value="1" c:type="SOUP_METHOD_H">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="MISC_H" value="1" c:type="SOUP_MISC_H">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="MULTIPART_H" value="1" c:type="SOUP_MULTIPART_H">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="MULTIPART_INPUT_STREAM_H"
              value="1"
              c:type="SOUP_MULTIPART_INPUT_STREAM_H">
      <type name="gint" c:type="gint"/>
    </constant>
    <enumeration name="MemoryUse"
                 glib:type-name="SoupMemoryUse"
                 glib:get-type="soup_memory_use_get_type"
                 c:type="SoupMemoryUse">
      <doc xml:space="preserve">Describes how #SoupBuffer should use the data passed in by the
caller.

See also soup_buffer_new_with_owner(), which allows to you create a
buffer containing data which is owned by another object.</doc>
      <member name="static"
              value="0"
              c:identifier="SOUP_MEMORY_STATIC"
              glib:nick="static">
        <doc xml:space="preserve">The memory is statically allocated and
constant; libsoup can use the passed-in buffer directly and not
need to worry about it being modified or freed.</doc>
      </member>
      <member name="take"
              value="1"
              c:identifier="SOUP_MEMORY_TAKE"
              glib:nick="take">
        <doc xml:space="preserve">The caller has allocated the memory for the
#SoupBuffer's use; libsoup will assume ownership of it and free it
(with g_free()) when it is done with it.</doc>
      </member>
      <member name="copy"
              value="2"
              c:identifier="SOUP_MEMORY_COPY"
              glib:nick="copy">
        <doc xml:space="preserve">The passed-in data belongs to the caller; the
#SoupBuffer will copy it into new memory, leaving the caller free
to reuse the original memory.</doc>
      </member>
      <member name="temporary"
              value="3"
              c:identifier="SOUP_MEMORY_TEMPORARY"
              glib:nick="temporary">
        <doc xml:space="preserve">The passed-in data belongs to the caller,
but will remain valid for the lifetime of the #SoupBuffer. The
difference between this and @SOUP_MEMORY_STATIC is that if you copy
a @SOUP_MEMORY_TEMPORARY buffer, it will make a copy of the memory
as well, rather than reusing the original memory.</doc>
      </member>
    </enumeration>
    <class name="Message"
           c:symbol-prefix="message"
           c:type="SoupMessage"
           parent="GObject.Object"
           glib:type-name="SoupMessage"
           glib:get-type="soup_message_get_type"
           glib:type-struct="MessageClass">
      <doc xml:space="preserve">Represents an HTTP message being sent or received.

@status_code will normally be a #SoupStatus value, eg,
%SOUP_STATUS_OK, though of course it might actually be an unknown
status code. @reason_phrase is the actual text returned from the
server, which may or may not correspond to the "standard"
description of @status_code. At any rate, it is almost certainly
not localized, and not very descriptive even if it is in the user's
language; you should not use @reason_phrase in user-visible
messages. Rather, you should look at @status_code, and determine an
end-user-appropriate message based on that and on what you were
trying to do.

As described in the #SoupMessageBody documentation, the
@request_body and @response_body &lt;literal&gt;data&lt;/literal&gt; fields
will not necessarily be filled in at all times. When the body
fields are filled in, they will be terminated with a '\0' byte
(which is not included in the &lt;literal&gt;length&lt;/literal&gt;), so you
can use them as ordinary C strings (assuming that you know that the
body doesn't have any other '\0' bytes).

For a client-side #SoupMessage, @request_body's
&lt;literal&gt;data&lt;/literal&gt; is usually filled in right before libsoup
writes the request to the network, but you should not count on
this; use soup_message_body_flatten() if you want to ensure that
&lt;literal&gt;data&lt;/literal&gt; is filled in. If you are not using
#SoupRequest to read the response, then @response_body's
&lt;literal&gt;data&lt;/literal&gt; will be filled in before
#SoupMessage::finished is emitted. (If you are using #SoupRequest,
then the message body is not accumulated by default, so
@response_body's &lt;literal&gt;data&lt;/literal&gt; will always be %NULL.)

For a server-side #SoupMessage, @request_body's %data will be
filled in before #SoupMessage::got_body is emitted.

To prevent the %data field from being filled in at all (eg, if you
are handling the data from a #SoupMessage::got_chunk, and so don't
need to see it all at the end), call
soup_message_body_set_accumulate() on @response_body or
@request_body as appropriate, passing %FALSE.</doc>
      <constructor name="new" c:identifier="soup_message_new">
        <doc xml:space="preserve">Creates a new empty #SoupMessage, which will connect to @uri</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the new #SoupMessage (or %NULL if @uri
could not be parsed).</doc>
          <type name="Message" c:type="SoupMessage*"/>
        </return-value>
        <parameters>
          <parameter name="method" transfer-ownership="none">
            <doc xml:space="preserve">the HTTP method for the created request</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="uri_string" transfer-ownership="none">
            <doc xml:space="preserve">the destination endpoint (as a string)</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_uri"
                   c:identifier="soup_message_new_from_uri">
        <doc xml:space="preserve">Creates a new empty #SoupMessage, which will connect to @uri</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #SoupMessage</doc>
          <type name="Message" c:type="SoupMessage*"/>
        </return-value>
        <parameters>
          <parameter name="method" transfer-ownership="none">
            <doc xml:space="preserve">the HTTP method for the created request</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">the destination endpoint (as a #SoupURI)</doc>
            <type name="URI" c:type="SoupURI*"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="finished" invoker="finished">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="got_body" invoker="got_body">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="got_chunk" invoker="got_chunk">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
          <parameter name="chunk" transfer-ownership="none">
            <type name="Buffer" c:type="SoupBuffer*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="got_headers" invoker="got_headers">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="got_informational" invoker="got_informational">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="restarted" invoker="restarted">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="starting" invoker="starting">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="wrote_body" invoker="wrote_body">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="wrote_chunk" invoker="wrote_chunk">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="wrote_headers" invoker="wrote_headers">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="wrote_informational" invoker="wrote_informational">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="add_header_handler"
              c:identifier="soup_message_add_header_handler"
              introspectable="0">
        <doc xml:space="preserve">Adds a signal handler to @msg for @signal, as with
g_signal_connect(), but the @callback will only be run if @msg's
incoming messages headers (that is, the
&lt;literal&gt;request_headers&lt;/literal&gt; for a client #SoupMessage, or
the &lt;literal&gt;response_headers&lt;/literal&gt; for a server #SoupMessage)
contain a header named @header.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the handler ID from g_signal_connect()</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
          <parameter name="signal" transfer-ownership="none">
            <doc xml:space="preserve">signal to connect the handler to.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="header" transfer-ownership="none">
            <doc xml:space="preserve">HTTP response header to match against</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" closure="3">
            <doc xml:space="preserve">the header handler</doc>
            <type name="GObject.Callback" c:type="GCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">data to pass to @handler_cb</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_status_code_handler"
              c:identifier="soup_message_add_status_code_handler"
              introspectable="0">
        <doc xml:space="preserve">Adds a signal handler to @msg for @signal, as with
g_signal_connect(), but the @callback will only be run if @msg has
the status @status_code.

@signal must be a signal that will be emitted after @msg's status
is set. For a client #SoupMessage, this means it can't be a "wrote"
signal. For a server #SoupMessage, this means it can't be a "got"
signal.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the handler ID from g_signal_connect()</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
          <parameter name="signal" transfer-ownership="none">
            <doc xml:space="preserve">signal to connect the handler to.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="status_code" transfer-ownership="none">
            <doc xml:space="preserve">status code to match against</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" closure="3">
            <doc xml:space="preserve">the header handler</doc>
            <type name="GObject.Callback" c:type="GCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">data to pass to @handler_cb</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="content_sniffed"
              c:identifier="soup_message_content_sniffed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
          <parameter name="content_type" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="params" transfer-ownership="none">
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="disable_feature"
              c:identifier="soup_message_disable_feature"
              version="2.28">
        <doc xml:space="preserve">This disables the actions of #SoupSessionFeature&lt;!-- --&gt;s with the
given @feature_type (or a subclass of that type) on @msg, so that
@msg is processed as though the feature(s) hadn't been added to the
session. Eg, passing #SOUP_TYPE_CONTENT_SNIFFER for @feature_type
will disable Content-Type sniffing on the message.

You must call this before queueing @msg on a session; calling it on
a message that has already been queued is undefined. In particular,
you cannot call this on a message that is being requeued after a
redirect or authentication.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
          <parameter name="feature_type" transfer-ownership="none">
            <doc xml:space="preserve">the #GType of a #SoupSessionFeature</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
      <method name="finished" c:identifier="soup_message_finished">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_address"
              c:identifier="soup_message_get_address"
              version="2.26">
        <doc xml:space="preserve">Gets the address @msg's URI points to. After first setting the
URI on a message, this will be unresolved, although the message's
session will resolve it before sending the message.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the address @msg's URI points to</doc>
          <type name="Address" c:type="SoupAddress*"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_first_party"
              c:identifier="soup_message_get_first_party"
              version="2.30">
        <doc xml:space="preserve">Gets @msg's first-party #SoupURI</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the @msg's first party #SoupURI</doc>
          <type name="URI" c:type="SoupURI*"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_flags" c:identifier="soup_message_get_flags">
        <doc xml:space="preserve">Gets the flags on @msg</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the flags</doc>
          <type name="MessageFlags" c:type="SoupMessageFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_http_version"
              c:identifier="soup_message_get_http_version">
        <doc xml:space="preserve">Gets the HTTP version of @msg. This is the minimum of the
version from the request and the version from the response.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the HTTP version</doc>
          <type name="HTTPVersion" c:type="SoupHTTPVersion"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_https_status"
              c:identifier="soup_message_get_https_status"
              version="2.34">
        <doc xml:space="preserve">If @msg is using https (or attempted to use https but got
%SOUP_STATUS_SSL_FAILED), this retrieves the #GTlsCertificate
associated with its connection, and the #GTlsCertificateFlags
showing what problems, if any, have been found with that
certificate.

&lt;note&gt;&lt;para&gt;This is only meaningful with messages processed by a #SoupSession and is
not useful for messages received by a #SoupServer&lt;/para&gt;&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @msg used/attempted https, %FALSE if not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
          <parameter name="certificate"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:space="preserve">@msg's TLS certificate</doc>
            <type name="Gio.TlsCertificate" c:type="GTlsCertificate**"/>
          </parameter>
          <parameter name="errors"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">the verification status of @certificate</doc>
            <type name="Gio.TlsCertificateFlags"
                  c:type="GTlsCertificateFlags*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_priority"
              c:identifier="soup_message_get_priority"
              version="2.44">
        <doc xml:space="preserve">Retrieves the #SoupMessagePriority. If not set this value defaults
to #SOUP_MESSAGE_PRIORITY_NORMAL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the priority of the message.</doc>
          <type name="MessagePriority" c:type="SoupMessagePriority"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_soup_request"
              c:identifier="soup_message_get_soup_request"
              version="2.42">
        <doc xml:space="preserve">If @msg is associated with a #SoupRequest, this returns that
request. Otherwise it returns %NULL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@msg's associated #SoupRequest</doc>
          <type name="Request" c:type="SoupRequest*"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_uri" c:identifier="soup_message_get_uri">
        <doc xml:space="preserve">Gets @msg's URI</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the URI @msg is targeted for.</doc>
          <type name="URI" c:type="SoupURI*"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="got_body" c:identifier="soup_message_got_body">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="got_chunk" c:identifier="soup_message_got_chunk">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
          <parameter name="chunk" transfer-ownership="none">
            <type name="Buffer" c:type="SoupBuffer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="got_headers" c:identifier="soup_message_got_headers">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="got_informational"
              c:identifier="soup_message_got_informational">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_keepalive" c:identifier="soup_message_is_keepalive">
        <doc xml:space="preserve">Determines whether or not @msg's connection can be kept alive for
further requests after processing @msg, based on the HTTP version,
Connection header, etc.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE or %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="restarted" c:identifier="soup_message_restarted">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_chunk_allocator"
              c:identifier="soup_message_set_chunk_allocator"
              deprecated="1">
        <doc xml:space="preserve">Sets an alternate chunk-allocation function to use when reading
@msg's body when using the traditional (ie,
non-#SoupRequest&lt;!-- --&gt;-based) API. Every time data is available
to read, libsoup will call @allocator, which should return a
#SoupBuffer. (See #SoupChunkAllocator for additional details.)
Libsoup will then read data from the network into that buffer, and
update the buffer's &lt;literal&gt;length&lt;/literal&gt; to indicate how much
data it read.

Generally, a custom chunk allocator would be used in conjunction
with soup_message_body_set_accumulate() %FALSE and
#SoupMessage::got_chunk, as part of a strategy to avoid unnecessary
copying of data. However, you cannot assume that every call to the
allocator will be followed by a call to your
#SoupMessage::got_chunk handler; if an I/O error occurs, then the
buffer will be unreffed without ever having been used. If your
buffer-allocation strategy requires special cleanup, use
soup_buffer_new_with_owner() rather than doing the cleanup from the
#SoupMessage::got_chunk handler.

The other thing to remember when using non-accumulating message
bodies is that the buffer passed to the #SoupMessage::got_chunk
handler will be unreffed after the handler returns, just as it
would be in the non-custom-allocated case. If you want to hand the
chunk data off to some other part of your program to use later,
you'll need to ref the #SoupBuffer (or its owner, in the
soup_buffer_new_with_owner() case) to ensure that the data remains
valid.</doc>
        <doc-deprecated xml:space="preserve">#SoupRequest provides a much simpler API that lets you
read the response directly into your own buffers without needing to
mess with callbacks, pausing/unpausing, etc.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
          <parameter name="allocator"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:space="preserve">the chunk allocator callback</doc>
            <type name="ChunkAllocator" c:type="SoupChunkAllocator"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">data to pass to @allocator</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy_notify"
                     transfer-ownership="none"
                     scope="async">
            <doc xml:space="preserve">destroy notifier to free @user_data when @msg is
destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_first_party"
              c:identifier="soup_message_set_first_party"
              version="2.30">
        <doc xml:space="preserve">Sets @first_party as the main document #SoupURI for @msg. For
details of when and how this is used refer to the documentation for
#SoupCookieJarAcceptPolicy.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
          <parameter name="first_party" transfer-ownership="none">
            <doc xml:space="preserve">the #SoupURI for the @msg's first party</doc>
            <type name="URI" c:type="SoupURI*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_flags" c:identifier="soup_message_set_flags">
        <doc xml:space="preserve">Sets the specified flags on @msg.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a set of #SoupMessageFlags values</doc>
            <type name="MessageFlags" c:type="SoupMessageFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_http_version"
              c:identifier="soup_message_set_http_version">
        <doc xml:space="preserve">Sets the HTTP version on @msg. The default version is
%SOUP_HTTP_1_1. Setting it to %SOUP_HTTP_1_0 will prevent certain
functionality from being used.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
          <parameter name="version" transfer-ownership="none">
            <doc xml:space="preserve">the HTTP version</doc>
            <type name="HTTPVersion" c:type="SoupHTTPVersion"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_priority"
              c:identifier="soup_message_set_priority"
              version="2.44">
        <doc xml:space="preserve">Sets the priority of a message. Note that this won't have any
effect unless used before the message is added to the session's
message processing queue.

The message will be placed just before any other previously added
message with lower priority (messages with the same priority are
processed on a FIFO basis).

Setting priorities does not currently work with #SoupSessionSync
(or with synchronous messages on a plain #SoupSession) because in
the synchronous/blocking case, priority ends up being determined
semi-randomly by thread scheduling.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
          <parameter name="priority" transfer-ownership="none">
            <doc xml:space="preserve">the #SoupMessagePriority</doc>
            <type name="MessagePriority" c:type="SoupMessagePriority"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_redirect"
              c:identifier="soup_message_set_redirect"
              version="2.38">
        <doc xml:space="preserve">Sets @msg's status_code to @status_code and adds a Location header
pointing to @redirect_uri. Use this from a #SoupServer when you
want to redirect the client to another URI.

@redirect_uri can be a relative URI, in which case it is
interpreted relative to @msg's current URI. In particular, if
@redirect_uri is just a path, it will replace the path
&lt;emphasis&gt;and query&lt;/emphasis&gt; of @msg's URI.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
          <parameter name="status_code" transfer-ownership="none">
            <doc xml:space="preserve">a 3xx status code</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="redirect_uri" transfer-ownership="none">
            <doc xml:space="preserve">the URI to redirect @msg to</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_request" c:identifier="soup_message_set_request">
        <doc xml:space="preserve">Convenience function to set the request body of a #SoupMessage. If
@content_type is %NULL, the request body must be empty as well.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">the message</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
          <parameter name="content_type"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">MIME Content-Type of the body</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="req_use" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMemoryUse describing how to handle @req_body</doc>
            <type name="MemoryUse" c:type="SoupMemoryUse"/>
          </parameter>
          <parameter name="req_body"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">
  a data buffer containing the body of the message request.</doc>
            <array length="3" zero-terminated="0" c:type="char*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="req_length" transfer-ownership="none">
            <doc xml:space="preserve">the byte length of @req_body.</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_response" c:identifier="soup_message_set_response">
        <doc xml:space="preserve">Convenience function to set the response body of a #SoupMessage. If
@content_type is %NULL, the response body must be empty as well.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">the message</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
          <parameter name="content_type"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">MIME Content-Type of the body</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="resp_use" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMemoryUse describing how to handle @resp_body</doc>
            <type name="MemoryUse" c:type="SoupMemoryUse"/>
          </parameter>
          <parameter name="resp_body"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">
  a data buffer containing the body of the message response.</doc>
            <array length="3" zero-terminated="0" c:type="char*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="resp_length" transfer-ownership="none">
            <doc xml:space="preserve">the byte length of @resp_body.</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_status" c:identifier="soup_message_set_status">
        <doc xml:space="preserve">Sets @msg's status code to @status_code. If @status_code is a
known value, it will also set @msg's reason_phrase.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
          <parameter name="status_code" transfer-ownership="none">
            <doc xml:space="preserve">an HTTP status code</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_status_full"
              c:identifier="soup_message_set_status_full">
        <doc xml:space="preserve">Sets @msg's status code and reason phrase.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
          <parameter name="status_code" transfer-ownership="none">
            <doc xml:space="preserve">an HTTP status code</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="reason_phrase" transfer-ownership="none">
            <doc xml:space="preserve">a description of the status</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uri" c:identifier="soup_message_set_uri">
        <doc xml:space="preserve">Sets @msg's URI to @uri. If @msg has already been sent and you want
to re-send it with the new URI, you need to call
soup_session_requeue_message().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">the new #SoupURI</doc>
            <type name="URI" c:type="SoupURI*"/>
          </parameter>
        </parameters>
      </method>
      <method name="starting" c:identifier="soup_message_starting">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="wrote_body" c:identifier="soup_message_wrote_body">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="wrote_body_data"
              c:identifier="soup_message_wrote_body_data">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
          <parameter name="chunk" transfer-ownership="none">
            <type name="Buffer" c:type="SoupBuffer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="wrote_chunk" c:identifier="soup_message_wrote_chunk">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="wrote_headers" c:identifier="soup_message_wrote_headers">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="wrote_informational"
              c:identifier="soup_message_wrote_informational">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="first-party"
                version="2.30"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The #SoupURI loaded in the application when the message was
queued.</doc>
        <type name="URI"/>
      </property>
      <property name="flags" writable="1" transfer-ownership="none">
        <type name="MessageFlags"/>
      </property>
      <property name="http-version" writable="1" transfer-ownership="none">
        <type name="HTTPVersion"/>
      </property>
      <property name="method" writable="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="priority" writable="1" transfer-ownership="none">
        <type name="MessagePriority"/>
      </property>
      <property name="reason-phrase" writable="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="request-body" transfer-ownership="none">
        <type name="MessageBody"/>
      </property>
      <property name="request-body-data"
                version="2.46"
                transfer-ownership="none">
        <doc xml:space="preserve">The message's HTTP request body, as a #GBytes.</doc>
        <type name="GLib.Bytes"/>
      </property>
      <property name="request-headers" transfer-ownership="none">
        <type name="MessageHeaders"/>
      </property>
      <property name="response-body" transfer-ownership="none">
        <type name="MessageBody"/>
      </property>
      <property name="response-body-data"
                version="2.46"
                transfer-ownership="none">
        <doc xml:space="preserve">The message's HTTP response body, as a #GBytes.</doc>
        <type name="GLib.Bytes"/>
      </property>
      <property name="response-headers" transfer-ownership="none">
        <type name="MessageHeaders"/>
      </property>
      <property name="server-side"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="status-code" writable="1" transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <property name="tls-certificate"
                version="2.34"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The #GTlsCertificate associated with the message</doc>
        <type name="Gio.TlsCertificate"/>
      </property>
      <property name="tls-errors"
                version="2.34"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The verification errors on #SoupMessage:tls-certificate</doc>
        <type name="Gio.TlsCertificateFlags"/>
      </property>
      <property name="uri" writable="1" transfer-ownership="none">
        <type name="URI"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="method">
        <doc xml:space="preserve">the HTTP method</doc>
        <type name="utf8" c:type="const char*"/>
      </field>
      <field name="status_code">
        <doc xml:space="preserve">the HTTP status code</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="reason_phrase">
        <doc xml:space="preserve">the status phrase associated with @status_code</doc>
        <type name="utf8" c:type="char*"/>
      </field>
      <field name="request_body">
        <doc xml:space="preserve">the request body</doc>
        <type name="MessageBody" c:type="SoupMessageBody*"/>
      </field>
      <field name="request_headers">
        <doc xml:space="preserve">the request headers</doc>
        <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
      </field>
      <field name="response_body">
        <doc xml:space="preserve">the response body</doc>
        <type name="MessageBody" c:type="SoupMessageBody*"/>
      </field>
      <field name="response_headers">
        <doc xml:space="preserve">the response headers</doc>
        <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
      </field>
      <glib:signal name="content-sniffed" when="first" version="2.28">
        <doc xml:space="preserve">This signal is emitted after #SoupMessage::got-headers, and
before the first #SoupMessage::got-chunk. If content
sniffing is disabled, or no content sniffing will be
performed, due to the sniffer deciding to trust the
Content-Type sent by the server, this signal is emitted
immediately after #SoupMessage::got-headers, and @type is
%NULL.

If the #SoupContentSniffer feature is enabled, and the
sniffer decided to perform sniffing, the first
#SoupMessage::got-chunk emission may be delayed, so that the
sniffer has enough data to correctly sniff the content. It
notified the library user that the content has been
sniffed, and allows it to change the header contents in the
message, if desired.

After this signal is emitted, the data that was spooled so
that sniffing could be done is delivered on the first
emission of #SoupMessage::got-chunk.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">the content type that we got from sniffing</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="params" transfer-ownership="none">
            <doc xml:space="preserve">a #GHashTable with the parameters</doc>
            <type name="GLib.HashTable">
              <type name="utf8"/>
              <type name="utf8"/>
            </type>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="finished" when="first">
        <doc xml:space="preserve">Emitted when all HTTP processing is finished for a message.
(After #SoupMessage::got_body for client-side messages, or
after #SoupMessage::wrote_body for server-side messages.)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="got-body" when="first">
        <doc xml:space="preserve">Emitted after receiving the complete message body. (For a
server-side message, this means it has received the request
body. For a client-side message, this means it has received
the response body and is nearly done with the message.)

See also soup_message_add_header_handler() and
soup_message_add_status_code_handler(), which can be used
to connect to a subset of emissions of this signal.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="got-chunk" when="first">
        <doc xml:space="preserve">Emitted after receiving a chunk of a message body. Note
that "chunk" in this context means any subpiece of the
body, not necessarily the specific HTTP 1.1 chunks sent by
the other side.

If you cancel or requeue @msg while processing this signal,
then the current HTTP I/O will be stopped after this signal
emission finished, and @msg's connection will be closed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="chunk" transfer-ownership="none">
            <doc xml:space="preserve">the just-read chunk</doc>
            <type name="Buffer"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="got-headers" when="first">
        <doc xml:space="preserve">Emitted after receiving all message headers for a message.
(For a client-side message, this is after receiving the
Status-Line and response headers; for a server-side
message, it is after receiving the Request-Line and request
headers.)

See also soup_message_add_header_handler() and
soup_message_add_status_code_handler(), which can be used
to connect to a subset of emissions of this signal.

If you cancel or requeue @msg while processing this signal,
then the current HTTP I/O will be stopped after this signal
emission finished, and @msg's connection will be closed.
(If you need to requeue a message--eg, after handling
authentication or redirection--it is usually better to
requeue it from a #SoupMessage::got_body handler rather
than a #SoupMessage::got_headers handler, so that the
existing HTTP connection can be reused.)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="got-informational" when="first">
        <doc xml:space="preserve">Emitted after receiving a 1xx (Informational) response for
a (client-side) message. The response_headers will be
filled in with the headers associated with the
informational response; however, those header values will
be erased after this signal is done.

If you cancel or requeue @msg while processing this signal,
then the current HTTP I/O will be stopped after this signal
emission finished, and @msg's connection will be closed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="network-event" when="first" version="2.38">
        <doc xml:space="preserve">Emitted to indicate that some network-related event
related to @msg has occurred. This essentially proxies the
#GSocketClient::event signal, but only for events that
occur while @msg "owns" the connection; if @msg is sent on
an existing persistent connection, then this signal will
not be emitted. (If you want to force the message to be
sent on a new connection, set the
%SOUP_MESSAGE_NEW_CONNECTION flag on it.)

See #GSocketClient::event for more information on what
the different values of @event correspond to, and what
@connection will be in each case.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="event" transfer-ownership="none">
            <doc xml:space="preserve">the network event</doc>
            <type name="Gio.SocketClientEvent"/>
          </parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the current state of the network connection</doc>
            <type name="Gio.IOStream"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="restarted" when="first">
        <doc xml:space="preserve">Emitted when a request that was already sent once is now
being sent again (eg, because the first attempt received a
redirection response, or because we needed to use
authentication).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="starting" when="first" version="2.50">
        <doc xml:space="preserve">Emitted just before a message is sent.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="wrote-body" when="first">
        <doc xml:space="preserve">Emitted immediately after writing the complete body for a
message. (For a client-side message, this means that
libsoup is done writing and is now waiting for the response
from the server. For a server-side message, this means that
libsoup has finished writing the response and is nearly
done with the message.)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="wrote-body-data" when="first" version="2.24">
        <doc xml:space="preserve">Emitted immediately after writing a portion of the message
body to the network.

Unlike #SoupMessage::wrote_chunk, this is emitted after
every successful write() call, not only after finishing a
complete "chunk".</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="chunk" transfer-ownership="none">
            <doc xml:space="preserve">the data written</doc>
            <type name="Buffer"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="wrote-chunk" when="first">
        <doc xml:space="preserve">Emitted immediately after writing a body chunk for a message.

Note that this signal is not parallel to
#SoupMessage::got_chunk; it is emitted only when a complete
chunk (added with soup_message_body_append() or
soup_message_body_append_buffer()) has been written. To get
more useful continuous progress information, use
#SoupMessage::wrote_body_data.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="wrote-headers" when="first">
        <doc xml:space="preserve">Emitted immediately after writing the headers for a
message. (For a client-side message, this is after writing
the request headers; for a server-side message, it is after
writing the response headers.)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="wrote-informational" when="first">
        <doc xml:space="preserve">Emitted immediately after writing a 1xx (Informational)
response for a (server-side) message.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
    </class>
    <record name="MessageBody"
            c:type="SoupMessageBody"
            glib:type-name="SoupMessageBody"
            glib:get-type="soup_message_body_get_type"
            c:symbol-prefix="message_body">
      <doc xml:space="preserve">A #SoupMessage request or response body.

Note that while @length always reflects the full length of the
message body, @data is normally %NULL, and will only be filled in
after soup_message_body_flatten() is called. For client-side
messages, this automatically happens for the response body after it
has been fully read, unless you set the
%SOUP_MESSAGE_OVERWRITE_CHUNKS flags. Likewise, for server-side
messages, the request body is automatically filled in after being
read.

As an added bonus, when @data is filled in, it is always terminated
with a '\0' byte (which is not reflected in @length).</doc>
      <field name="data" writable="1">
        <doc xml:space="preserve">the data</doc>
        <type name="utf8" c:type="const char*"/>
      </field>
      <field name="length" writable="1">
        <doc xml:space="preserve">length of @data</doc>
        <type name="gint64" c:type="goffset"/>
      </field>
      <constructor name="new" c:identifier="soup_message_body_new">
        <doc xml:space="preserve">Creates a new #SoupMessageBody. #SoupMessage uses this internally; you
will not normally need to call it yourself.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #SoupMessageBody.</doc>
          <type name="MessageBody" c:type="SoupMessageBody*"/>
        </return-value>
      </constructor>
      <method name="append"
              c:identifier="soup_message_body_append"
              shadowed-by="append_take">
        <doc xml:space="preserve">Appends @length bytes from @data to @body according to @use.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="body" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageBody</doc>
            <type name="MessageBody" c:type="SoupMessageBody*"/>
          </instance-parameter>
          <parameter name="use" transfer-ownership="none">
            <doc xml:space="preserve">how to use @data</doc>
            <type name="MemoryUse" c:type="SoupMemoryUse"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">data to append</doc>
            <array length="2" zero-terminated="0" c:type="gconstpointer">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">length of @data</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="append_buffer"
              c:identifier="soup_message_body_append_buffer">
        <doc xml:space="preserve">Appends the data from @buffer to @body. (#SoupMessageBody uses
#SoupBuffers internally, so this is normally a constant-time
operation that doesn't actually require copying the data in
@buffer.)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="body" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageBody</doc>
            <type name="MessageBody" c:type="SoupMessageBody*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupBuffer</doc>
            <type name="Buffer" c:type="SoupBuffer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="append_take"
              c:identifier="soup_message_body_append_take"
              shadows="append"
              version="2.32">
        <doc xml:space="preserve">Appends @length bytes from @data to @body.

This function is exactly equivalent to soup_message_body_append()
with %SOUP_MEMORY_TAKE as second argument; it exists mainly for
convenience and simplifying language bindings.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="body" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageBody</doc>
            <type name="MessageBody" c:type="SoupMessageBody*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="full">
            <doc xml:space="preserve">data to append</doc>
            <array length="1" zero-terminated="0" c:type="guchar*">
              <type name="guint8" c:type="guchar"/>
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">length of @data</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="complete" c:identifier="soup_message_body_complete">
        <doc xml:space="preserve">Tags @body as being complete; Call this when using chunked encoding
after you have appended the last chunk.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="body" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageBody</doc>
            <type name="MessageBody" c:type="SoupMessageBody*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="flatten" c:identifier="soup_message_body_flatten">
        <doc xml:space="preserve">Fills in @body's data field with a buffer containing all of the
data in @body (plus an additional '\0' byte not counted by @body's
length field).</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #SoupBuffer containing the same data as @body.
(You must free this buffer if you do not want it.)</doc>
          <type name="Buffer" c:type="SoupBuffer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="body" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageBody</doc>
            <type name="MessageBody" c:type="SoupMessageBody*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="soup_message_body_free">
        <doc xml:space="preserve">Frees @body. You will not normally need to use this, as
#SoupMessage frees its associated message bodies automatically.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="body" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageBody</doc>
            <type name="MessageBody" c:type="SoupMessageBody*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_accumulate"
              c:identifier="soup_message_body_get_accumulate"
              version="2.24">
        <doc xml:space="preserve">Gets the accumulate flag on @body; see
soup_message_body_set_accumulate() for details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the accumulate flag for @body.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="body" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageBody</doc>
            <type name="MessageBody" c:type="SoupMessageBody*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_chunk" c:identifier="soup_message_body_get_chunk">
        <doc xml:space="preserve">Gets a #SoupBuffer containing data from @body starting at @offset.
The size of the returned chunk is unspecified. You can iterate
through the entire body by first calling
soup_message_body_get_chunk() with an offset of 0, and then on each
successive call, increment the offset by the length of the
previously-returned chunk.

If @offset is greater than or equal to the total length of @body,
then the return value depends on whether or not
soup_message_body_complete() has been called or not; if it has,
then soup_message_body_get_chunk() will return a 0-length chunk
(indicating the end of @body). If it has not, then
soup_message_body_get_chunk() will return %NULL (indicating that
@body may still potentially have more data, but that data is not
currently available).</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a #SoupBuffer, or %NULL.</doc>
          <type name="Buffer" c:type="SoupBuffer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="body" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageBody</doc>
            <type name="MessageBody" c:type="SoupMessageBody*"/>
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve">an offset</doc>
            <type name="gint64" c:type="goffset"/>
          </parameter>
        </parameters>
      </method>
      <method name="got_chunk"
              c:identifier="soup_message_body_got_chunk"
              version="2.24">
        <doc xml:space="preserve">Handles the #SoupMessageBody part of receiving a chunk of data from
the network. Normally this means appending @chunk to @body, exactly
as with soup_message_body_append_buffer(), but if you have set
@body's accumulate flag to %FALSE, then that will not happen.

This is a low-level method which you should not normally need to
use.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="body" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageBody</doc>
            <type name="MessageBody" c:type="SoupMessageBody*"/>
          </instance-parameter>
          <parameter name="chunk" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupBuffer received from the network</doc>
            <type name="Buffer" c:type="SoupBuffer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_accumulate"
              c:identifier="soup_message_body_set_accumulate"
              version="2.24">
        <doc xml:space="preserve">Sets or clears the accumulate flag on @body. (The default value is
%TRUE.) If set to %FALSE, @body's %data field will not be filled in
after the body is fully sent/received, and the chunks that make up
@body may be discarded when they are no longer needed.

In particular, if you set this flag to %FALSE on an "incoming"
message body (that is, the #SoupMessage:response_body of a
client-side message, or #SoupMessage:request_body of a server-side
message), this will cause each chunk of the body to be discarded
after its corresponding #SoupMessage::got_chunk signal is emitted.
(This is equivalent to setting the deprecated
%SOUP_MESSAGE_OVERWRITE_CHUNKS flag on the message.)

If you set this flag to %FALSE on the #SoupMessage:response_body of
a server-side message, it will cause each chunk of the body to be
discarded after its corresponding #SoupMessage::wrote_chunk signal
is emitted.

If you set the flag to %FALSE on the #SoupMessage:request_body of a
client-side message, it will block the accumulation of chunks into
@body's %data field, but it will not normally cause the chunks to
be discarded after being written like in the server-side
#SoupMessage:response_body case, because the request body needs to
be kept around in case the request needs to be sent a second time
due to redirection or authentication. However, if you set the
%SOUP_MESSAGE_CAN_REBUILD flag on the message, then the chunks will
be discarded, and you will be responsible for recreating the
request body after the #SoupMessage::restarted signal is emitted.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="body" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageBody</doc>
            <type name="MessageBody" c:type="SoupMessageBody*"/>
          </instance-parameter>
          <parameter name="accumulate" transfer-ownership="none">
            <doc xml:space="preserve">whether or not to accumulate body chunks in @body</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="truncate" c:identifier="soup_message_body_truncate">
        <doc xml:space="preserve">Deletes all of the data in @body.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="body" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageBody</doc>
            <type name="MessageBody" c:type="SoupMessageBody*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="wrote_chunk"
              c:identifier="soup_message_body_wrote_chunk"
              version="2.24">
        <doc xml:space="preserve">Handles the #SoupMessageBody part of writing a chunk of data to the
network. Normally this is a no-op, but if you have set @body's
accumulate flag to %FALSE, then this will cause @chunk to be
discarded to free up memory.

This is a low-level method which you should not need to use, and
there are further restrictions on its proper use which are not
documented here.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="body" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageBody</doc>
            <type name="MessageBody" c:type="SoupMessageBody*"/>
          </instance-parameter>
          <parameter name="chunk" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupBuffer returned from soup_message_body_get_chunk()</doc>
            <type name="Buffer" c:type="SoupBuffer*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <record name="MessageClass"
            c:type="SoupMessageClass"
            glib:is-gtype-struct-for="Message">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="wrote_informational">
        <callback name="wrote_informational">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="msg" transfer-ownership="none">
              <type name="Message" c:type="SoupMessage*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="wrote_headers">
        <callback name="wrote_headers">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="msg" transfer-ownership="none">
              <type name="Message" c:type="SoupMessage*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="wrote_chunk">
        <callback name="wrote_chunk">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="msg" transfer-ownership="none">
              <type name="Message" c:type="SoupMessage*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="wrote_body">
        <callback name="wrote_body">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="msg" transfer-ownership="none">
              <type name="Message" c:type="SoupMessage*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="got_informational">
        <callback name="got_informational">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="msg" transfer-ownership="none">
              <type name="Message" c:type="SoupMessage*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="got_headers">
        <callback name="got_headers">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="msg" transfer-ownership="none">
              <type name="Message" c:type="SoupMessage*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="got_chunk">
        <callback name="got_chunk">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="msg" transfer-ownership="none">
              <type name="Message" c:type="SoupMessage*"/>
            </parameter>
            <parameter name="chunk" transfer-ownership="none">
              <type name="Buffer" c:type="SoupBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="got_body">
        <callback name="got_body">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="msg" transfer-ownership="none">
              <type name="Message" c:type="SoupMessage*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="restarted">
        <callback name="restarted">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="msg" transfer-ownership="none">
              <type name="Message" c:type="SoupMessage*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="finished">
        <callback name="finished">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="msg" transfer-ownership="none">
              <type name="Message" c:type="SoupMessage*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="starting">
        <callback name="starting">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="msg" transfer-ownership="none">
              <type name="Message" c:type="SoupMessage*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_libsoup_reserved1" introspectable="0">
        <callback name="_libsoup_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_libsoup_reserved2" introspectable="0">
        <callback name="_libsoup_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_libsoup_reserved3" introspectable="0">
        <callback name="_libsoup_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <bitfield name="MessageFlags"
              glib:type-name="SoupMessageFlags"
              glib:get-type="soup_message_flags_get_type"
              c:type="SoupMessageFlags">
      <doc xml:space="preserve">Various flags that can be set on a #SoupMessage to alter its
behavior.</doc>
      <member name="no_redirect"
              value="2"
              c:identifier="SOUP_MESSAGE_NO_REDIRECT"
              glib:nick="no-redirect">
        <doc xml:space="preserve">The session should not follow redirect
  (3xx) responses received by this message.</doc>
      </member>
      <member name="can_rebuild"
              value="4"
              c:identifier="SOUP_MESSAGE_CAN_REBUILD"
              glib:nick="can-rebuild">
        <doc xml:space="preserve">The caller will rebuild the request
  body if the message is restarted; see
  soup_message_body_set_accumulate() for more details.</doc>
      </member>
      <member name="overwrite_chunks"
              value="8"
              c:identifier="SOUP_MESSAGE_OVERWRITE_CHUNKS"
              glib:nick="overwrite-chunks">
        <doc xml:space="preserve">Deprecated: equivalent to calling
  soup_message_body_set_accumulate() on the incoming message body
  (ie, #SoupMessage:response_body for a client-side request),
  passing %FALSE.</doc>
      </member>
      <member name="content_decoded"
              value="16"
              c:identifier="SOUP_MESSAGE_CONTENT_DECODED"
              glib:nick="content-decoded">
        <doc xml:space="preserve">Set by #SoupContentDecoder to
  indicate that it has removed the Content-Encoding on a message (and
  so headers such as Content-Length may no longer accurately describe
  the body).</doc>
      </member>
      <member name="certificate_trusted"
              value="32"
              c:identifier="SOUP_MESSAGE_CERTIFICATE_TRUSTED"
              glib:nick="certificate-trusted">
        <doc xml:space="preserve">if set after an https response
  has been received, indicates that the server's SSL certificate is
  trusted according to the session's CA.</doc>
      </member>
      <member name="new_connection"
              value="64"
              c:identifier="SOUP_MESSAGE_NEW_CONNECTION"
              glib:nick="new-connection">
        <doc xml:space="preserve">Requests that the message should be
  sent on a newly-created connection, not reusing an existing
  persistent connection. Note that messages with non-idempotent
  #SoupMessage:method&lt;!-- --&gt;s behave this way by default, unless
  #SOUP_MESSAGE_IDEMPOTENT is set.</doc>
      </member>
      <member name="idempotent"
              value="128"
              c:identifier="SOUP_MESSAGE_IDEMPOTENT"
              glib:nick="idempotent">
        <doc xml:space="preserve">The message is considered idempotent,
  regardless its #SoupMessage:method, and allows reuse of existing
  idle connections, instead of always requiring a new one, unless
  #SOUP_MESSAGE_NEW_CONNECTION is set.</doc>
      </member>
      <member name="ignore_connection_limits"
              value="256"
              c:identifier="SOUP_MESSAGE_IGNORE_CONNECTION_LIMITS"
              glib:nick="ignore-connection-limits">
        <doc xml:space="preserve">Request that a new connection is
  created for the message if there aren't idle connections available
  and it's not possible to create new connections due to any of the
  connection limits has been reached. If a dedicated connection is
  eventually created for this message, it will be dropped when the
  message finishes. Since 2.50</doc>
      </member>
    </bitfield>
    <record name="MessageHeaders"
            c:type="SoupMessageHeaders"
            glib:type-name="SoupMessageHeaders"
            glib:get-type="soup_message_headers_get_type"
            c:symbol-prefix="message_headers">
      <doc xml:space="preserve">The HTTP message headers associated with a request or response.</doc>
      <constructor name="new" c:identifier="soup_message_headers_new">
        <doc xml:space="preserve">Creates a #SoupMessageHeaders. (#SoupMessage does this
automatically for its own headers. You would only need to use this
method if you are manually parsing or generating message headers.)</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #SoupMessageHeaders</doc>
          <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">the type of headers</doc>
            <type name="MessageHeadersType" c:type="SoupMessageHeadersType"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="append" c:identifier="soup_message_headers_append">
        <doc xml:space="preserve">Appends a new header with name @name and value @value to @hdrs. (If
there is an existing header with name @name, then this creates a
second one, which is only allowed for list-valued headers; see also
soup_message_headers_replace().)

The caller is expected to make sure that @name and @value are
syntactically correct.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the header name to add</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the new value of @name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="clean_connection_headers"
              c:identifier="soup_message_headers_clean_connection_headers"
              version="2.36">
        <doc xml:space="preserve">Removes all the headers listed in the Connection header.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="clear" c:identifier="soup_message_headers_clear">
        <doc xml:space="preserve">Clears @hdrs.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="foreach" c:identifier="soup_message_headers_foreach">
        <doc xml:space="preserve">Calls @func once for each header value in @hdrs.

Beware that unlike soup_message_headers_get(), this processes the
headers in exactly the way they were added, rather than
concatenating multiple same-named headers into a single value.
(This is intentional; it ensures that if you call
soup_message_headers_append() multiple times with the same name,
then the I/O code will output multiple copies of the header when
sending the message to the remote implementation, which may be
required for interoperability in some cases.)

You may not modify the headers from @func.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve">callback function to run for each header</doc>
            <type name="MessageHeadersForeachFunc"
                  c:type="SoupMessageHeadersForeachFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">data to pass to @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="soup_message_headers_free">
        <doc xml:space="preserve">Frees @hdrs.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free_ranges"
              c:identifier="soup_message_headers_free_ranges"
              version="2.26">
        <doc xml:space="preserve">Frees the array of ranges returned from soup_message_headers_get_ranges().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
          <parameter name="ranges" transfer-ownership="none">
            <doc xml:space="preserve">an array of #SoupRange</doc>
            <type name="Range" c:type="SoupRange*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get"
              c:identifier="soup_message_headers_get"
              deprecated="1">
        <doc xml:space="preserve">Gets the value of header @name in @hdrs.

This method was supposed to work correctly for both single-valued
and list-valued headers, but because some HTTP clients/servers
mistakenly send multiple copies of headers that are supposed to be
single-valued, it sometimes returns incorrect results. To fix this,
the methods soup_message_headers_get_one() and
soup_message_headers_get_list() were introduced, so callers can
explicitly state which behavior they are expecting.</doc>
        <doc-deprecated xml:space="preserve">Use soup_message_headers_get_one() or
soup_message_headers_get_list() instead.</doc-deprecated>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">as with soup_message_headers_get_list().</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">header name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_content_disposition"
              c:identifier="soup_message_headers_get_content_disposition"
              version="2.26">
        <doc xml:space="preserve">Looks up the "Content-Disposition" header in @hdrs, parses it, and
returns its value in *@disposition and *@params. @params can be
%NULL if you are only interested in the disposition-type.

In HTTP, the most common use of this header is to set a
disposition-type of "attachment", to suggest to the browser that a
response should be saved to disk rather than displayed in the
browser. If @params contains a "filename" parameter, this is a
suggestion of a filename to use. (If the parameter value in the
header contains an absolute or relative path, libsoup will truncate
it down to just the final path component, so you do not need to
test this yourself.)

Content-Disposition is also used in "multipart/form-data", however
this is handled automatically by #SoupMultipart and the associated
form methods.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @hdrs contains a "Content-Disposition"
header, %FALSE if not (in which case *@disposition and *@params
will be unchanged).</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
          <parameter name="disposition"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">return location for the
disposition-type, or %NULL</doc>
            <type name="utf8" c:type="char**"/>
          </parameter>
          <parameter name="params"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">return
location for the Content-Disposition parameters, or %NULL</doc>
            <type name="GLib.HashTable" c:type="GHashTable**">
              <type name="utf8"/>
              <type name="utf8"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="get_content_length"
              c:identifier="soup_message_headers_get_content_length">
        <doc xml:space="preserve">Gets the message body length that @hdrs declare. This will only
be non-0 if soup_message_headers_get_encoding() returns
%SOUP_ENCODING_CONTENT_LENGTH.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the message body length declared by @hdrs.</doc>
          <type name="gint64" c:type="goffset"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_content_range"
              c:identifier="soup_message_headers_get_content_range"
              version="2.26">
        <doc xml:space="preserve">Parses @hdrs's Content-Range header and returns it in @start,
@end, and @total_length. If the total length field in the header
was specified as "*", then @total_length will be set to -1.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @hdrs contained a "Content-Range" header
containing a byte range which could be parsed, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
          <parameter name="start" transfer-ownership="none">
            <doc xml:space="preserve">return value for the start of the range</doc>
            <type name="gint64" c:type="goffset*"/>
          </parameter>
          <parameter name="end" transfer-ownership="none">
            <doc xml:space="preserve">return value for the end of the range</doc>
            <type name="gint64" c:type="goffset*"/>
          </parameter>
          <parameter name="total_length" transfer-ownership="none">
            <doc xml:space="preserve">return value for the total length of the resource,
or %NULL if you don't care.</doc>
            <type name="gint64" c:type="goffset*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_content_type"
              c:identifier="soup_message_headers_get_content_type"
              version="2.26">
        <doc xml:space="preserve">Looks up the "Content-Type" header in @hdrs, parses it, and returns
its value in *@content_type and *@params. @params can be %NULL if you
are only interested in the content type itself.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">a string with the value of the
"Content-Type" header or %NULL if @hdrs does not contain that
header or it cannot be parsed (in which case *@params will be
unchanged).</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
          <parameter name="params"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">
  return location for the Content-Type parameters (eg, "charset"), or
  %NULL</doc>
            <type name="GLib.HashTable" c:type="GHashTable**">
              <type name="utf8"/>
              <type name="utf8"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="get_encoding"
              c:identifier="soup_message_headers_get_encoding">
        <doc xml:space="preserve">Gets the message body encoding that @hdrs declare. This may not
always correspond to the encoding used on the wire; eg, a HEAD
response may declare a Content-Length or Transfer-Encoding, but
it will never actually include a body.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the encoding declared by @hdrs.</doc>
          <type name="Encoding" c:type="SoupEncoding"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_expectations"
              c:identifier="soup_message_headers_get_expectations">
        <doc xml:space="preserve">Gets the expectations declared by @hdrs's "Expect" header.
Currently this will either be %SOUP_EXPECTATION_CONTINUE or
%SOUP_EXPECTATION_UNRECOGNIZED.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the contents of @hdrs's "Expect" header</doc>
          <type name="Expectation" c:type="SoupExpectation"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_headers_type"
              c:identifier="soup_message_headers_get_headers_type"
              version="2.50">
        <doc xml:space="preserve">Gets the type of headers.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the header's type.</doc>
          <type name="MessageHeadersType" c:type="SoupMessageHeadersType"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_list"
              c:identifier="soup_message_headers_get_list"
              version="2.28">
        <doc xml:space="preserve">Gets the value of header @name in @hdrs. Use this for headers whose
values are comma-delimited lists, and which are therefore allowed
to appear multiple times in the headers. For non-list-valued
headers, use soup_message_headers_get_one().

If @name appears multiple times in @hdrs,
soup_message_headers_get_list() will concatenate all of the values
together, separated by commas. This is sometimes awkward to parse
(eg, WWW-Authenticate, Set-Cookie), but you have to be able to deal
with it anyway, because the HTTP spec explicitly states that this
transformation is allowed, and so an upstream proxy could do the
same thing.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the header's value or %NULL if not found.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">header name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_one"
              c:identifier="soup_message_headers_get_one"
              version="2.28">
        <doc xml:space="preserve">Gets the value of header @name in @hdrs. Use this for headers whose
values are &lt;emphasis&gt;not&lt;/emphasis&gt; comma-delimited lists, and
which therefore can only appear at most once in the headers. For
list-valued headers, use soup_message_headers_get_list().

If @hdrs does erroneously contain multiple copies of the header, it
is not defined which one will be returned. (Ideally, it will return
whichever one makes libsoup most compatible with other HTTP
implementations.)</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the header's value or %NULL if not found.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">header name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_ranges"
              c:identifier="soup_message_headers_get_ranges"
              version="2.26">
        <doc xml:space="preserve">Parses @hdrs's Range header and returns an array of the requested
byte ranges. The returned array must be freed with
soup_message_headers_free_ranges().

If @total_length is non-0, its value will be used to adjust the
returned ranges to have explicit start and end values, and the
returned ranges will be sorted and non-overlapping. If
@total_length is 0, then some ranges may have an end value of -1,
as described under #SoupRange, and some of the ranges may be
redundant.

Beware that even if given a @total_length, this function does not
check that the ranges are satisfiable.

&lt;note&gt;&lt;para&gt;
#SoupServer has built-in handling for range requests. If your
server handler returns a %SOUP_STATUS_OK response containing the
complete response body (rather than pausing the message and
returning some of the response body later), and there is a Range
header in the request, then libsoup will automatically convert the
response to a %SOUP_STATUS_PARTIAL_CONTENT response containing only
the range(s) requested by the client.

The only time you need to process the Range header yourself is if
either you need to stream the response body rather than returning
it all at once, or you do not already have the complete response
body available, and only want to generate the parts that were
actually requested by the client.
&lt;/para&gt;&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @hdrs contained a syntactically-valid
"Range" header, %FALSE otherwise (in which case @range and @length
will not be set).</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
          <parameter name="total_length" transfer-ownership="none">
            <doc xml:space="preserve">the total_length of the response body</doc>
            <type name="gint64" c:type="goffset"/>
          </parameter>
          <parameter name="ranges"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">return location for an array
of #SoupRange</doc>
            <array length="2" zero-terminated="0" c:type="SoupRange**">
              <type name="Range" c:type="SoupRange*"/>
            </array>
          </parameter>
          <parameter name="length"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">the length of the returned array</doc>
            <type name="gint" c:type="int*"/>
          </parameter>
        </parameters>
      </method>
      <method name="header_contains"
              c:identifier="soup_message_headers_header_contains"
              version="2.50">
        <doc xml:space="preserve">Checks whether the list-valued header @name is present in @hdrs,
and contains a case-insensitive match for @token.

(If @name is present in @hdrs, then this is equivalent to calling
soup_header_contains() on its value.)</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the header is present and contains @token,
  %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">header name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="token" transfer-ownership="none">
            <doc xml:space="preserve">token to look for</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="header_equals"
              c:identifier="soup_message_headers_header_equals"
              version="2.50">
        <doc xml:space="preserve">Checks whether the header @name is present in @hdrs and is
(case-insensitively) equal to @value.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the header is present and its value is
  @value, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">header name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">expected value</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove" c:identifier="soup_message_headers_remove">
        <doc xml:space="preserve">Removes @name from @hdrs. If there are multiple values for @name,
they are all removed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the header name to remove</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="replace" c:identifier="soup_message_headers_replace">
        <doc xml:space="preserve">Replaces the value of the header @name in @hdrs with @value. (See
also soup_message_headers_append().)

The caller is expected to make sure that @name and @value are
syntactically correct.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the header name to replace</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the new value of @name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_content_disposition"
              c:identifier="soup_message_headers_set_content_disposition"
              version="2.26">
        <doc xml:space="preserve">Sets the "Content-Disposition" header in @hdrs to @disposition,
optionally with additional parameters specified in @params.

See soup_message_headers_get_content_disposition() for a discussion
of how Content-Disposition is used in HTTP.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
          <parameter name="disposition" transfer-ownership="none">
            <doc xml:space="preserve">the disposition-type</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="params"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">additional
parameters, or %NULL</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="utf8"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="set_content_length"
              c:identifier="soup_message_headers_set_content_length">
        <doc xml:space="preserve">Sets the message body length that @hdrs will declare, and sets
@hdrs's encoding to %SOUP_ENCODING_CONTENT_LENGTH.

You do not normally need to call this; if @hdrs is set to use
Content-Length encoding, libsoup will automatically set its
Content-Length header for you immediately before sending the
headers. One situation in which this method is useful is when
generating the response to a HEAD request; Calling
soup_message_headers_set_content_length() allows you to put the
correct content length into the response without needing to waste
memory by filling in a response body which won't actually be sent.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
          <parameter name="content_length" transfer-ownership="none">
            <doc xml:space="preserve">the message body length</doc>
            <type name="gint64" c:type="goffset"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_content_range"
              c:identifier="soup_message_headers_set_content_range"
              version="2.26">
        <doc xml:space="preserve">Sets @hdrs's Content-Range header according to the given values.
(Note that @total_length is the total length of the entire resource
that this is a range of, not simply @end - @start + 1.)

&lt;note&gt;&lt;para&gt;
#SoupServer has built-in handling for range requests, and you do
not normally need to call this function youself. See
soup_message_headers_get_ranges() for more details.
&lt;/para&gt;&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
          <parameter name="start" transfer-ownership="none">
            <doc xml:space="preserve">the start of the range</doc>
            <type name="gint64" c:type="goffset"/>
          </parameter>
          <parameter name="end" transfer-ownership="none">
            <doc xml:space="preserve">the end of the range</doc>
            <type name="gint64" c:type="goffset"/>
          </parameter>
          <parameter name="total_length" transfer-ownership="none">
            <doc xml:space="preserve">the total length of the resource, or -1 if unknown</doc>
            <type name="gint64" c:type="goffset"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_content_type"
              c:identifier="soup_message_headers_set_content_type"
              version="2.26">
        <doc xml:space="preserve">Sets the "Content-Type" header in @hdrs to @content_type,
optionally with additional parameters specified in @params.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
          <parameter name="content_type" transfer-ownership="none">
            <doc xml:space="preserve">the MIME type</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="params"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">additional
parameters, or %NULL</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="utf8"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="set_encoding"
              c:identifier="soup_message_headers_set_encoding">
        <doc xml:space="preserve">Sets the message body encoding that @hdrs will declare. In particular,
you should use this if you are going to send a request or response in
chunked encoding.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
          <parameter name="encoding" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupEncoding</doc>
            <type name="Encoding" c:type="SoupEncoding"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_expectations"
              c:identifier="soup_message_headers_set_expectations">
        <doc xml:space="preserve">Sets @hdrs's "Expect" header according to @expectations.

Currently %SOUP_EXPECTATION_CONTINUE is the only known expectation
value. You should set this value on a request if you are sending a
large message body (eg, via POST or PUT), and want to give the
server a chance to reject the request after seeing just the headers
(eg, because it will require authentication before allowing you to
post, or because you're POSTing to a URL that doesn't exist). This
saves you from having to transmit the large request body when the
server is just going to ignore it anyway.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
          <parameter name="expectations" transfer-ownership="none">
            <doc xml:space="preserve">the expectations to set</doc>
            <type name="Expectation" c:type="SoupExpectation"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_range"
              c:identifier="soup_message_headers_set_range"
              version="2.26">
        <doc xml:space="preserve">Sets @hdrs's Range header to request the indicated range.
@start and @end are interpreted as in a #SoupRange.

If you need to request multiple ranges, use
soup_message_headers_set_ranges().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
          <parameter name="start" transfer-ownership="none">
            <doc xml:space="preserve">the start of the range to request</doc>
            <type name="gint64" c:type="goffset"/>
          </parameter>
          <parameter name="end" transfer-ownership="none">
            <doc xml:space="preserve">the end of the range to request</doc>
            <type name="gint64" c:type="goffset"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_ranges"
              c:identifier="soup_message_headers_set_ranges"
              version="2.26">
        <doc xml:space="preserve">Sets @hdrs's Range header to request the indicated ranges. (If you
only want to request a single range, you can use
soup_message_headers_set_range().)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
          <parameter name="ranges" transfer-ownership="none">
            <doc xml:space="preserve">an array of #SoupRange</doc>
            <type name="Range" c:type="SoupRange*"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">the length of @range</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <callback name="MessageHeadersForeachFunc"
              c:type="SoupMessageHeadersForeachFunc">
      <doc xml:space="preserve">The callback passed to soup_message_headers_foreach().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">the header name</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">the header value</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:space="preserve">the data passed to soup_message_headers_foreach()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="MessageHeadersIter" c:type="SoupMessageHeadersIter">
      <doc xml:space="preserve">An opaque type used to iterate over a %SoupMessageHeaders
structure.

After intializing the iterator with
soup_message_headers_iter_init(), call
soup_message_headers_iter_next() to fetch data from it.

You may not modify the headers while iterating over them.</doc>
      <field name="dummy" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="3">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <method name="next" c:identifier="soup_message_headers_iter_next">
        <doc xml:space="preserve">Yields the next name/value pair in the %SoupMessageHeaders being
iterated by @iter. If @iter has already yielded the last header,
then soup_message_headers_iter_next() will return %FALSE and @name
and @value will be unchanged.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if another name and value were returned, %FALSE
if the end of the headers has been reached.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="iter"
                              direction="inout"
                              caller-allocates="0"
                              transfer-ownership="none">
            <doc xml:space="preserve">a %SoupMessageHeadersIter</doc>
            <type name="MessageHeadersIter" c:type="SoupMessageHeadersIter*"/>
          </instance-parameter>
          <parameter name="name"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:space="preserve">pointer to a variable to return
the header name in</doc>
            <type name="utf8" c:type="const char**"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:space="preserve">pointer to a variable to return
the header value in</doc>
            <type name="utf8" c:type="const char**"/>
          </parameter>
        </parameters>
      </method>
      <function name="init" c:identifier="soup_message_headers_iter_init">
        <doc xml:space="preserve">Initializes @iter for iterating @hdrs.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="iter"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">a pointer to a %SoupMessageHeadersIter
structure</doc>
            <type name="MessageHeadersIter" c:type="SoupMessageHeadersIter*"/>
          </parameter>
          <parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a %SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <enumeration name="MessageHeadersType"
                 glib:type-name="SoupMessageHeadersType"
                 glib:get-type="soup_message_headers_type_get_type"
                 c:type="SoupMessageHeadersType">
      <doc xml:space="preserve">Value passed to soup_message_headers_new() to set certain default
behaviors.</doc>
      <member name="request"
              value="0"
              c:identifier="SOUP_MESSAGE_HEADERS_REQUEST"
              glib:nick="request">
        <doc xml:space="preserve">request headers</doc>
      </member>
      <member name="response"
              value="1"
              c:identifier="SOUP_MESSAGE_HEADERS_RESPONSE"
              glib:nick="response">
        <doc xml:space="preserve">response headers</doc>
      </member>
      <member name="multipart"
              value="2"
              c:identifier="SOUP_MESSAGE_HEADERS_MULTIPART"
              glib:nick="multipart">
        <doc xml:space="preserve">multipart body part headers</doc>
      </member>
    </enumeration>
    <enumeration name="MessagePriority"
                 glib:type-name="SoupMessagePriority"
                 glib:get-type="soup_message_priority_get_type"
                 c:type="SoupMessagePriority">
      <doc xml:space="preserve">Priorities that can be set on a #SoupMessage to instruct the
message queue to process it before any other message with lower
priority.</doc>
      <member name="very_low"
              value="0"
              c:identifier="SOUP_MESSAGE_PRIORITY_VERY_LOW"
              glib:nick="very-low">
        <doc xml:space="preserve">The lowest priority, the messages
  with this priority will be the last ones to be attended.</doc>
      </member>
      <member name="low"
              value="1"
              c:identifier="SOUP_MESSAGE_PRIORITY_LOW"
              glib:nick="low">
        <doc xml:space="preserve">Use this for low priority messages, a
  #SoupMessage with the default priority will be processed first.</doc>
      </member>
      <member name="normal"
              value="2"
              c:identifier="SOUP_MESSAGE_PRIORITY_NORMAL"
              glib:nick="normal">
        <doc xml:space="preserve">The default priotity, this is the
  priority assigned to the #SoupMessage by default.</doc>
      </member>
      <member name="high"
              value="3"
              c:identifier="SOUP_MESSAGE_PRIORITY_HIGH"
              glib:nick="high">
        <doc xml:space="preserve">High priority, a #SoupMessage with
  this priority will be processed before the ones with the default
  priority.</doc>
      </member>
      <member name="very_high"
              value="4"
              c:identifier="SOUP_MESSAGE_PRIORITY_VERY_HIGH"
              glib:nick="very-high">
        <doc xml:space="preserve">The highest priority, use this
  for very urgent #SoupMessage as they will be the first ones to be
  attended.</doc>
      </member>
    </enumeration>
    <record name="MessageQueue" c:type="SoupMessageQueue" disguised="1">
    </record>
    <record name="MessageQueueItem"
            c:type="SoupMessageQueueItem"
            disguised="1">
    </record>
    <record name="Multipart"
            c:type="SoupMultipart"
            version="2.26"
            glib:type-name="SoupMultipart"
            glib:get-type="soup_multipart_get_type"
            c:symbol-prefix="multipart">
      <doc xml:space="preserve">Represents a multipart HTTP message body, parsed according to the
syntax of RFC 2046. Of particular interest to HTTP are
&lt;literal&gt;multipart/byte-ranges&lt;/literal&gt; and
&lt;literal&gt;multipart/form-data&lt;/literal&gt;.

Although the headers of a #SoupMultipart body part will contain the
full headers from that body part, libsoup does not interpret them
according to MIME rules. For example, each body part is assumed to
have "binary" Content-Transfer-Encoding, even if its headers
explicitly state otherwise. In other words, don't try to use
#SoupMultipart for handling real MIME multiparts.</doc>
      <constructor name="new" c:identifier="soup_multipart_new" version="2.26">
        <doc xml:space="preserve">Creates a new empty #SoupMultipart with a randomly-generated
boundary string. Note that @mime_type must be the full MIME type,
including "multipart/".</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new empty #SoupMultipart of the given @mime_type</doc>
          <type name="Multipart" c:type="SoupMultipart*"/>
        </return-value>
        <parameters>
          <parameter name="mime_type" transfer-ownership="none">
            <doc xml:space="preserve">the MIME type of the multipart to create.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_message"
                   c:identifier="soup_multipart_new_from_message"
                   version="2.26">
        <doc xml:space="preserve">Parses @headers and @body to form a new #SoupMultipart</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a new #SoupMultipart (or %NULL if the
message couldn't be parsed or wasn't multipart).</doc>
          <type name="Multipart" c:type="SoupMultipart*"/>
        </return-value>
        <parameters>
          <parameter name="headers" transfer-ownership="none">
            <doc xml:space="preserve">the headers of the HTTP message to parse</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </parameter>
          <parameter name="body" transfer-ownership="none">
            <doc xml:space="preserve">the body of the HTTP message to parse</doc>
            <type name="MessageBody" c:type="SoupMessageBody*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="append_form_file"
              c:identifier="soup_multipart_append_form_file"
              version="2.26">
        <doc xml:space="preserve">Adds a new MIME part containing @body to @multipart, using
"Content-Disposition: form-data", as per the HTML forms
specification. See soup_form_request_new_from_multipart() for more
details.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="multipart" transfer-ownership="none">
            <doc xml:space="preserve">a multipart (presumably of type "multipart/form-data")</doc>
            <type name="Multipart" c:type="SoupMultipart*"/>
          </instance-parameter>
          <parameter name="control_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the control associated with this file</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve">the name of the file, or %NULL if not known</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="content_type" transfer-ownership="none">
            <doc xml:space="preserve">the MIME type of the file, or %NULL if not known</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="body" transfer-ownership="none">
            <doc xml:space="preserve">the file data</doc>
            <type name="Buffer" c:type="SoupBuffer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="append_form_string"
              c:identifier="soup_multipart_append_form_string"
              version="2.26">
        <doc xml:space="preserve">Adds a new MIME part containing @data to @multipart, using
"Content-Disposition: form-data", as per the HTML forms
specification. See soup_form_request_new_from_multipart() for more
details.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="multipart" transfer-ownership="none">
            <doc xml:space="preserve">a multipart (presumably of type "multipart/form-data")</doc>
            <type name="Multipart" c:type="SoupMultipart*"/>
          </instance-parameter>
          <parameter name="control_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the control associated with @data</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">the body data</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="append_part"
              c:identifier="soup_multipart_append_part"
              version="2.26">
        <doc xml:space="preserve">Adds a new MIME part to @multipart with the given headers and body.
(The multipart will make its own copies of @headers and @body, so
you should free your copies if you are not using them for anything
else.)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="multipart" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMultipart</doc>
            <type name="Multipart" c:type="SoupMultipart*"/>
          </instance-parameter>
          <parameter name="headers" transfer-ownership="none">
            <doc xml:space="preserve">the MIME part headers</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </parameter>
          <parameter name="body" transfer-ownership="none">
            <doc xml:space="preserve">the MIME part body</doc>
            <type name="Buffer" c:type="SoupBuffer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="soup_multipart_free" version="2.26">
        <doc xml:space="preserve">Frees @multipart</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="multipart" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMultipart</doc>
            <type name="Multipart" c:type="SoupMultipart*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_length"
              c:identifier="soup_multipart_get_length"
              version="2.26">
        <doc xml:space="preserve">Gets the number of body parts in @multipart</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of body parts in @multipart</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="multipart" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMultipart</doc>
            <type name="Multipart" c:type="SoupMultipart*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_part"
              c:identifier="soup_multipart_get_part"
              version="2.26">
        <doc xml:space="preserve">Gets the indicated body part from @multipart.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE if @part is out of range (in
which case @headers and @body won't be set)</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="multipart" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMultipart</doc>
            <type name="Multipart" c:type="SoupMultipart*"/>
          </instance-parameter>
          <parameter name="part" transfer-ownership="none">
            <doc xml:space="preserve">the part number to get (counting from 0)</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="headers"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:space="preserve">return location for the MIME part
headers</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders**"/>
          </parameter>
          <parameter name="body"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:space="preserve">return location for the MIME part
body</doc>
            <type name="Buffer" c:type="SoupBuffer**"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_message"
              c:identifier="soup_multipart_to_message"
              version="2.26">
        <doc xml:space="preserve">Serializes @multipart to @dest_headers and @dest_body.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="multipart" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMultipart</doc>
            <type name="Multipart" c:type="SoupMultipart*"/>
          </instance-parameter>
          <parameter name="dest_headers" transfer-ownership="none">
            <doc xml:space="preserve">the headers of the HTTP message to serialize @multipart to</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </parameter>
          <parameter name="dest_body" transfer-ownership="none">
            <doc xml:space="preserve">the body of the HTTP message to serialize @multipart to</doc>
            <type name="MessageBody" c:type="SoupMessageBody*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <class name="MultipartInputStream"
           c:symbol-prefix="multipart_input_stream"
           c:type="SoupMultipartInputStream"
           parent="Gio.FilterInputStream"
           glib:type-name="SoupMultipartInputStream"
           glib:get-type="soup_multipart_input_stream_get_type"
           glib:type-struct="MultipartInputStreamClass">
      <implements name="Gio.PollableInputStream"/>
      <constructor name="new"
                   c:identifier="soup_multipart_input_stream_new"
                   version="2.40">
        <doc xml:space="preserve">Creates a new #SoupMultipartInputStream that wraps the
#GInputStream obtained by sending the #SoupRequest. Reads should
not be done directly through this object, use the input streams
returned by soup_multipart_input_stream_next_part() or its async
counterpart instead.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #SoupMultipartInputStream</doc>
          <type name="MultipartInputStream"
                c:type="SoupMultipartInputStream*"/>
        </return-value>
        <parameters>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">the #SoupMessage the response is related to.</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
          <parameter name="base_stream" transfer-ownership="none">
            <doc xml:space="preserve">the #GInputStream returned by sending the request.</doc>
            <type name="Gio.InputStream" c:type="GInputStream*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_headers"
              c:identifier="soup_multipart_input_stream_get_headers"
              version="2.40">
        <doc xml:space="preserve">Obtains the headers for the part currently being processed. Note
that the #SoupMessageHeaders that are returned are owned by the
#SoupMultipartInputStream and will be replaced when a call is made
to soup_multipart_input_stream_next_part() or its async
counterpart, so if keeping the headers is required, a copy must be
made.

Note that if a part had no headers at all an empty #SoupMessageHeaders
will be returned.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">a #SoupMessageHeaders
containing the headers for the part currently being processed or
%NULL if the headers failed to parse.</doc>
          <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
        </return-value>
        <parameters>
          <instance-parameter name="multipart" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMultipartInputStream.</doc>
            <type name="MultipartInputStream"
                  c:type="SoupMultipartInputStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="next_part"
              c:identifier="soup_multipart_input_stream_next_part"
              version="2.40"
              throws="1">
        <doc xml:space="preserve">Obtains an input stream for the next part. When dealing with a
multipart response the input stream needs to be wrapped in a
#SoupMultipartInputStream and this function or its async
counterpart need to be called to obtain the first part for
reading.

After calling this function,
soup_multipart_input_stream_get_headers() can be used to obtain the
headers for the first part. A read of 0 bytes indicates the end of
the part; a new call to this function should be done at that point,
to obtain the next part.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a new #GInputStream, or
%NULL if there are no more parts</doc>
          <type name="Gio.InputStream" c:type="GInputStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="multipart" transfer-ownership="none">
            <doc xml:space="preserve">the #SoupMultipartInputStream</doc>
            <type name="MultipartInputStream"
                  c:type="SoupMultipartInputStream*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="next_part_async"
              c:identifier="soup_multipart_input_stream_next_part_async"
              version="2.40">
        <doc xml:space="preserve">Obtains a #GInputStream for the next request. See
soup_multipart_input_stream_next_part() for details on the
workflow.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="multipart" transfer-ownership="none">
            <doc xml:space="preserve">the #SoupMultipartInputStream.</doc>
            <type name="MultipartInputStream"
                  c:type="SoupMultipartInputStream*"/>
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the I/O priority for the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">callback to call when request is satisfied.</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">data for @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="next_part_finish"
              c:identifier="soup_multipart_input_stream_next_part_finish"
              version="2.40"
              throws="1">
        <doc xml:space="preserve">Finishes an asynchronous request for the next part.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a newly created
#GInputStream for reading the next part or %NULL if there are no
more parts.</doc>
          <type name="Gio.InputStream" c:type="GInputStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="multipart" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMultipartInputStream.</doc>
            <type name="MultipartInputStream"
                  c:type="SoupMultipartInputStream*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <property name="message"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="Message"/>
      </property>
      <field name="parent_instance">
        <type name="Gio.FilterInputStream" c:type="GFilterInputStream"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="MultipartInputStreamPrivate"
              c:type="SoupMultipartInputStreamPrivate*"/>
      </field>
    </class>
    <record name="MultipartInputStreamClass"
            c:type="SoupMultipartInputStreamClass"
            glib:is-gtype-struct-for="MultipartInputStream">
      <field name="parent_class">
        <type name="Gio.FilterInputStreamClass"
              c:type="GFilterInputStreamClass"/>
      </field>
    </record>
    <record name="MultipartInputStreamPrivate"
            c:type="SoupMultipartInputStreamPrivate"
            disguised="1">
    </record>
    <constant name="PASSWORD_MANAGER_H"
              value="1"
              c:type="SOUP_PASSWORD_MANAGER_H">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="PROXY_RESOLVER_DEFAULT_H"
              value="1"
              c:type="SOUP_PROXY_RESOLVER_DEFAULT_H">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="PROXY_URI_RESOLVER_H"
              value="1"
              c:type="SOUP_PROXY_URI_RESOLVER_H">
      <type name="gint" c:type="gint"/>
    </constant>
    <interface name="PasswordManager"
               c:symbol-prefix="password_manager"
               c:type="SoupPasswordManager"
               glib:type-name="SoupPasswordManager"
               glib:get-type="soup_password_manager_get_type"
               glib:type-struct="PasswordManagerInterface">
      <prerequisite name="SessionFeature"/>
      <virtual-method name="get_passwords_async" invoker="get_passwords_async">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="password_manager"
                              transfer-ownership="none">
            <type name="PasswordManager" c:type="SoupPasswordManager*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
          <parameter name="auth" transfer-ownership="none">
            <type name="Auth" c:type="SoupAuth*"/>
          </parameter>
          <parameter name="retrying" transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="async_context" transfer-ownership="none">
            <type name="GLib.MainContext" c:type="GMainContext*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="6">
            <type name="PasswordManagerCallback"
                  c:type="SoupPasswordManagerCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="6">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_passwords_sync" invoker="get_passwords_sync">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="password_manager"
                              transfer-ownership="none">
            <type name="PasswordManager" c:type="SoupPasswordManager*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
          <parameter name="auth" transfer-ownership="none">
            <type name="Auth" c:type="SoupAuth*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_passwords_async"
              c:identifier="soup_password_manager_get_passwords_async">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="password_manager"
                              transfer-ownership="none">
            <type name="PasswordManager" c:type="SoupPasswordManager*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
          <parameter name="auth" transfer-ownership="none">
            <type name="Auth" c:type="SoupAuth*"/>
          </parameter>
          <parameter name="retrying" transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="async_context" transfer-ownership="none">
            <type name="GLib.MainContext" c:type="GMainContext*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="6">
            <type name="PasswordManagerCallback"
                  c:type="SoupPasswordManagerCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_passwords_sync"
              c:identifier="soup_password_manager_get_passwords_sync">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="password_manager"
                              transfer-ownership="none">
            <type name="PasswordManager" c:type="SoupPasswordManager*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
          <parameter name="auth" transfer-ownership="none">
            <type name="Auth" c:type="SoupAuth*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
    </interface>
    <callback name="PasswordManagerCallback"
              c:type="SoupPasswordManagerCallback">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="password_manager" transfer-ownership="none">
          <type name="PasswordManager" c:type="SoupPasswordManager*"/>
        </parameter>
        <parameter name="msg" transfer-ownership="none">
          <type name="Message" c:type="SoupMessage*"/>
        </parameter>
        <parameter name="auth" transfer-ownership="none">
          <type name="Auth" c:type="SoupAuth*"/>
        </parameter>
        <parameter name="retrying" transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="4">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="PasswordManagerInterface"
            c:type="SoupPasswordManagerInterface"
            glib:is-gtype-struct-for="PasswordManager">
      <field name="base">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="get_passwords_async">
        <callback name="get_passwords_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="password_manager" transfer-ownership="none">
              <type name="PasswordManager" c:type="SoupPasswordManager*"/>
            </parameter>
            <parameter name="msg" transfer-ownership="none">
              <type name="Message" c:type="SoupMessage*"/>
            </parameter>
            <parameter name="auth" transfer-ownership="none">
              <type name="Auth" c:type="SoupAuth*"/>
            </parameter>
            <parameter name="retrying" transfer-ownership="none">
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
            <parameter name="async_context" transfer-ownership="none">
              <type name="GLib.MainContext" c:type="GMainContext*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="7">
              <type name="PasswordManagerCallback"
                    c:type="SoupPasswordManagerCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="7">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_passwords_sync">
        <callback name="get_passwords_sync">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="password_manager" transfer-ownership="none">
              <type name="PasswordManager" c:type="SoupPasswordManager*"/>
            </parameter>
            <parameter name="msg" transfer-ownership="none">
              <type name="Message" c:type="SoupMessage*"/>
            </parameter>
            <parameter name="auth" transfer-ownership="none">
              <type name="Auth" c:type="SoupAuth*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <class name="ProxyResolverDefault"
           c:symbol-prefix="proxy_resolver_default"
           c:type="SoupProxyResolverDefault"
           parent="GObject.Object"
           glib:type-name="SoupProxyResolverDefault"
           glib:get-type="soup_proxy_resolver_default_get_type"
           glib:type-struct="ProxyResolverDefaultClass">
      <implements name="ProxyURIResolver"/>
      <implements name="SessionFeature"/>
      <property name="gproxy-resolver"
                readable="0"
                writable="1"
                transfer-ownership="none">
        <type name="Gio.ProxyResolver"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <record name="ProxyResolverDefaultClass"
            c:type="SoupProxyResolverDefaultClass"
            glib:is-gtype-struct-for="ProxyResolverDefault">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <interface name="ProxyURIResolver"
               c:symbol-prefix="proxy_uri_resolver"
               c:type="SoupProxyURIResolver"
               glib:type-name="SoupProxyURIResolver"
               glib:get-type="soup_proxy_uri_resolver_get_type"
               glib:type-struct="ProxyURIResolverInterface">
      <prerequisite name="SessionFeature"/>
      <virtual-method name="get_proxy_uri_async"
                      invoker="get_proxy_uri_async"
                      version="2.26.3"
                      deprecated="1">
        <doc xml:space="preserve">Asynchronously determines a proxy URI to use for @msg and calls
@callback.</doc>
        <doc-deprecated xml:space="preserve">#SoupProxyURIResolver is deprecated in favor of
#GProxyResolver</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="proxy_uri_resolver"
                              transfer-ownership="none">
            <doc xml:space="preserve">the #SoupProxyURIResolver</doc>
            <type name="ProxyURIResolver" c:type="SoupProxyURIResolver*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">the #SoupURI you want a proxy for</doc>
            <type name="URI" c:type="SoupURI*"/>
          </parameter>
          <parameter name="async_context"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the #GMainContext to invoke @callback in</doc>
            <type name="GLib.MainContext" c:type="GMainContext*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve">callback to invoke with the proxy address</doc>
            <type name="ProxyURIResolverCallback"
                  c:type="SoupProxyURIResolverCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="4">
            <doc xml:space="preserve">data for @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_proxy_uri_sync"
                      invoker="get_proxy_uri_sync"
                      version="2.26.3"
                      deprecated="1">
        <doc xml:space="preserve">Synchronously determines a proxy URI to use for @uri. If @uri
should be sent via proxy, *@proxy_uri will be set to the URI of the
proxy, else it will be set to %NULL.</doc>
        <doc-deprecated xml:space="preserve">#SoupProxyURIResolver is deprecated in favor of
#GProxyResolver</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%SOUP_STATUS_OK if successful, or a transport-level
error.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="proxy_uri_resolver"
                              transfer-ownership="none">
            <doc xml:space="preserve">the #SoupProxyURIResolver</doc>
            <type name="ProxyURIResolver" c:type="SoupProxyURIResolver*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">the #SoupURI you want a proxy for</doc>
            <type name="URI" c:type="SoupURI*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="proxy_uri"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">on return, will contain the proxy URI</doc>
            <type name="URI" c:type="SoupURI**"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_proxy_uri_async"
              c:identifier="soup_proxy_uri_resolver_get_proxy_uri_async"
              version="2.26.3"
              deprecated="1">
        <doc xml:space="preserve">Asynchronously determines a proxy URI to use for @msg and calls
@callback.</doc>
        <doc-deprecated xml:space="preserve">#SoupProxyURIResolver is deprecated in favor of
#GProxyResolver</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="proxy_uri_resolver"
                              transfer-ownership="none">
            <doc xml:space="preserve">the #SoupProxyURIResolver</doc>
            <type name="ProxyURIResolver" c:type="SoupProxyURIResolver*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">the #SoupURI you want a proxy for</doc>
            <type name="URI" c:type="SoupURI*"/>
          </parameter>
          <parameter name="async_context"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the #GMainContext to invoke @callback in</doc>
            <type name="GLib.MainContext" c:type="GMainContext*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve">callback to invoke with the proxy address</doc>
            <type name="ProxyURIResolverCallback"
                  c:type="SoupProxyURIResolverCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">data for @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_proxy_uri_sync"
              c:identifier="soup_proxy_uri_resolver_get_proxy_uri_sync"
              version="2.26.3"
              deprecated="1">
        <doc xml:space="preserve">Synchronously determines a proxy URI to use for @uri. If @uri
should be sent via proxy, *@proxy_uri will be set to the URI of the
proxy, else it will be set to %NULL.</doc>
        <doc-deprecated xml:space="preserve">#SoupProxyURIResolver is deprecated in favor of
#GProxyResolver</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%SOUP_STATUS_OK if successful, or a transport-level
error.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="proxy_uri_resolver"
                              transfer-ownership="none">
            <doc xml:space="preserve">the #SoupProxyURIResolver</doc>
            <type name="ProxyURIResolver" c:type="SoupProxyURIResolver*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">the #SoupURI you want a proxy for</doc>
            <type name="URI" c:type="SoupURI*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="proxy_uri"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">on return, will contain the proxy URI</doc>
            <type name="URI" c:type="SoupURI**"/>
          </parameter>
        </parameters>
      </method>
    </interface>
    <callback name="ProxyURIResolverCallback"
              c:type="SoupProxyURIResolverCallback">
      <doc xml:space="preserve">Callback for soup_proxy_uri_resolver_get_proxy_uri_async()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="resolver" transfer-ownership="none">
          <doc xml:space="preserve">the #SoupProxyURIResolver</doc>
          <type name="ProxyURIResolver" c:type="SoupProxyURIResolver*"/>
        </parameter>
        <parameter name="status" transfer-ownership="none">
          <doc xml:space="preserve">a #SoupStatus</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="proxy_uri" transfer-ownership="none">
          <doc xml:space="preserve">the resolved proxy URI, or %NULL</doc>
          <type name="URI" c:type="SoupURI*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="3">
          <doc xml:space="preserve">data passed to soup_proxy_uri_resolver_get_proxy_uri_async()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="ProxyURIResolverInterface"
            c:type="SoupProxyURIResolverInterface"
            glib:is-gtype-struct-for="ProxyURIResolver">
      <field name="base">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="get_proxy_uri_async">
        <callback name="get_proxy_uri_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="proxy_uri_resolver" transfer-ownership="none">
              <doc xml:space="preserve">the #SoupProxyURIResolver</doc>
              <type name="ProxyURIResolver" c:type="SoupProxyURIResolver*"/>
            </parameter>
            <parameter name="uri" transfer-ownership="none">
              <doc xml:space="preserve">the #SoupURI you want a proxy for</doc>
              <type name="URI" c:type="SoupURI*"/>
            </parameter>
            <parameter name="async_context"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">the #GMainContext to invoke @callback in</doc>
              <type name="GLib.MainContext" c:type="GMainContext*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="5">
              <doc xml:space="preserve">callback to invoke with the proxy address</doc>
              <type name="ProxyURIResolverCallback"
                    c:type="SoupProxyURIResolverCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="5">
              <doc xml:space="preserve">data for @callback</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_proxy_uri_sync">
        <callback name="get_proxy_uri_sync">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%SOUP_STATUS_OK if successful, or a transport-level
error.</doc>
            <type name="guint" c:type="guint"/>
          </return-value>
          <parameters>
            <parameter name="proxy_uri_resolver" transfer-ownership="none">
              <doc xml:space="preserve">the #SoupProxyURIResolver</doc>
              <type name="ProxyURIResolver" c:type="SoupProxyURIResolver*"/>
            </parameter>
            <parameter name="uri" transfer-ownership="none">
              <doc xml:space="preserve">the #SoupURI you want a proxy for</doc>
              <type name="URI" c:type="SoupURI*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="proxy_uri"
                       direction="out"
                       caller-allocates="0"
                       transfer-ownership="full">
              <doc xml:space="preserve">on return, will contain the proxy URI</doc>
              <type name="URI" c:type="SoupURI**"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_libsoup_reserved1" introspectable="0">
        <callback name="_libsoup_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_libsoup_reserved2" introspectable="0">
        <callback name="_libsoup_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_libsoup_reserved3" introspectable="0">
        <callback name="_libsoup_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_libsoup_reserved4" introspectable="0">
        <callback name="_libsoup_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <constant name="REQUESTER_H" value="1" c:type="SOUP_REQUESTER_H">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="REQUEST_DATA_H" value="1" c:type="SOUP_REQUEST_DATA_H">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="REQUEST_FILE_H" value="1" c:type="SOUP_REQUEST_FILE_H">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="REQUEST_H" value="1" c:type="SOUP_REQUEST_H">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="REQUEST_HTTP_H" value="1" c:type="SOUP_REQUEST_HTTP_H">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="REQUEST_SESSION"
              value="session"
              c:type="SOUP_REQUEST_SESSION"
              version="2.42">
      <doc xml:space="preserve">Alias for the #SoupRequest:session property, qv.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="REQUEST_URI"
              value="uri"
              c:type="SOUP_REQUEST_URI"
              version="2.42">
      <doc xml:space="preserve">Alias for the #SoupRequest:uri property, qv.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <record name="Range" c:type="SoupRange" version="2.26">
      <doc xml:space="preserve">Represents a byte range as used in the Range header.

If @end is non-negative, then @start and @end represent the bounds
of of the range, counting from 0. (Eg, the first 500 bytes would be
represented as @start = 0 and @end = 499.)

If @end is -1 and @start is non-negative, then this represents a
range starting at @start and ending with the last byte of the
requested resource body. (Eg, all but the first 500 bytes would be
@start = 500, and @end = -1.)

If @end is -1 and @start is negative, then it represents a "suffix
range", referring to the last -@start bytes of the resource body.
(Eg, the last 500 bytes would be @start = -500 and @end = -1.)</doc>
      <field name="start" writable="1">
        <doc xml:space="preserve">the start of the range</doc>
        <type name="gint64" c:type="goffset"/>
      </field>
      <field name="end" writable="1">
        <doc xml:space="preserve">the end of the range</doc>
        <type name="gint64" c:type="goffset"/>
      </field>
    </record>
    <class name="Request"
           c:symbol-prefix="request"
           c:type="SoupRequest"
           version="2.42"
           parent="GObject.Object"
           glib:type-name="SoupRequest"
           glib:get-type="soup_request_get_type"
           glib:type-struct="RequestClass">
      <doc xml:space="preserve">A request to retrieve a particular URI.</doc>
      <implements name="Gio.Initable"/>
      <virtual-method name="check_uri" throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="req_base" transfer-ownership="none">
            <type name="Request" c:type="SoupRequest*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <type name="URI" c:type="SoupURI*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_content_length"
                      invoker="get_content_length"
                      version="2.42">
        <doc xml:space="preserve">Gets the length of the data represented by @request. For most
request types, this will not be known until after you call
soup_request_send() or soup_request_send_finish().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the length of the data represented by @request,
  or -1 if not known.</doc>
          <type name="gint64" c:type="goffset"/>
        </return-value>
        <parameters>
          <instance-parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupRequest</doc>
            <type name="Request" c:type="SoupRequest*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_content_type"
                      invoker="get_content_type"
                      version="2.42">
        <doc xml:space="preserve">Gets the type of the data represented by @request. For most request
types, this will not be known until after you call
soup_request_send() or soup_request_send_finish().

As in the HTTP Content-Type header, this may include parameters
after the MIME type.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the type of the data represented by
  @request, or %NULL if not known.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupRequest</doc>
            <type name="Request" c:type="SoupRequest*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="send" invoker="send" version="2.42" throws="1">
        <doc xml:space="preserve">Synchronously requests the URI pointed to by @request, and returns
a #GInputStream that can be used to read its contents.

Note that you cannot use this method with #SoupRequests attached to
a #SoupSessionAsync.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GInputStream that can be used to
  read from the URI pointed to by @request.</doc>
          <type name="Gio.InputStream" c:type="GInputStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupRequest</doc>
            <type name="Request" c:type="SoupRequest*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="send_async" invoker="send_async" version="2.42">
        <doc xml:space="preserve">Begins an asynchronously request for the URI pointed to by
@request.

Note that you cannot use this method with #SoupRequests attached to
a #SoupSessionSync.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupRequest</doc>
            <type name="Request" c:type="SoupRequest*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">a #GAsyncReadyCallback</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="2">
            <doc xml:space="preserve">user data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="send_finish"
                      invoker="send_finish"
                      version="2.42"
                      throws="1">
        <doc xml:space="preserve">Gets the result of a soup_request_send_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GInputStream that can be used to
  read from the URI pointed to by @request.</doc>
          <type name="Gio.InputStream" c:type="GInputStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupRequest</doc>
            <type name="Request" c:type="SoupRequest*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_content_length"
              c:identifier="soup_request_get_content_length"
              version="2.42">
        <doc xml:space="preserve">Gets the length of the data represented by @request. For most
request types, this will not be known until after you call
soup_request_send() or soup_request_send_finish().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the length of the data represented by @request,
  or -1 if not known.</doc>
          <type name="gint64" c:type="goffset"/>
        </return-value>
        <parameters>
          <instance-parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupRequest</doc>
            <type name="Request" c:type="SoupRequest*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_content_type"
              c:identifier="soup_request_get_content_type"
              version="2.42">
        <doc xml:space="preserve">Gets the type of the data represented by @request. For most request
types, this will not be known until after you call
soup_request_send() or soup_request_send_finish().

As in the HTTP Content-Type header, this may include parameters
after the MIME type.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the type of the data represented by
  @request, or %NULL if not known.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupRequest</doc>
            <type name="Request" c:type="SoupRequest*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_session"
              c:identifier="soup_request_get_session"
              version="2.42">
        <doc xml:space="preserve">Gets @request's #SoupSession</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@request's #SoupSession</doc>
          <type name="Session" c:type="SoupSession*"/>
        </return-value>
        <parameters>
          <instance-parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupRequest</doc>
            <type name="Request" c:type="SoupRequest*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_uri"
              c:identifier="soup_request_get_uri"
              version="2.42">
        <doc xml:space="preserve">Gets @request's URI</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@request's URI</doc>
          <type name="URI" c:type="SoupURI*"/>
        </return-value>
        <parameters>
          <instance-parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupRequest</doc>
            <type name="Request" c:type="SoupRequest*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="send"
              c:identifier="soup_request_send"
              version="2.42"
              throws="1">
        <doc xml:space="preserve">Synchronously requests the URI pointed to by @request, and returns
a #GInputStream that can be used to read its contents.

Note that you cannot use this method with #SoupRequests attached to
a #SoupSessionAsync.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GInputStream that can be used to
  read from the URI pointed to by @request.</doc>
          <type name="Gio.InputStream" c:type="GInputStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupRequest</doc>
            <type name="Request" c:type="SoupRequest*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_async"
              c:identifier="soup_request_send_async"
              version="2.42">
        <doc xml:space="preserve">Begins an asynchronously request for the URI pointed to by
@request.

Note that you cannot use this method with #SoupRequests attached to
a #SoupSessionSync.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupRequest</doc>
            <type name="Request" c:type="SoupRequest*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">a #GAsyncReadyCallback</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">user data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_finish"
              c:identifier="soup_request_send_finish"
              version="2.42"
              throws="1">
        <doc xml:space="preserve">Gets the result of a soup_request_send_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GInputStream that can be used to
  read from the URI pointed to by @request.</doc>
          <type name="Gio.InputStream" c:type="GInputStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupRequest</doc>
            <type name="Request" c:type="SoupRequest*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <property name="session"
                version="2.42"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The request's #SoupSession.</doc>
        <type name="Session"/>
      </property>
      <property name="uri"
                version="2.42"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The request URI.</doc>
        <type name="URI"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="RequestPrivate" c:type="SoupRequestPrivate*"/>
      </field>
    </class>
    <record name="RequestClass"
            c:type="SoupRequestClass"
            glib:is-gtype-struct-for="Request">
      <field name="parent">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="schemes">
        <type name="utf8" c:type="const char**"/>
      </field>
      <field name="check_uri">
        <callback name="check_uri" throws="1">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="req_base" transfer-ownership="none">
              <type name="Request" c:type="SoupRequest*"/>
            </parameter>
            <parameter name="uri" transfer-ownership="none">
              <type name="URI" c:type="SoupURI*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="send">
        <callback name="send" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #GInputStream that can be used to
  read from the URI pointed to by @request.</doc>
            <type name="Gio.InputStream" c:type="GInputStream*"/>
          </return-value>
          <parameters>
            <parameter name="request" transfer-ownership="none">
              <doc xml:space="preserve">a #SoupRequest</doc>
              <type name="Request" c:type="SoupRequest*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">a #GCancellable or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="send_async">
        <callback name="send_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="request" transfer-ownership="none">
              <doc xml:space="preserve">a #SoupRequest</doc>
              <type name="Request" c:type="SoupRequest*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">a #GCancellable or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1"
                       scope="async"
                       closure="3">
              <doc xml:space="preserve">a #GAsyncReadyCallback</doc>
              <type name="Gio.AsyncReadyCallback"
                    c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="3">
              <doc xml:space="preserve">user data passed to @callback</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="send_finish">
        <callback name="send_finish" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #GInputStream that can be used to
  read from the URI pointed to by @request.</doc>
            <type name="Gio.InputStream" c:type="GInputStream*"/>
          </return-value>
          <parameters>
            <parameter name="request" transfer-ownership="none">
              <doc xml:space="preserve">a #SoupRequest</doc>
              <type name="Request" c:type="SoupRequest*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">the #GAsyncResult</doc>
              <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_content_length">
        <callback name="get_content_length">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the length of the data represented by @request,
  or -1 if not known.</doc>
            <type name="gint64" c:type="goffset"/>
          </return-value>
          <parameters>
            <parameter name="request" transfer-ownership="none">
              <doc xml:space="preserve">a #SoupRequest</doc>
              <type name="Request" c:type="SoupRequest*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_content_type">
        <callback name="get_content_type">
          <return-value transfer-ownership="none" nullable="1">
            <doc xml:space="preserve">the type of the data represented by
  @request, or %NULL if not known.</doc>
            <type name="utf8" c:type="const char*"/>
          </return-value>
          <parameters>
            <parameter name="request" transfer-ownership="none">
              <doc xml:space="preserve">a #SoupRequest</doc>
              <type name="Request" c:type="SoupRequest*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <class name="RequestData"
           c:symbol-prefix="request_data"
           c:type="SoupRequestData"
           parent="Request"
           glib:type-name="SoupRequestData"
           glib:get-type="soup_request_data_get_type"
           glib:type-struct="RequestDataClass">
      <implements name="Gio.Initable"/>
      <field name="parent">
        <type name="Request" c:type="SoupRequest"/>
      </field>
      <field name="priv">
        <type name="RequestDataPrivate" c:type="SoupRequestDataPrivate*"/>
      </field>
    </class>
    <record name="RequestDataClass"
            c:type="SoupRequestDataClass"
            glib:is-gtype-struct-for="RequestData">
      <field name="parent">
        <type name="RequestClass" c:type="SoupRequestClass"/>
      </field>
    </record>
    <record name="RequestDataPrivate"
            c:type="SoupRequestDataPrivate"
            disguised="1">
    </record>
    <enumeration name="RequestError"
                 version="2.42"
                 glib:type-name="SoupRequestError"
                 glib:get-type="soup_request_error_get_type"
                 c:type="SoupRequestError"
                 glib:error-domain="soup_request_error_quark">
      <doc xml:space="preserve">A #SoupRequest error.</doc>
      <member name="bad_uri"
              value="0"
              c:identifier="SOUP_REQUEST_ERROR_BAD_URI"
              glib:nick="bad-uri">
        <doc xml:space="preserve">the URI could not be parsed</doc>
      </member>
      <member name="unsupported_uri_scheme"
              value="1"
              c:identifier="SOUP_REQUEST_ERROR_UNSUPPORTED_URI_SCHEME"
              glib:nick="unsupported-uri-scheme">
        <doc xml:space="preserve">the URI scheme is not
  supported by this #SoupSession</doc>
      </member>
      <member name="parsing"
              value="2"
              c:identifier="SOUP_REQUEST_ERROR_PARSING"
              glib:nick="parsing">
        <doc xml:space="preserve">the server's response could not
  be parsed</doc>
      </member>
      <member name="encoding"
              value="3"
              c:identifier="SOUP_REQUEST_ERROR_ENCODING"
              glib:nick="encoding">
        <doc xml:space="preserve">the server's response was in an
  unsupported format</doc>
      </member>
      <function name="quark" c:identifier="soup_request_error_quark">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="RequestFile"
           c:symbol-prefix="request_file"
           c:type="SoupRequestFile"
           parent="Request"
           glib:type-name="SoupRequestFile"
           glib:get-type="soup_request_file_get_type"
           glib:type-struct="RequestFileClass">
      <implements name="Gio.Initable"/>
      <method name="get_file"
              c:identifier="soup_request_file_get_file"
              version="2.40">
        <doc xml:space="preserve">Gets a #GFile corresponding to @file's URI</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GFile corresponding to @file</doc>
          <type name="Gio.File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupRequestFile</doc>
            <type name="RequestFile" c:type="SoupRequestFile*"/>
          </instance-parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="Request" c:type="SoupRequest"/>
      </field>
      <field name="priv">
        <type name="RequestFilePrivate" c:type="SoupRequestFilePrivate*"/>
      </field>
    </class>
    <record name="RequestFileClass"
            c:type="SoupRequestFileClass"
            glib:is-gtype-struct-for="RequestFile">
      <field name="parent">
        <type name="RequestClass" c:type="SoupRequestClass"/>
      </field>
    </record>
    <record name="RequestFilePrivate"
            c:type="SoupRequestFilePrivate"
            disguised="1">
    </record>
    <class name="RequestHTTP"
           c:symbol-prefix="request_http"
           c:type="SoupRequestHTTP"
           parent="Request"
           glib:type-name="SoupRequestHTTP"
           glib:get-type="soup_request_http_get_type"
           glib:type-struct="RequestHTTPClass">
      <implements name="Gio.Initable"/>
      <method name="get_message"
              c:identifier="soup_request_http_get_message"
              version="2.40">
        <doc xml:space="preserve">Gets a new reference to the #SoupMessage associated to this SoupRequest</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new reference to the #SoupMessage</doc>
          <type name="Message" c:type="SoupMessage*"/>
        </return-value>
        <parameters>
          <instance-parameter name="http" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupRequestHTTP object</doc>
            <type name="RequestHTTP" c:type="SoupRequestHTTP*"/>
          </instance-parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="Request" c:type="SoupRequest"/>
      </field>
      <field name="priv">
        <type name="RequestHTTPPrivate" c:type="SoupRequestHTTPPrivate*"/>
      </field>
    </class>
    <record name="RequestHTTPClass"
            c:type="SoupRequestHTTPClass"
            glib:is-gtype-struct-for="RequestHTTP">
      <field name="parent">
        <type name="RequestClass" c:type="SoupRequestClass"/>
      </field>
    </record>
    <record name="RequestHTTPPrivate"
            c:type="SoupRequestHTTPPrivate"
            disguised="1">
    </record>
    <record name="RequestPrivate" c:type="SoupRequestPrivate" disguised="1">
    </record>
    <class name="Requester"
           c:symbol-prefix="requester"
           c:type="SoupRequester"
           parent="GObject.Object"
           glib:type-name="SoupRequester"
           glib:get-type="soup_requester_get_type"
           glib:type-struct="RequesterClass">
      <implements name="SessionFeature"/>
      <constructor name="new" c:identifier="soup_requester_new">
        <return-value transfer-ownership="full">
          <type name="Requester" c:type="SoupRequester*"/>
        </return-value>
      </constructor>
      <method name="request" c:identifier="soup_requester_request" throws="1">
        <return-value transfer-ownership="full">
          <type name="Request" c:type="SoupRequest*"/>
        </return-value>
        <parameters>
          <instance-parameter name="requester" transfer-ownership="none">
            <type name="Requester" c:type="SoupRequester*"/>
          </instance-parameter>
          <parameter name="uri_string" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_uri"
              c:identifier="soup_requester_request_uri"
              throws="1">
        <return-value transfer-ownership="full">
          <type name="Request" c:type="SoupRequest*"/>
        </return-value>
        <parameters>
          <instance-parameter name="requester" transfer-ownership="none">
            <type name="Requester" c:type="SoupRequester*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <type name="URI" c:type="SoupURI*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="RequesterPrivate" c:type="SoupRequesterPrivate*"/>
      </field>
    </class>
    <record name="RequesterClass"
            c:type="SoupRequesterClass"
            glib:is-gtype-struct-for="Requester">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <enumeration name="RequesterError"
                 glib:type-name="SoupRequesterError"
                 glib:get-type="soup_requester_error_get_type"
                 c:type="SoupRequesterError"
                 glib:error-domain="soup_requester_error_quark">
      <member name="bad_uri"
              value="0"
              c:identifier="SOUP_REQUESTER_ERROR_BAD_URI"
              glib:nick="bad-uri">
      </member>
      <member name="unsupported_uri_scheme"
              value="1"
              c:identifier="SOUP_REQUESTER_ERROR_UNSUPPORTED_URI_SCHEME"
              glib:nick="unsupported-uri-scheme">
      </member>
      <function name="quark" c:identifier="soup_requester_error_quark">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <record name="RequesterPrivate"
            c:type="SoupRequesterPrivate"
            disguised="1">
    </record>
    <constant name="SERVER_ASYNC_CONTEXT"
              value="async-context"
              c:type="SOUP_SERVER_ASYNC_CONTEXT"
              deprecated="1">
      <doc xml:space="preserve">Alias for the deprecated #SoupServer:async-context
property, qv.</doc>
      <doc-deprecated xml:space="preserve">The new API uses the thread-default #GMainContext
rather than having an explicitly-specified one.</doc-deprecated>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SERVER_H" value="1" c:type="SOUP_SERVER_H">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="SERVER_HTTPS_ALIASES"
              value="https-aliases"
              c:type="SOUP_SERVER_HTTPS_ALIASES"
              version="2.44">
      <doc xml:space="preserve">Alias for the #SoupServer:https-aliases property, qv.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SERVER_HTTP_ALIASES"
              value="http-aliases"
              c:type="SOUP_SERVER_HTTP_ALIASES"
              version="2.44">
      <doc xml:space="preserve">Alias for the #SoupServer:http-aliases property, qv.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SERVER_INTERFACE"
              value="interface"
              c:type="SOUP_SERVER_INTERFACE"
              deprecated="1">
      <doc xml:space="preserve">Alias for the #SoupServer:interface property, qv.</doc>
      <doc-deprecated xml:space="preserve">#SoupServers can listen on multiple interfaces
at once now. Use soup_server_listen(), etc, to listen on an
interface, and soup_server_get_uris() to see what addresses
are being listened on.</doc-deprecated>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SERVER_PORT"
              value="port"
              c:type="SOUP_SERVER_PORT"
              deprecated="1">
      <doc xml:space="preserve">Alias for the deprecated #SoupServer:port property, qv.</doc>
      <doc-deprecated xml:space="preserve">#SoupServers can listen on multiple interfaces
at once now. Use soup_server_listen(), etc, to listen on a
port, and soup_server_get_uris() to see what ports are
being listened on.</doc-deprecated>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SERVER_RAW_PATHS"
              value="raw-paths"
              c:type="SOUP_SERVER_RAW_PATHS">
      <doc xml:space="preserve">Alias for the #SoupServer:raw-paths property. (If %TRUE,
percent-encoding in the Request-URI path will not be
automatically decoded.)</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SERVER_SERVER_HEADER"
              value="server-header"
              c:type="SOUP_SERVER_SERVER_HEADER">
      <doc xml:space="preserve">Alias for the #SoupServer:server-header property, qv.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SERVER_SSL_CERT_FILE"
              value="ssl-cert-file"
              c:type="SOUP_SERVER_SSL_CERT_FILE"
              deprecated="1">
      <doc xml:space="preserve">Alias for the #SoupServer:ssl-cert-file property, qv.</doc>
      <doc-deprecated xml:space="preserve">use #SoupServer:tls-certificate or
soup_server_set_ssl_certificate().</doc-deprecated>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SERVER_SSL_KEY_FILE"
              value="ssl-key-file"
              c:type="SOUP_SERVER_SSL_KEY_FILE"
              deprecated="1">
      <doc xml:space="preserve">Alias for the #SoupServer:ssl-key-file property, qv.</doc>
      <doc-deprecated xml:space="preserve">use #SoupServer:tls-certificate or
soup_server_set_ssl_certificate().</doc-deprecated>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SERVER_TLS_CERTIFICATE"
              value="tls-certificate"
              c:type="SOUP_SERVER_TLS_CERTIFICATE"
              version="2.38">
      <doc xml:space="preserve">Alias for the #SoupServer:tls-certificate property, qv.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SESSION_ACCEPT_LANGUAGE"
              value="accept-language"
              c:type="SOUP_SESSION_ACCEPT_LANGUAGE"
              version="2.30">
      <doc xml:space="preserve">Alias for the #SoupSession:accept-language property, qv.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SESSION_ACCEPT_LANGUAGE_AUTO"
              value="accept-language-auto"
              c:type="SOUP_SESSION_ACCEPT_LANGUAGE_AUTO"
              version="2.30">
      <doc xml:space="preserve">Alias for the #SoupSession:accept-language-auto property, qv.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SESSION_ADD_FEATURE"
              value="add-feature"
              c:type="SOUP_SESSION_ADD_FEATURE"
              version="2.24"
              introspectable="0">
      <doc xml:space="preserve">Alias for the #SoupSession:add-feature property, qv.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SESSION_ADD_FEATURE_BY_TYPE"
              value="add-feature-by-type"
              c:type="SOUP_SESSION_ADD_FEATURE_BY_TYPE"
              version="2.24"
              introspectable="0">
      <doc xml:space="preserve">Alias for the #SoupSession:add-feature-by-type property, qv.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SESSION_ASYNC_CONTEXT"
              value="async-context"
              c:type="SOUP_SESSION_ASYNC_CONTEXT">
      <doc xml:space="preserve">Alias for the #SoupSession:async-context property, qv.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SESSION_ASYNC_H" value="1" c:type="SOUP_SESSION_ASYNC_H">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="SESSION_FEATURE_H"
              value="1"
              c:type="SOUP_SESSION_FEATURE_H">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="SESSION_H" value="1" c:type="SOUP_SESSION_H">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="SESSION_HTTPS_ALIASES"
              value="https-aliases"
              c:type="SOUP_SESSION_HTTPS_ALIASES"
              version="2.38">
      <doc xml:space="preserve">Alias for the #SoupSession:https-aliases property, qv.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SESSION_HTTP_ALIASES"
              value="http-aliases"
              c:type="SOUP_SESSION_HTTP_ALIASES"
              version="2.38">
      <doc xml:space="preserve">Alias for the #SoupSession:http-aliases property, qv.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SESSION_IDLE_TIMEOUT"
              value="idle-timeout"
              c:type="SOUP_SESSION_IDLE_TIMEOUT"
              version="2.24">
      <doc xml:space="preserve">Alias for the #SoupSession:idle-timeout property, qv.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SESSION_LOCAL_ADDRESS"
              value="local-address"
              c:type="SOUP_SESSION_LOCAL_ADDRESS"
              version="2.42">
      <doc xml:space="preserve">Alias for the #SoupSession:local-address property, qv.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SESSION_MAX_CONNS"
              value="max-conns"
              c:type="SOUP_SESSION_MAX_CONNS">
      <doc xml:space="preserve">Alias for the #SoupSession:max-conns property, qv.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SESSION_MAX_CONNS_PER_HOST"
              value="max-conns-per-host"
              c:type="SOUP_SESSION_MAX_CONNS_PER_HOST">
      <doc xml:space="preserve">Alias for the #SoupSession:max-conns-per-host property, qv.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SESSION_PROXY_RESOLVER"
              value="proxy-resolver"
              c:type="SOUP_SESSION_PROXY_RESOLVER">
      <doc xml:space="preserve">Alias for the #SoupSession:proxy-resolver property, qv.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SESSION_PROXY_URI"
              value="proxy-uri"
              c:type="SOUP_SESSION_PROXY_URI">
      <doc xml:space="preserve">Alias for the #SoupSession:proxy-uri property, qv.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SESSION_REMOVE_FEATURE_BY_TYPE"
              value="remove-feature-by-type"
              c:type="SOUP_SESSION_REMOVE_FEATURE_BY_TYPE"
              version="2.24"
              introspectable="0">
      <doc xml:space="preserve">Alias for the #SoupSession:remove-feature-by-type property,
qv.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SESSION_SSL_CA_FILE"
              value="ssl-ca-file"
              c:type="SOUP_SESSION_SSL_CA_FILE">
      <doc xml:space="preserve">Alias for the #SoupSession:ssl-ca-file property, qv.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SESSION_SSL_STRICT"
              value="ssl-strict"
              c:type="SOUP_SESSION_SSL_STRICT"
              version="2.30">
      <doc xml:space="preserve">Alias for the #SoupSession:ssl-strict property, qv.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SESSION_SSL_USE_SYSTEM_CA_FILE"
              value="ssl-use-system-ca-file"
              c:type="SOUP_SESSION_SSL_USE_SYSTEM_CA_FILE"
              version="2.38">
      <doc xml:space="preserve">Alias for the #SoupSession:ssl-use-system-ca-file property,
qv.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SESSION_SYNC_H" value="1" c:type="SOUP_SESSION_SYNC_H">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="SESSION_TIMEOUT"
              value="timeout"
              c:type="SOUP_SESSION_TIMEOUT">
      <doc xml:space="preserve">Alias for the #SoupSession:timeout property, qv.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SESSION_TLS_DATABASE"
              value="tls-database"
              c:type="SOUP_SESSION_TLS_DATABASE"
              version="2.38">
      <doc xml:space="preserve">Alias for the #SoupSession:tls-database property, qv.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SESSION_TLS_INTERACTION"
              value="tls-interaction"
              c:type="SOUP_SESSION_TLS_INTERACTION"
              version="2.48">
      <doc xml:space="preserve">Alias for the #SoupSession:tls-interaction property, qv.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SESSION_USER_AGENT"
              value="user-agent"
              c:type="SOUP_SESSION_USER_AGENT">
      <doc xml:space="preserve">Alias for the #SoupSession:user-agent property, qv.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SESSION_USE_NTLM"
              value="use-ntlm"
              c:type="SOUP_SESSION_USE_NTLM">
      <doc xml:space="preserve">Alias for the #SoupSession:use-ntlm property, qv.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SESSION_USE_THREAD_CONTEXT"
              value="use-thread-context"
              c:type="SOUP_SESSION_USE_THREAD_CONTEXT"
              version="2.38">
      <doc xml:space="preserve">Alias for the #SoupSession:use-thread-context property, qv.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SOCKET_ASYNC_CONTEXT"
              value="async-context"
              c:type="SOUP_SOCKET_ASYNC_CONTEXT">
      <doc xml:space="preserve">Alias for the #SoupSocket:async-context property. (The
socket's #GMainContext.)</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SOCKET_FLAG_NONBLOCKING"
              value="non-blocking"
              c:type="SOUP_SOCKET_FLAG_NONBLOCKING">
      <doc xml:space="preserve">Alias for the #SoupSocket:non-blocking property. (Whether
or not the socket uses non-blocking I/O.)</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SOCKET_H" value="1" c:type="SOUP_SOCKET_H">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="SOCKET_IS_SERVER"
              value="is-server"
              c:type="SOUP_SOCKET_IS_SERVER">
      <doc xml:space="preserve">Alias for the #SoupSocket:is-server property, qv.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SOCKET_LOCAL_ADDRESS"
              value="local-address"
              c:type="SOUP_SOCKET_LOCAL_ADDRESS">
      <doc xml:space="preserve">Alias for the #SoupSocket:local-address property. (Address
of local end of socket.)</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SOCKET_REMOTE_ADDRESS"
              value="remote-address"
              c:type="SOUP_SOCKET_REMOTE_ADDRESS">
      <doc xml:space="preserve">Alias for the #SoupSocket:remote-address property. (Address
of remote end of socket.)</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SOCKET_SSL_CREDENTIALS"
              value="ssl-creds"
              c:type="SOUP_SOCKET_SSL_CREDENTIALS">
      <doc xml:space="preserve">Alias for the #SoupSocket:ssl-creds property.
(SSL credential information.)</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SOCKET_SSL_FALLBACK"
              value="ssl-fallback"
              c:type="SOUP_SOCKET_SSL_FALLBACK">
      <doc xml:space="preserve">Alias for the #SoupSocket:ssl-fallback property.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SOCKET_SSL_STRICT"
              value="ssl-strict"
              c:type="SOUP_SOCKET_SSL_STRICT">
      <doc xml:space="preserve">Alias for the #SoupSocket:ssl-strict property.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SOCKET_TIMEOUT"
              value="timeout"
              c:type="SOUP_SOCKET_TIMEOUT">
      <doc xml:space="preserve">Alias for the #SoupSocket:timeout property. (The timeout
in seconds for blocking socket I/O operations.)</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SOCKET_TLS_CERTIFICATE"
              value="tls-certificate"
              c:type="SOUP_SOCKET_TLS_CERTIFICATE"
              version="2.34">
      <doc xml:space="preserve">Alias for the #SoupSocket:tls-certificate
property. Note that this property's value is only useful
if the socket is for a TLS connection, and only reliable
after some data has been transferred to or from it.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SOCKET_TLS_ERRORS"
              value="tls-errors"
              c:type="SOUP_SOCKET_TLS_ERRORS"
              version="2.34">
      <doc xml:space="preserve">Alias for the #SoupSocket:tls-errors
property. Note that this property's value is only useful
if the socket is for a TLS connection, and only reliable
after some data has been transferred to or from it.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SOCKET_TRUSTED_CERTIFICATE"
              value="trusted-certificate"
              c:type="SOUP_SOCKET_TRUSTED_CERTIFICATE">
      <doc xml:space="preserve">Alias for the #SoupSocket:trusted-certificate
property.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SOCKET_USE_THREAD_CONTEXT"
              value="use-thread-context"
              c:type="SOUP_SOCKET_USE_THREAD_CONTEXT"
              version="2.38">
      <doc xml:space="preserve">Alias for the #SoupSocket:use-thread-context property. (Use
g_main_context_get_thread_default())</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="STATUS_H" value="1" c:type="SOUP_STATUS_H">
      <type name="gint" c:type="gint"/>
    </constant>
    <class name="Server"
           c:symbol-prefix="server"
           c:type="SoupServer"
           parent="GObject.Object"
           glib:type-name="SoupServer"
           glib:get-type="soup_server_get_type"
           glib:type-struct="ServerClass">
      <constructor name="new"
                   c:identifier="soup_server_new"
                   introspectable="0">
        <doc xml:space="preserve">Creates a new #SoupServer. This is exactly equivalent to calling
g_object_new() and specifying %SOUP_TYPE_SERVER as the type.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a new #SoupServer. If you are using
certain legacy properties, this may also return %NULL if an error
occurs.</doc>
          <type name="Server" c:type="SoupServer*"/>
        </return-value>
        <parameters>
          <parameter name="optname1" transfer-ownership="none">
            <doc xml:space="preserve">name of first property to set</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">value of @optname1, followed by additional property/value pairs</doc>
            <varargs/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="request_aborted">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
          <parameter name="client" transfer-ownership="none">
            <type name="ClientContext" c:type="SoupClientContext*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="request_finished">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
          <parameter name="client" transfer-ownership="none">
            <type name="ClientContext" c:type="SoupClientContext*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="request_read">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
          <parameter name="client" transfer-ownership="none">
            <type name="ClientContext" c:type="SoupClientContext*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="request_started">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
          <parameter name="client" transfer-ownership="none">
            <type name="ClientContext" c:type="SoupClientContext*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="accept_iostream"
              c:identifier="soup_server_accept_iostream"
              version="2.50"
              throws="1">
        <doc xml:space="preserve">Add a new client stream to the @server.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE if the stream could not be
accepted or any other error occurred (in which case @error will be
set).</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServer</doc>
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
          <parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOStream</doc>
            <type name="Gio.IOStream" c:type="GIOStream*"/>
          </parameter>
          <parameter name="local_addr"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the local #GSocketAddress associated with the @stream</doc>
            <type name="Gio.SocketAddress" c:type="GSocketAddress*"/>
          </parameter>
          <parameter name="remote_addr"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the remote #GSocketAddress associated with the @stream</doc>
            <type name="Gio.SocketAddress" c:type="GSocketAddress*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_auth_domain"
              c:identifier="soup_server_add_auth_domain">
        <doc xml:space="preserve">Adds an authentication domain to @server. Each auth domain will
have the chance to require authentication for each request that
comes in; normally auth domains will require authentication for
requests on certain paths that they have been set up to watch, or
that meet other criteria set by the caller. If an auth domain
determines that a request requires authentication (and the request
doesn't contain authentication), @server will automatically reject
the request with an appropriate status (401 Unauthorized or 407
Proxy Authentication Required). If the request used the
"100-continue" Expectation, @server will reject it before the
request body is sent.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServer</doc>
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
          <parameter name="auth_domain" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuthDomain</doc>
            <type name="AuthDomain" c:type="SoupAuthDomain*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_early_handler"
              c:identifier="soup_server_add_early_handler"
              version="2.50">
        <doc xml:space="preserve">Adds an "early" handler to @server for requests under @path. Note
that "normal" and "early" handlers are matched up together, so if
you add a normal handler for "/foo" and an early handler for
"/foo/bar", then a request to "/foo/bar" (or any path below it)
will run only the early handler. (But if you add both handlers at
the same path, then both will get run.)

For requests under @path (that have not already been assigned a
status code by a #SoupAuthDomain or a signal handler), @callback
will be invoked after receiving the request headers, but before
receiving the request body; the message's #SoupMessage:method and
#SoupMessage:request-headers fields will be filled in.

Early handlers are generally used for processing requests with
request bodies in a streaming fashion. If you determine that the
request will contain a message body, normally you would call
soup_message_body_set_accumulate() on the message's
#SoupMessage:request-body to turn off request-body accumulation,
and connect to the message's #SoupMessage::got-chunk signal to
process each chunk as it comes in.

To complete the message processing after the full message body has
been read, you can either also connect to #SoupMessage::got-body,
or else you can register a non-early handler for @path as well. As
long as you have not set the #SoupMessage:status-code by the time
#SoupMessage::got-body is emitted, the non-early handler will be
run as well.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServer</doc>
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
          <parameter name="path"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the toplevel path for the handler</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="2"
                     destroy="3">
            <doc xml:space="preserve">callback to invoke for requests under @path</doc>
            <type name="ServerCallback" c:type="SoupServerCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">data for @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">destroy notifier to free @user_data</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_handler" c:identifier="soup_server_add_handler">
        <doc xml:space="preserve">Adds a handler to @server for requests under @path. If @path is
%NULL or "/", then this will be the default handler for all
requests that don't have a more specific handler. (Note though that
if you want to handle requests to the special "*" URI, you must
explicitly register a handler for "*"; the default handler will not
be used for that case.)

For requests under @path (that have not already been assigned a
status code by a #SoupAuthDomain, an early #SoupServerHandler, or a
signal handler), @callback will be invoked after receiving the
request body; the message's #SoupMessage:method,
#SoupMessage:request-headers, and #SoupMessage:request-body fields
will be filled in.

After determining what to do with the request, the callback must at
a minimum call soup_message_set_status() (or
soup_message_set_status_full()) on the message to set the response
status code. Additionally, it may set response headers and/or fill
in the response body.

If the callback cannot fully fill in the response before returning
(eg, if it needs to wait for information from a database, or
another network server), it should call soup_server_pause_message()
to tell @server to not send the response right away. When the
response is ready, call soup_server_unpause_message() to cause it
to be sent.

To send the response body a bit at a time using "chunked" encoding,
first call soup_message_headers_set_encoding() to set
%SOUP_ENCODING_CHUNKED on the #SoupMessage:response-headers. Then call
soup_message_body_append() (or soup_message_body_append_buffer())
to append each chunk as it becomes ready, and
soup_server_unpause_message() to make sure it's running. (The
server will automatically pause the message if it is using chunked
encoding but no more chunks are available.) When you are done, call
soup_message_body_complete() to indicate that no more chunks are
coming.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServer</doc>
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
          <parameter name="path"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the toplevel path for the handler</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="2"
                     destroy="3">
            <doc xml:space="preserve">callback to invoke for requests under @path</doc>
            <type name="ServerCallback" c:type="SoupServerCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">data for @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">destroy notifier to free @user_data</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_websocket_handler"
              c:identifier="soup_server_add_websocket_handler">
        <doc xml:space="preserve">Adds a WebSocket handler to @server for requests under @path. (If
@path is %NULL or "/", then this will be the default handler for
all requests that don't have a more specific handler.)

When a path has a WebSocket handler registered, @server will check
incoming requests for WebSocket handshakes after all other handlers
have run (unless some earlier handler has already set a status code
on the message), and update the request's status, response headers,
and response body accordingly.

If @origin is non-%NULL, then only requests containing a matching
"Origin" header will be accepted. If @protocols is non-%NULL, then
only requests containing a compatible "Sec-WebSocket-Protocols"
header will be accepted. More complicated requirements can be
handled by adding a normal handler to @path, and having it perform
whatever checks are needed (possibly calling
soup_server_check_websocket_handshake() one or more times), and
setting a failure status code if the handshake should be rejected.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServer</doc>
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
          <parameter name="path"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the toplevel path for the handler</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="origin"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the origin of the connection</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="protocols"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the protocols
  supported by this handler</doc>
            <array c:type="char**">
              <type name="utf8" c:type="char*"/>
            </array>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="4"
                     destroy="5">
            <doc xml:space="preserve">callback to invoke for successful WebSocket requests under @path</doc>
            <type name="ServerWebsocketCallback"
                  c:type="SoupServerWebsocketCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">data for @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">destroy notifier to free @user_data</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="disconnect" c:identifier="soup_server_disconnect">
        <doc xml:space="preserve">Closes and frees @server's listening sockets. If you are using the
old #SoupServer APIs, this also includes the effect of
soup_server_quit().

Note that if there are currently requests in progress on @server,
that they will continue to be processed if @server's #GMainContext
is still running.

You can call soup_server_listen(), etc, after calling this function
if you want to start listening again.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServer</doc>
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_async_context"
              c:identifier="soup_server_get_async_context"
              deprecated="1">
        <doc xml:space="preserve">Gets @server's async_context, if you are using the old API. (With
the new API, the server runs in the thread's thread-default
#GMainContext, regardless of what this method returns.)

This does not add a ref to the context, so you will need to ref it
yourself if you want it to outlive its server.</doc>
        <doc-deprecated xml:space="preserve">If you are using soup_server_listen(), etc, then
the server listens on the thread-default #GMainContext, and this
property is ignored.</doc-deprecated>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">@server's #GMainContext,
which may be %NULL</doc>
          <type name="GLib.MainContext" c:type="GMainContext*"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServer</doc>
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_listener"
              c:identifier="soup_server_get_listener"
              deprecated="1">
        <doc xml:space="preserve">Gets @server's listening socket, if you are using the old API.

You should treat this socket as read-only; writing to it or
modifiying it may cause @server to malfunction.</doc>
        <doc-deprecated xml:space="preserve">If you are using soup_server_listen(), etc, then use
soup_server_get_listeners() to get a list of all listening sockets,
but note that that function returns #GSockets, not #SoupSockets.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the listening socket.</doc>
          <type name="Socket" c:type="SoupSocket*"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServer</doc>
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_listeners" c:identifier="soup_server_get_listeners">
        <doc xml:space="preserve">Gets @server's list of listening sockets.

You should treat these sockets as read-only; writing to or
modifiying any of these sockets may cause @server to malfunction.

(Beware that in contrast to the old soup_server_get_listener(), this
function returns #GSockets, not #SoupSockets.)</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">a
list of listening sockets.</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="Gio.Socket"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServer</doc>
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_port"
              c:identifier="soup_server_get_port"
              deprecated="1">
        <doc xml:space="preserve">Gets the TCP port that @server is listening on, if you are using
the old API.</doc>
        <doc-deprecated xml:space="preserve">If you are using soup_server_listen(), etc, then use
soup_server_get_uris() to get a list of all listening addresses.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the port @server is listening on.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServer</doc>
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_uris"
              c:identifier="soup_server_get_uris"
              version="2.48">
        <doc xml:space="preserve">Gets a list of URIs corresponding to the interfaces @server is
listening on. These will contain IP addresses, not hostnames, and
will also indicate whether the given listener is http or https.

Note that if you used soup_server_listen_all(), the returned URIs
will use the addresses &lt;literal&gt;0.0.0.0&lt;/literal&gt; and
&lt;literal&gt;::&lt;/literal&gt;, rather than actually returning separate URIs
for each interface on the system.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a list of
#SoupURIs, which you must free when you are done with it.</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="URI"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServer</doc>
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_https" c:identifier="soup_server_is_https">
        <doc xml:space="preserve">Checks whether @server is capable of https.

In order for a server to run https, you must call
soup_server_set_ssl_cert_file(), or set the
#SoupServer:tls-certificate property, to provide it with a
certificate to use.

If you are using the deprecated single-listener APIs, then a return
value of %TRUE indicates that the #SoupServer serves https
exclusively. If you are using soup_server_listen(), etc, then a
%TRUE return value merely indicates that the server is
&lt;emphasis&gt;able&lt;/emphasis&gt; to do https, regardless of whether it
actually currently is or not. Use soup_server_get_uris() to see if
it currently has any https listeners.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @server is configured to serve https.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServer</doc>
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="listen"
              c:identifier="soup_server_listen"
              version="2.48"
              throws="1">
        <doc xml:space="preserve">This attempts to set up @server to listen for connections on
@address.

If @options includes %SOUP_SERVER_LISTEN_HTTPS, and @server has
been configured for TLS, then @server will listen for https
connections on this port. Otherwise it will listen for plain http.

You may call this method (along with the other "listen" methods)
any number of times on a server, if you want to listen on multiple
ports, or set up both http and https service.

After calling this method, @server will begin accepting and
processing connections as soon as the appropriate #GMainContext is
run.

Note that #SoupServer never makes use of dual IPv4/IPv6 sockets; if
@address is an IPv6 address, it will only accept IPv6 connections.
You must configure IPv4 listening separately.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE if @address could not be
bound or any other error occurred (in which case @error will be
set).</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServer</doc>
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
          <parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">the address of the interface to listen on</doc>
            <type name="Gio.SocketAddress" c:type="GSocketAddress*"/>
          </parameter>
          <parameter name="options" transfer-ownership="none">
            <doc xml:space="preserve">listening options for this server</doc>
            <type name="ServerListenOptions" c:type="SoupServerListenOptions"/>
          </parameter>
        </parameters>
      </method>
      <method name="listen_all"
              c:identifier="soup_server_listen_all"
              version="2.48"
              throws="1">
        <doc xml:space="preserve">This attempts to set up @server to listen for connections on all
interfaces on the system. (That is, it listens on the addresses
&lt;literal&gt;0.0.0.0&lt;/literal&gt; and/or &lt;literal&gt;::&lt;/literal&gt;, depending
on whether @options includes %SOUP_SERVER_LISTEN_IPV4_ONLY,
%SOUP_SERVER_LISTEN_IPV6_ONLY, or neither.) If @port is specified,
@server will listen on that port. If it is 0, @server will find an
unused port to listen on. (In that case, you can use
soup_server_get_uris() to find out what port it ended up choosing.)

See soup_server_listen() for more details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE if @port could not be bound
or any other error occurred (in which case @error will be set).</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServer</doc>
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
          <parameter name="port" transfer-ownership="none">
            <doc xml:space="preserve">the port to listen on, or 0</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="options" transfer-ownership="none">
            <doc xml:space="preserve">listening options for this server</doc>
            <type name="ServerListenOptions" c:type="SoupServerListenOptions"/>
          </parameter>
        </parameters>
      </method>
      <method name="listen_fd"
              c:identifier="soup_server_listen_fd"
              version="2.48"
              throws="1">
        <doc xml:space="preserve">This attempts to set up @server to listen for connections on
@fd.

See soup_server_listen() for more details.

Note that @server will close @fd when you free it or call
soup_server_disconnect().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE if an error occurred (in
which case @error will be set).</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServer</doc>
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
          <parameter name="fd" transfer-ownership="none">
            <doc xml:space="preserve">the file descriptor of a listening socket</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="options" transfer-ownership="none">
            <doc xml:space="preserve">listening options for this server</doc>
            <type name="ServerListenOptions" c:type="SoupServerListenOptions"/>
          </parameter>
        </parameters>
      </method>
      <method name="listen_local"
              c:identifier="soup_server_listen_local"
              version="2.48"
              throws="1">
        <doc xml:space="preserve">This attempts to set up @server to listen for connections on
"localhost" (that is, &lt;literal&gt;127.0.0.1&lt;/literal&gt; and/or
&lt;literal&gt;::1&lt;/literal&gt;, depending on whether @options includes
%SOUP_SERVER_LISTEN_IPV4_ONLY, %SOUP_SERVER_LISTEN_IPV6_ONLY, or
neither). If @port is specified, @server will listen on that port.
If it is 0, @server will find an unused port to listen on. (In that
case, you can use soup_server_get_uris() to find out what port it
ended up choosing.)

See soup_server_listen() for more details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE if @port could not be bound
or any other error occurred (in which case @error will be set).</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServer</doc>
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
          <parameter name="port" transfer-ownership="none">
            <doc xml:space="preserve">the port to listen on, or 0</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="options" transfer-ownership="none">
            <doc xml:space="preserve">listening options for this server</doc>
            <type name="ServerListenOptions" c:type="SoupServerListenOptions"/>
          </parameter>
        </parameters>
      </method>
      <method name="listen_socket"
              c:identifier="soup_server_listen_socket"
              version="2.48"
              throws="1">
        <doc xml:space="preserve">This attempts to set up @server to listen for connections on
@socket.

See soup_server_listen() for more details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE if an error occurred (in
which case @error will be set).</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServer</doc>
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
          <parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a listening #GSocket</doc>
            <type name="Gio.Socket" c:type="GSocket*"/>
          </parameter>
          <parameter name="options" transfer-ownership="none">
            <doc xml:space="preserve">listening options for this server</doc>
            <type name="ServerListenOptions" c:type="SoupServerListenOptions"/>
          </parameter>
        </parameters>
      </method>
      <method name="pause_message" c:identifier="soup_server_pause_message">
        <doc xml:space="preserve">Pauses I/O on @msg. This can be used when you need to return from
the server handler without having the full response ready yet. Use
soup_server_unpause_message() to resume I/O.

This must only be called on #SoupMessages which were created by the
#SoupServer and are currently doing I/O, such as those passed into a
#SoupServerCallback or emitted in a #SoupServer::request-read signal.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServer</doc>
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage associated with @server.</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
        </parameters>
      </method>
      <method name="quit" c:identifier="soup_server_quit" deprecated="1">
        <doc xml:space="preserve">Stops processing for @server, if you are using the old API. Call
this to clean up after soup_server_run_async(), or to terminate a
call to soup_server_run().

Note that messages currently in progress will continue to be
handled, if the main loop associated with the server is resumed or
kept running.

@server is still in a working state after this call; you can start
and stop a server as many times as you want.</doc>
        <doc-deprecated xml:space="preserve">When using soup_server_listen(), etc, the server will
always listen for connections, and will process them whenever the
thread-default #GMainContext is running.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServer</doc>
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="remove_auth_domain"
              c:identifier="soup_server_remove_auth_domain">
        <doc xml:space="preserve">Removes @auth_domain from @server.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServer</doc>
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
          <parameter name="auth_domain" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuthDomain</doc>
            <type name="AuthDomain" c:type="SoupAuthDomain*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_handler" c:identifier="soup_server_remove_handler">
        <doc xml:space="preserve">Removes all handlers (early and normal) registered at @path.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServer</doc>
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the toplevel path for the handler</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="run" c:identifier="soup_server_run" deprecated="1">
        <doc xml:space="preserve">Starts @server, if you are using the old API, causing it to listen
for and process incoming connections. Unlike
soup_server_run_async(), this creates a #GMainLoop and runs it, and
it will not return until someone calls soup_server_quit() to stop
the server.</doc>
        <doc-deprecated xml:space="preserve">When using soup_server_listen(), etc, the server will
always listen for connections, and will process them whenever the
thread-default #GMainContext is running.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServer</doc>
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="run_async"
              c:identifier="soup_server_run_async"
              deprecated="1">
        <doc xml:space="preserve">Starts @server, if you are using the old API, causing it to listen
for and process incoming connections.

The server runs in @server's #GMainContext. It will not actually
perform any processing unless the appropriate main loop is running.
In the simple case where you did not set the server's
%SOUP_SERVER_ASYNC_CONTEXT property, this means the server will run
whenever the glib main loop is running.</doc>
        <doc-deprecated xml:space="preserve">When using soup_server_listen(), etc, the server will
always listen for connections, and will process them whenever the
thread-default #GMainContext is running.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServer</doc>
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_ssl_cert_file"
              c:identifier="soup_server_set_ssl_cert_file"
              version="2.48"
              throws="1">
        <doc xml:space="preserve">Sets @server up to do https, using the SSL/TLS certificate
specified by @ssl_cert_file and @ssl_key_file (which may point to
the same file).

Alternatively, you can set the #SoupServer:tls-certificate property
at construction time, if you already have a #GTlsCertificate.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">success or failure.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServer</doc>
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
          <parameter name="ssl_cert_file" transfer-ownership="none">
            <doc xml:space="preserve">path to a file containing a PEM-encoded SSL/TLS
  certificate.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="ssl_key_file" transfer-ownership="none">
            <doc xml:space="preserve">path to a file containing a PEM-encoded private key.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unpause_message"
              c:identifier="soup_server_unpause_message">
        <doc xml:space="preserve">Resumes I/O on @msg. Use this to resume after calling
soup_server_pause_message(), or after adding a new chunk to a
chunked response.

I/O won't actually resume until you return to the main loop.

This must only be called on #SoupMessages which were created by the
#SoupServer and are currently doing I/O, such as those passed into a
#SoupServerCallback or emitted in a #SoupServer::request-read signal.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServer</doc>
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage associated with @server.</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
        </parameters>
      </method>
      <property name="async-context"
                deprecated="1"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The server's #GMainContext, if you are using the old API.
Servers created using soup_server_listen() will listen on
the #GMainContext that was the thread-default context at
the time soup_server_listen() was called.</doc>
        <doc-deprecated xml:space="preserve">The new API uses the thread-default #GMainContext
rather than having an explicitly-specified one.</doc-deprecated>
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <property name="http-aliases"
                version="2.44"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">A %NULL-terminated array of URI schemes that should be
considered to be aliases for "http". Eg, if this included
&lt;literal&gt;"dav"&lt;/literal&gt;, than a URI of
&lt;literal&gt;dav://example.com/path&lt;/literal&gt; would be treated
identically to &lt;literal&gt;http://example.com/path&lt;/literal&gt;.
In particular, this is needed in cases where a client
sends requests with absolute URIs, where those URIs do
not use "http:".

The default value is an array containing the single element
&lt;literal&gt;"*"&lt;/literal&gt;, a special value which means that
any scheme except "https" is considered to be an alias for
"http".

See also #SoupServer:https-aliases.</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <property name="https-aliases"
                version="2.44"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">A comma-delimited list of URI schemes that should be
considered to be aliases for "https". See
#SoupServer:http-aliases for more information.

The default value is %NULL, meaning that no URI schemes
are considered aliases for "https".</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <property name="interface"
                deprecated="1"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The address of the network interface the server is
listening on, if you are using the old #SoupServer API.
(This will not be set if you use soup_server_listen(),
etc.)</doc>
        <doc-deprecated xml:space="preserve">#SoupServers can listen on multiple interfaces
at once now. Use soup_server_listen(), etc, to listen on an
interface, and soup_server_get_uris() to see what addresses
are being listened on.</doc-deprecated>
        <type name="Address"/>
      </property>
      <property name="port"
                deprecated="1"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The port the server is listening on, if you are using the
old #SoupServer API. (This will not be set if you use
soup_server_listen(), etc.)</doc>
        <doc-deprecated xml:space="preserve">#SoupServers can listen on multiple interfaces
at once now. Use soup_server_listen(), etc, to listen on a
port, and soup_server_get_uris() to see what ports are
being listened on.</doc-deprecated>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="raw-paths"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="server-header"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If non-%NULL, the value to use for the "Server" header on
#SoupMessage&lt;!-- --&gt;s processed by this server.

The Server header is the server equivalent of the
User-Agent header, and provides information about the
server and its components. It contains a list of one or
more product tokens, separated by whitespace, with the most
significant product token coming first. The tokens must be
brief, ASCII, and mostly alphanumeric (although "-", "_",
and "." are also allowed), and may optionally include a "/"
followed by a version string. You may also put comments,
enclosed in parentheses, between or after the tokens.

Some HTTP server implementations intentionally do not use
version numbers in their Server header, so that
installations running older versions of the server don't
end up advertising their vulnerability to specific security
holes.

As with #SoupSession:user_agent, if you set a
#SoupServer:server_header property that has trailing whitespace,
#SoupServer will append its own product token (eg,
"&lt;literal&gt;libsoup/2.3.2&lt;/literal&gt;") to the end of the
header for you.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="ssl-cert-file"
                deprecated="1"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Path to a file containing a PEM-encoded certificate.

If you set this property and #SoupServer:ssl-key-file at
construct time, then soup_server_new() will try to read the
files; if it cannot, it will return %NULL, with no explicit
indication of what went wrong (and logging a warning with
newer versions of glib, since returning %NULL from a
constructor is illegal).</doc>
        <doc-deprecated xml:space="preserve">use #SoupServer:tls-certificate or
soup_server_set_ssl_certificate().</doc-deprecated>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="ssl-key-file"
                deprecated="1"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Path to a file containing a PEM-encoded private key. See
#SoupServer:ssl-cert-file for more information about how this
is used.</doc>
        <doc-deprecated xml:space="preserve">use #SoupServer:tls-certificate or
soup_server_set_ssl_certificate().</doc-deprecated>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="tls-certificate"
                version="2.38"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">A #GTlsCertificate that has a #GTlsCertificate:private-key
set. If this is set, then the server will be able to speak
https in addition to (or instead of) plain http.

Alternatively, you can call soup_server_set_ssl_cert_file()
to have #SoupServer read in a a certificate from a file.</doc>
        <type name="Gio.TlsCertificate"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <glib:signal name="request-aborted" when="first">
        <doc xml:space="preserve">Emitted when processing has failed for a message; this
could mean either that it could not be read (if
#SoupServer::request_read has not been emitted for it yet),
or that the response could not be written back (if
#SoupServer::request_read has been emitted but
#SoupServer::request_finished has not been).

@message is in an undefined state when this signal is
emitted; the signal exists primarily to allow the server to
free any state that it may have allocated in
#SoupServer::request_started.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">the message</doc>
            <type name="Message"/>
          </parameter>
          <parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">the client context</doc>
            <type name="ClientContext"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="request-finished" when="first">
        <doc xml:space="preserve">Emitted when the server has finished writing a response to
a request.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">the message</doc>
            <type name="Message"/>
          </parameter>
          <parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">the client context</doc>
            <type name="ClientContext"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="request-read" when="first">
        <doc xml:space="preserve">Emitted when the server has successfully read a request.
@message will have all of its request-side information
filled in, and if the message was authenticated, @client
will have information about that. This signal is emitted
before any (non-early) handlers are called for the message,
and if it sets the message's #status_code, then normal
handler processing will be skipped.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">the message</doc>
            <type name="Message"/>
          </parameter>
          <parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">the client context</doc>
            <type name="ClientContext"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="request-started" when="first">
        <doc xml:space="preserve">Emitted when the server has started reading a new request.
@message will be completely blank; not even the
Request-Line will have been read yet. About the only thing
you can usefully do with it is connect to its signals.

If the request is read successfully, this will eventually
be followed by a #SoupServer::request_read signal. If a
response is then sent, the request processing will end with
a #SoupServer::request_finished signal. If a network error
occurs, the processing will instead end with
#SoupServer::request_aborted.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">the new message</doc>
            <type name="Message"/>
          </parameter>
          <parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">the client context</doc>
            <type name="ClientContext"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <callback name="ServerCallback" c:type="SoupServerCallback">
      <doc xml:space="preserve">A callback used to handle requests to a #SoupServer.

@path and @query contain the likewise-named components of the
Request-URI, subject to certain assumptions. By default,
#SoupServer decodes all percent-encoding in the URI path, such that
"/foo%&lt;!-- --&gt;2Fbar" is treated the same as "/foo/bar". If your
server is serving resources in some non-POSIX-filesystem namespace,
you may want to distinguish those as two distinct paths. In that
case, you can set the %SOUP_SERVER_RAW_PATHS property when creating
the #SoupServer, and it will leave those characters undecoded. (You
may want to call soup_uri_normalize() to decode any percent-encoded
characters that you aren't handling specially.)

@query contains the query component of the Request-URI parsed
according to the rules for HTML form handling. Although this is the
only commonly-used query string format in HTTP, there is nothing
that actually requires that HTTP URIs use that format; if your
server needs to use some other format, you can just ignore @query,
and call soup_message_get_uri() and parse the URI's query field
yourself.

See soup_server_add_handler() and soup_server_add_early_handler()
for details of what handlers can/should do.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="server" transfer-ownership="none">
          <doc xml:space="preserve">the #SoupServer</doc>
          <type name="Server" c:type="SoupServer*"/>
        </parameter>
        <parameter name="msg" transfer-ownership="none">
          <doc xml:space="preserve">the message being processed</doc>
          <type name="Message" c:type="SoupMessage*"/>
        </parameter>
        <parameter name="path" transfer-ownership="none">
          <doc xml:space="preserve">the path component of @msg's Request-URI</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="query"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">the parsed query
  component of @msg's Request-URI</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="utf8"/>
          </type>
        </parameter>
        <parameter name="client" transfer-ownership="none">
          <doc xml:space="preserve">additional contextual information about the client</doc>
          <type name="ClientContext" c:type="SoupClientContext*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="5">
          <doc xml:space="preserve">the data passed to soup_server_add_handler() or
  soup_server_add_early_handler().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="ServerClass"
            c:type="SoupServerClass"
            glib:is-gtype-struct-for="Server">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="request_started">
        <callback name="request_started">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="server" transfer-ownership="none">
              <type name="Server" c:type="SoupServer*"/>
            </parameter>
            <parameter name="msg" transfer-ownership="none">
              <type name="Message" c:type="SoupMessage*"/>
            </parameter>
            <parameter name="client" transfer-ownership="none">
              <type name="ClientContext" c:type="SoupClientContext*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="request_read">
        <callback name="request_read">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="server" transfer-ownership="none">
              <type name="Server" c:type="SoupServer*"/>
            </parameter>
            <parameter name="msg" transfer-ownership="none">
              <type name="Message" c:type="SoupMessage*"/>
            </parameter>
            <parameter name="client" transfer-ownership="none">
              <type name="ClientContext" c:type="SoupClientContext*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="request_finished">
        <callback name="request_finished">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="server" transfer-ownership="none">
              <type name="Server" c:type="SoupServer*"/>
            </parameter>
            <parameter name="msg" transfer-ownership="none">
              <type name="Message" c:type="SoupMessage*"/>
            </parameter>
            <parameter name="client" transfer-ownership="none">
              <type name="ClientContext" c:type="SoupClientContext*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="request_aborted">
        <callback name="request_aborted">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="server" transfer-ownership="none">
              <type name="Server" c:type="SoupServer*"/>
            </parameter>
            <parameter name="msg" transfer-ownership="none">
              <type name="Message" c:type="SoupMessage*"/>
            </parameter>
            <parameter name="client" transfer-ownership="none">
              <type name="ClientContext" c:type="SoupClientContext*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_libsoup_reserved1" introspectable="0">
        <callback name="_libsoup_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_libsoup_reserved2" introspectable="0">
        <callback name="_libsoup_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_libsoup_reserved3" introspectable="0">
        <callback name="_libsoup_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_libsoup_reserved4" introspectable="0">
        <callback name="_libsoup_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <bitfield name="ServerListenOptions"
              version="2.48"
              glib:type-name="SoupServerListenOptions"
              glib:get-type="soup_server_listen_options_get_type"
              c:type="SoupServerListenOptions">
      <doc xml:space="preserve">Options to pass to soup_server_listen(), etc.

%SOUP_SERVER_LISTEN_IPV4_ONLY and %SOUP_SERVER_LISTEN_IPV6_ONLY
only make sense with soup_server_listen_all() and
soup_server_listen_local(), not plain soup_server_listen() (which
simply listens on whatever kind of socket you give it). And you
cannot specify both of them in a single call.</doc>
      <member name="https"
              value="1"
              c:identifier="SOUP_SERVER_LISTEN_HTTPS"
              glib:nick="https">
        <doc xml:space="preserve">Listen for https connections rather
  than plain http.</doc>
      </member>
      <member name="ipv4_only"
              value="2"
              c:identifier="SOUP_SERVER_LISTEN_IPV4_ONLY"
              glib:nick="ipv4-only">
        <doc xml:space="preserve">Only listen on IPv4 interfaces.</doc>
      </member>
      <member name="ipv6_only"
              value="4"
              c:identifier="SOUP_SERVER_LISTEN_IPV6_ONLY"
              glib:nick="ipv6-only">
        <doc xml:space="preserve">Only listen on IPv6 interfaces.</doc>
      </member>
    </bitfield>
    <callback name="ServerWebsocketCallback"
              c:type="SoupServerWebsocketCallback">
      <doc xml:space="preserve">A callback used to handle WebSocket requests to a #SoupServer. The
callback will be invoked after sending the handshake response back
to the client (and is only invoked if the handshake was
successful).

@path contains the path of the Request-URI, subject to the same
rules as #SoupServerCallback (qv).</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="server" transfer-ownership="none">
          <doc xml:space="preserve">the #SoupServer</doc>
          <type name="Server" c:type="SoupServer*"/>
        </parameter>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:space="preserve">the newly created WebSocket connection</doc>
          <type name="WebsocketConnection" c:type="SoupWebsocketConnection*"/>
        </parameter>
        <parameter name="path" transfer-ownership="none">
          <doc xml:space="preserve">the path component of @msg's Request-URI</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="client" transfer-ownership="none">
          <doc xml:space="preserve">additional contextual information about the client</doc>
          <type name="ClientContext" c:type="SoupClientContext*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="4">
          <doc xml:space="preserve">the data passed to @soup_server_add_handler</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="Session"
           c:symbol-prefix="session"
           c:type="SoupSession"
           parent="GObject.Object"
           glib:type-name="SoupSession"
           glib:get-type="soup_session_get_type"
           glib:type-struct="SessionClass">
      <constructor name="new" c:identifier="soup_session_new" version="2.42">
        <doc xml:space="preserve">Creates a #SoupSession with the default options.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new session.</doc>
          <type name="Session" c:type="SoupSession*"/>
        </return-value>
      </constructor>
      <constructor name="new_with_options"
                   c:identifier="soup_session_new_with_options"
                   version="2.42"
                   introspectable="0">
        <doc xml:space="preserve">Creates a #SoupSession with the specified options.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new session.</doc>
          <type name="Session" c:type="SoupSession*"/>
        </return-value>
        <parameters>
          <parameter name="optname1" transfer-ownership="none">
            <doc xml:space="preserve">name of first property to set</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">value of @optname1, followed by additional property/value pairs</doc>
            <varargs/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="auth_required">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
          <parameter name="auth" transfer-ownership="none">
            <type name="Auth" c:type="SoupAuth*"/>
          </parameter>
          <parameter name="retrying" transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="authenticate">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
          <parameter name="auth" transfer-ownership="none">
            <type name="Auth" c:type="SoupAuth*"/>
          </parameter>
          <parameter name="retrying" transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="cancel_message" invoker="cancel_message">
        <doc xml:space="preserve">Causes @session to immediately finish processing @msg (regardless
of its current state) with a final status_code of @status_code. You
may call this at any time after handing @msg off to @session; if
@session has started sending the request but has not yet received
the complete response, then it will close the request's connection.
Note that with requests that have side effects (eg,
&lt;literal&gt;POST&lt;/literal&gt;, &lt;literal&gt;PUT&lt;/literal&gt;,
&lt;literal&gt;DELETE&lt;/literal&gt;) it is possible that you might cancel the
request after the server acts on it, but before it returns a
response, leaving the remote resource in an unknown state.

If the message is cancelled while its response body is being read,
then the response body in @msg will be left partially-filled-in.
The response headers, on the other hand, will always be either
empty or complete.

Beware that with the deprecated #SoupSessionAsync, messages queued
with soup_session_queue_message() will have their callbacks invoked
before soup_session_cancel_message() returns. The plain
#SoupSession does not have this behavior; cancelling an
asynchronous message will merely queue its callback to be run after
returning to the main loop.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">the message to cancel</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
          <parameter name="status_code" transfer-ownership="none">
            <doc xml:space="preserve">status code to set on @msg (generally
%SOUP_STATUS_CANCELLED)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="flush_queue">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="kick">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="queue_message" invoker="queue_message">
        <doc xml:space="preserve">Queues the message @msg for asynchronously sending the request and
receiving a response in the current thread-default #GMainContext.
If @msg has been processed before, any resources related to the
time it was last sent are freed.

Upon message completion, the callback specified in @callback will
be invoked. If after returning from this callback the message has not
been requeued, @msg will be unreffed.

(The behavior above applies to a plain #SoupSession; if you are
using #SoupSessionAsync or #SoupSessionSync, then the #GMainContext
that is used depends on the settings of #SoupSession:async-context
and #SoupSession:use-thread-context, and for #SoupSessionSync, the
message will actually be sent and processed in another thread, with
only the final callback occurring in the indicated #GMainContext.)

Contrast this method with soup_session_send_async(), which also
asynchronously sends a message, but returns before reading the
response body, and allows you to read the response via a
#GInputStream.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="full">
            <doc xml:space="preserve">the message to queue</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">a #SoupSessionCallback which will
be called after the message completes or when an unrecoverable error occurs.</doc>
            <type name="SessionCallback" c:type="SoupSessionCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     closure="2">
            <doc xml:space="preserve">a pointer passed to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="request_started">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
          <parameter name="socket" transfer-ownership="none">
            <type name="Socket" c:type="SoupSocket*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="requeue_message" invoker="requeue_message">
        <doc xml:space="preserve">This causes @msg to be placed back on the queue to be attempted
again.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">the message to requeue</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="send_message" invoker="send_message">
        <doc xml:space="preserve">Synchronously send @msg. This call will not return until the
transfer is finished successfully or there is an unrecoverable
error.

Unlike with soup_session_queue_message(), @msg is not freed upon
return.

(Note that if you call this method on a #SoupSessionAsync, it will
still use asynchronous I/O internally, running the glib main loop
to process the message, which may also cause other events to be
processed.)

Contrast this method with soup_session_send(), which also
synchronously sends a message, but returns before reading the
response body, and allows you to read the response via a
#GInputStream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the HTTP status code of the response</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">the message to send</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="abort" c:identifier="soup_session_abort">
        <doc xml:space="preserve">Cancels all pending requests in @session and closes all idle
persistent connections.

The message cancellation has the same semantics as with
soup_session_cancel_message(); asynchronous requests on a
#SoupSessionAsync will have their callback called before
soup_session_abort() returns. Requests on a plain #SoupSession will
not.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">the session</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="add_feature"
              c:identifier="soup_session_add_feature"
              version="2.24">
        <doc xml:space="preserve">Adds @feature's functionality to @session. You can also add a
feature to the session at construct time by using the
%SOUP_SESSION_ADD_FEATURE property.

See the main #SoupSession documentation for information on what
features are present in sessions by default.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="feature" transfer-ownership="none">
            <doc xml:space="preserve">an object that implements #SoupSessionFeature</doc>
            <type name="SessionFeature" c:type="SoupSessionFeature*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_feature_by_type"
              c:identifier="soup_session_add_feature_by_type"
              version="2.24">
        <doc xml:space="preserve">If @feature_type is the type of a class that implements
#SoupSessionFeature, this creates a new feature of that type and
adds it to @session as with soup_session_add_feature(). You can use
this when you don't need to customize the new feature in any way.

If @feature_type is not a #SoupSessionFeature type, this gives each
existing feature on @session the chance to accept @feature_type as
a "subfeature". This can be used to add new #SoupAuth or
#SoupRequest types, for instance.

You can also add a feature to the session at construct time by
using the %SOUP_SESSION_ADD_FEATURE_BY_TYPE property.

See the main #SoupSession documentation for information on what
features are present in sessions by default.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="feature_type" transfer-ownership="none">
            <doc xml:space="preserve">a #GType</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
      <method name="cancel_message" c:identifier="soup_session_cancel_message">
        <doc xml:space="preserve">Causes @session to immediately finish processing @msg (regardless
of its current state) with a final status_code of @status_code. You
may call this at any time after handing @msg off to @session; if
@session has started sending the request but has not yet received
the complete response, then it will close the request's connection.
Note that with requests that have side effects (eg,
&lt;literal&gt;POST&lt;/literal&gt;, &lt;literal&gt;PUT&lt;/literal&gt;,
&lt;literal&gt;DELETE&lt;/literal&gt;) it is possible that you might cancel the
request after the server acts on it, but before it returns a
response, leaving the remote resource in an unknown state.

If the message is cancelled while its response body is being read,
then the response body in @msg will be left partially-filled-in.
The response headers, on the other hand, will always be either
empty or complete.

Beware that with the deprecated #SoupSessionAsync, messages queued
with soup_session_queue_message() will have their callbacks invoked
before soup_session_cancel_message() returns. The plain
#SoupSession does not have this behavior; cancelling an
asynchronous message will merely queue its callback to be run after
returning to the main loop.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">the message to cancel</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
          <parameter name="status_code" transfer-ownership="none">
            <doc xml:space="preserve">status code to set on @msg (generally
%SOUP_STATUS_CANCELLED)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_async_context"
              c:identifier="soup_session_get_async_context">
        <doc xml:space="preserve">Gets @session's #SoupSession:async-context. This does not add a ref
to the context, so you will need to ref it yourself if you want it
to outlive its session.

For a modern #SoupSession, this will always just return the
thread-default #GMainContext, and so is not especially useful.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">@session's #GMainContext,
which may be %NULL</doc>
          <type name="GLib.MainContext" c:type="GMainContext*"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_feature"
              c:identifier="soup_session_get_feature"
              version="2.26">
        <doc xml:space="preserve">Gets the first feature in @session of type @feature_type. For
features where there may be more than one feature of a given type,
use soup_session_get_features().</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">a #SoupSessionFeature, or
%NULL. The feature is owned by @session.</doc>
          <type name="SessionFeature" c:type="SoupSessionFeature*"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="feature_type" transfer-ownership="none">
            <doc xml:space="preserve">the #GType of the feature to get</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_feature_for_message"
              c:identifier="soup_session_get_feature_for_message"
              version="2.28">
        <doc xml:space="preserve">Gets the first feature in @session of type @feature_type, provided
that it is not disabled for @msg. As with
soup_session_get_feature(), this should only be used for features
where @feature_type is only expected to match a single feature. In
particular, if there are two matching features, and the first is
disabled on @msg, and the second is not, then this will return
%NULL, not the second feature.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">a #SoupSessionFeature, or %NULL. The
feature is owned by @session.</doc>
          <type name="SessionFeature" c:type="SoupSessionFeature*"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="feature_type" transfer-ownership="none">
            <doc xml:space="preserve">the #GType of the feature to get</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_features"
              c:identifier="soup_session_get_features"
              version="2.26">
        <doc xml:space="preserve">Generates a list of @session's features of type @feature_type. (If
you want to see all features, you can pass %SOUP_TYPE_SESSION_FEATURE
for @feature_type.)</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">
a list of features. You must free the list, but not its contents</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="SessionFeature"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="feature_type" transfer-ownership="none">
            <doc xml:space="preserve">the #GType of the class of features to get</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_feature"
              c:identifier="soup_session_has_feature"
              version="2.42">
        <doc xml:space="preserve">Tests if @session has at a feature of type @feature_type (which can
be the type of either a #SoupSessionFeature, or else a subtype of
some class managed by another feature, such as #SoupAuth or
#SoupRequest).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE or %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="feature_type" transfer-ownership="none">
            <doc xml:space="preserve">the #GType of the class of features to check for</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
      <method name="pause_message" c:identifier="soup_session_pause_message">
        <doc xml:space="preserve">Pauses HTTP I/O on @msg. Call soup_session_unpause_message() to
resume I/O.

This may only be called for asynchronous messages (those sent on a
#SoupSessionAsync or using soup_session_queue_message()).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage currently running on @session</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
        </parameters>
      </method>
      <method name="prefetch_dns"
              c:identifier="soup_session_prefetch_dns"
              version="2.38">
        <doc xml:space="preserve">Tells @session that an URI from the given @hostname may be requested
shortly, and so the session can try to prepare by resolving the
domain name in advance, in order to work more quickly once the URI
is actually requested.

If @cancellable is non-%NULL, it can be used to cancel the
resolution. @callback will still be invoked in this case, with a
status of %SOUP_STATUS_CANCELLED.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="hostname" transfer-ownership="none">
            <doc xml:space="preserve">a hostname to be resolved</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">callback to call with the
    result, or %NULL</doc>
            <type name="AddressCallback" c:type="SoupAddressCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">data for @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="prepare_for_uri"
              c:identifier="soup_session_prepare_for_uri"
              version="2.30"
              deprecated="1"
              deprecated-version="2.38">
        <doc xml:space="preserve">Tells @session that @uri may be requested shortly, and so the
session can try to prepare (resolving the domain name, obtaining
proxy address, etc.) in order to work more quickly once the URI is
actually requested.</doc>
        <doc-deprecated xml:space="preserve">use soup_session_prefetch_dns() instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupURI which may be required</doc>
            <type name="URI" c:type="SoupURI*"/>
          </parameter>
        </parameters>
      </method>
      <method name="queue_message" c:identifier="soup_session_queue_message">
        <doc xml:space="preserve">Queues the message @msg for asynchronously sending the request and
receiving a response in the current thread-default #GMainContext.
If @msg has been processed before, any resources related to the
time it was last sent are freed.

Upon message completion, the callback specified in @callback will
be invoked. If after returning from this callback the message has not
been requeued, @msg will be unreffed.

(The behavior above applies to a plain #SoupSession; if you are
using #SoupSessionAsync or #SoupSessionSync, then the #GMainContext
that is used depends on the settings of #SoupSession:async-context
and #SoupSession:use-thread-context, and for #SoupSessionSync, the
message will actually be sent and processed in another thread, with
only the final callback occurring in the indicated #GMainContext.)

Contrast this method with soup_session_send_async(), which also
asynchronously sends a message, but returns before reading the
response body, and allows you to read the response via a
#GInputStream.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="full">
            <doc xml:space="preserve">the message to queue</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">a #SoupSessionCallback which will
be called after the message completes or when an unrecoverable error occurs.</doc>
            <type name="SessionCallback" c:type="SoupSessionCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a pointer passed to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="redirect_message"
              c:identifier="soup_session_redirect_message"
              version="2.38">
        <doc xml:space="preserve">Updates @msg's URI according to its status code and "Location"
header, and requeues it on @session. Use this when you have set
%SOUP_MESSAGE_NO_REDIRECT on a message, but have decided to allow a
particular redirection to occur, or if you want to allow a
redirection that #SoupSession will not perform automatically (eg,
redirecting a non-safe method such as DELETE).

If @msg's status code indicates that it should be retried as a GET
request, then @msg will be modified accordingly.

If @msg has already been redirected too many times, this will
cause it to fail with %SOUP_STATUS_TOO_MANY_REDIRECTS.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if a redirection was applied, %FALSE if not
(eg, because there was no Location header, or it could not be
parsed).</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">the session</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage that has received a 3xx response</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_feature"
              c:identifier="soup_session_remove_feature"
              version="2.24">
        <doc xml:space="preserve">Removes @feature's functionality from @session.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="feature" transfer-ownership="none">
            <doc xml:space="preserve">a feature that has previously been added to @session</doc>
            <type name="SessionFeature" c:type="SoupSessionFeature*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_feature_by_type"
              c:identifier="soup_session_remove_feature_by_type"
              version="2.24">
        <doc xml:space="preserve">Removes all features of type @feature_type (or any subclass of
@feature_type) from @session. You can also remove standard features
from the session at construct time by using the
%SOUP_SESSION_REMOVE_FEATURE_BY_TYPE property.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="feature_type" transfer-ownership="none">
            <doc xml:space="preserve">a #GType</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
      <method name="request"
              c:identifier="soup_session_request"
              version="2.42"
              throws="1">
        <doc xml:space="preserve">Creates a #SoupRequest for retrieving @uri_string.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #SoupRequest, or
  %NULL on error.</doc>
          <type name="Request" c:type="SoupRequest*"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="uri_string" transfer-ownership="none">
            <doc xml:space="preserve">a URI, in string form</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_http"
              c:identifier="soup_session_request_http"
              version="2.42"
              throws="1">
        <doc xml:space="preserve">Creates a #SoupRequest for retrieving @uri_string, which must be an
"http" or "https" URI (or another protocol listed in @session's
#SoupSession:http-aliases or #SoupSession:https-aliases).</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #SoupRequestHTTP, or
  %NULL on error.</doc>
          <type name="RequestHTTP" c:type="SoupRequestHTTP*"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="method" transfer-ownership="none">
            <doc xml:space="preserve">an HTTP method</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="uri_string" transfer-ownership="none">
            <doc xml:space="preserve">a URI, in string form</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_http_uri"
              c:identifier="soup_session_request_http_uri"
              version="2.42"
              throws="1">
        <doc xml:space="preserve">Creates a #SoupRequest for retrieving @uri, which must be an
"http" or "https" URI (or another protocol listed in @session's
#SoupSession:http-aliases or #SoupSession:https-aliases).</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #SoupRequestHTTP, or
  %NULL on error.</doc>
          <type name="RequestHTTP" c:type="SoupRequestHTTP*"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="method" transfer-ownership="none">
            <doc xml:space="preserve">an HTTP method</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupURI representing the URI to retrieve</doc>
            <type name="URI" c:type="SoupURI*"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_uri"
              c:identifier="soup_session_request_uri"
              version="2.42"
              throws="1">
        <doc xml:space="preserve">Creates a #SoupRequest for retrieving @uri.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #SoupRequest, or
  %NULL on error.</doc>
          <type name="Request" c:type="SoupRequest*"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupURI representing the URI to retrieve</doc>
            <type name="URI" c:type="SoupURI*"/>
          </parameter>
        </parameters>
      </method>
      <method name="requeue_message"
              c:identifier="soup_session_requeue_message">
        <doc xml:space="preserve">This causes @msg to be placed back on the queue to be attempted
again.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">the message to requeue</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
        </parameters>
      </method>
      <method name="send"
              c:identifier="soup_session_send"
              version="2.42"
              throws="1">
        <doc xml:space="preserve">Synchronously sends @msg and waits for the beginning of a response.
On success, a #GInputStream will be returned which you can use to
read the response body. ("Success" here means only that an HTTP
response was received and understood; it does not necessarily mean
that a 2xx class status code was received.)

If non-%NULL, @cancellable can be used to cancel the request;
soup_session_send() will return a %G_IO_ERROR_CANCELLED error. Note
that with requests that have side effects (eg,
&lt;literal&gt;POST&lt;/literal&gt;, &lt;literal&gt;PUT&lt;/literal&gt;,
&lt;literal&gt;DELETE&lt;/literal&gt;) it is possible that you might cancel the
request after the server acts on it, but before it returns a
response, leaving the remote resource in an unknown state.

If @msg is requeued due to a redirect or authentication, the
initial (3xx/401/407) response body will be suppressed, and
soup_session_send() will only return once a final response has been
received.

Contrast this method with soup_session_send_message(), which also
synchronously sends a #SoupMessage, but doesn't return until the
response has been completely read.

(Note that this method cannot be called on the deprecated
#SoupSessionAsync subclass.)</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GInputStream for reading the
  response body, or %NULL on error.</doc>
          <type name="Gio.InputStream" c:type="GInputStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_async"
              c:identifier="soup_session_send_async"
              version="2.42">
        <doc xml:space="preserve">Asynchronously sends @msg and waits for the beginning of a
response. When @callback is called, then either @msg has been sent,
and its response headers received, or else an error has occurred.
Call soup_session_send_finish() to get a #GInputStream for reading
the response body.

See soup_session_send() for more details on the general semantics.

Contrast this method with soup_session_queue_message(), which also
asynchronously sends a #SoupMessage, but doesn't invoke its
callback until the response has been completely read.

(Note that this method cannot be called on the deprecated
#SoupSessionSync subclass, and can only be called on
#SoupSessionAsync if you have set the
#SoupSession:use-thread-context property.)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">the callback to invoke</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">data for @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_finish"
              c:identifier="soup_session_send_finish"
              version="2.42"
              throws="1">
        <doc xml:space="preserve">Gets the response to a soup_session_send_async() call and (if
successful), returns a #GInputStream that can be used to read the
response body.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GInputStream for reading the
  response body, or %NULL on error.</doc>
          <type name="Gio.InputStream" c:type="GInputStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the #GAsyncResult passed to your callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_message" c:identifier="soup_session_send_message">
        <doc xml:space="preserve">Synchronously send @msg. This call will not return until the
transfer is finished successfully or there is an unrecoverable
error.

Unlike with soup_session_queue_message(), @msg is not freed upon
return.

(Note that if you call this method on a #SoupSessionAsync, it will
still use asynchronous I/O internally, running the glib main loop
to process the message, which may also cause other events to be
processed.)

Contrast this method with soup_session_send(), which also
synchronously sends a message, but returns before reading the
response body, and allows you to read the response via a
#GInputStream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the HTTP status code of the response</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">the message to send</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
        </parameters>
      </method>
      <method name="steal_connection"
              c:identifier="soup_session_steal_connection"
              version="2.50">
        <doc xml:space="preserve">"Steals" the HTTP connection associated with @msg from @session.
This happens immediately, regardless of the current state of the
connection, and @msg's callback will not be called. You can steal
the connection from a #SoupMessage signal handler if you need to
wait for part or all of the response to be received first.

Calling this function may cause @msg to be freed if you are not
holding any other reference to it.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the #GIOStream formerly associated
  with @msg (or %NULL if @msg was no longer associated with a
  connection). No guarantees are made about what kind of #GIOStream
  is returned.</doc>
          <type name="Gio.IOStream" c:type="GIOStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">the message whose connection is to be stolen</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unpause_message"
              c:identifier="soup_session_unpause_message">
        <doc xml:space="preserve">Resumes HTTP I/O on @msg. Use this to resume after calling
soup_session_pause_message().

If @msg is being sent via blocking I/O, this will resume reading or
writing immediately. If @msg is using non-blocking I/O, then
reading or writing won't resume until you return to the main loop.

This may only be called for asynchronous messages (those sent on a
#SoupSessionAsync or using soup_session_queue_message()).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage currently running on @session</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
        </parameters>
      </method>
      <method name="websocket_connect_async"
              c:identifier="soup_session_websocket_connect_async"
              version="2.50">
        <doc xml:space="preserve">Asynchronously creates a #SoupWebsocketConnection to communicate
with a remote server.

All necessary WebSocket-related headers will be added to @msg, and
it will then be sent and asynchronously processed normally
(including handling of redirection and HTTP authentication).

If the server returns "101 Switching Protocols", then @msg's status
code and response headers will be updated, and then the WebSocket
handshake will be completed. On success,
soup_websocket_connect_finish() will return a new
#SoupWebsocketConnection. On failure it will return a #GError.

If the server returns a status other than "101 Switching
Protocols", then @msg will contain the complete response headers
and body from the server's response, and
soup_websocket_connect_finish() will return
%SOUP_WEBSOCKET_ERROR_NOT_WEBSOCKET.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">#SoupMessage indicating the WebSocket server to connect to</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
          <parameter name="origin"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">origin of the connection</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="protocols"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a
  %NULL-terminated array of protocols supported</doc>
            <array c:type="char**">
              <type name="utf8" c:type="char*"/>
            </array>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="5">
            <doc xml:space="preserve">the callback to invoke</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">data for @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="websocket_connect_finish"
              c:identifier="soup_session_websocket_connect_finish"
              version="2.50"
              throws="1">
        <doc xml:space="preserve">Gets the #SoupWebsocketConnection response to a
soup_session_websocket_connect_async() call and (if successful),
returns a #SoupWebsockConnection that can be used to communicate
with the server.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #SoupWebsocketConnection, or
  %NULL on error.</doc>
          <type name="WebsocketConnection" c:type="SoupWebsocketConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the #GAsyncResult passed to your callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="would_redirect"
              c:identifier="soup_session_would_redirect"
              version="2.38">
        <doc xml:space="preserve">Checks if @msg contains a response that would cause @session to
redirect it to a new URL (ignoring @msg's %SOUP_MESSAGE_NO_REDIRECT
flag, and the number of times it has already been redirected).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether @msg would be redirected</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage that has response headers</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
        </parameters>
      </method>
      <property name="accept-language"
                version="2.30"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If non-%NULL, the value to use for the "Accept-Language" header
on #SoupMessage&lt;!-- --&gt;s sent from this session.

Setting this will disable
#SoupSession:accept-language-auto.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="accept-language-auto"
                version="2.30"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If %TRUE, #SoupSession will automatically set the string
for the "Accept-Language" header on every #SoupMessage
sent, based on the return value of g_get_language_names().

Setting this will override any previous value of
#SoupSession:accept-language.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="add-feature"
                version="2.24"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Add a feature object to the session. (Shortcut for calling
soup_session_add_feature().)</doc>
        <type name="SessionFeature"/>
      </property>
      <property name="add-feature-by-type"
                version="2.24"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Add a feature object of the given type to the session.
(Shortcut for calling soup_session_add_feature_by_type().)</doc>
        <type name="GType" c:type="GType"/>
      </property>
      <property name="async-context"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The #GMainContext that miscellaneous session-related
asynchronous callbacks are invoked on. (Eg, setting
#SoupSession:idle-timeout will add a timeout source on this
context.)

For a plain #SoupSession, this property is always set to
the #GMainContext that is the thread-default at the time
the session was created, and cannot be overridden. For the
deprecated #SoupSession subclasses, the default value is
%NULL, meaning to use the global default #GMainContext.

If #SoupSession:use-thread-context is %FALSE, this context
will also be used for asynchronous HTTP I/O.</doc>
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <property name="http-aliases"
                version="2.38"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">A %NULL-terminated array of URI schemes that should be
considered to be aliases for "http". Eg, if this included
&lt;literal&gt;"dav"&lt;/literal&gt;, than a URI of
&lt;literal&gt;dav://example.com/path&lt;/literal&gt; would be treated
identically to &lt;literal&gt;http://example.com/path&lt;/literal&gt;.

In a plain #SoupSession, the default value is %NULL,
meaning that only "http" is recognized as meaning "http".
In #SoupSessionAsync and #SoupSessionSync, for backward
compatibility, the default value is an array containing the
single element &lt;literal&gt;"*"&lt;/literal&gt;, a special value
which means that any scheme except "https" is considered to
be an alias for "http".

See also #SoupSession:https-aliases.</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <property name="https-aliases"
                version="2.38"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">A comma-delimited list of URI schemes that should be
considered to be aliases for "https". See
#SoupSession:http-aliases for more information.

The default value is %NULL, meaning that no URI schemes
are considered aliases for "https".</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <property name="idle-timeout"
                version="2.24"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Connection lifetime (in seconds) when idle. Any connection
left idle longer than this will be closed.

Although you can change this property at any time, it will
only affect newly-created connections, not currently-open
ones. You can call soup_session_abort() after setting this
if you want to ensure that all future connections will have
this timeout value.

Note that the default value of 60 seconds only applies to
plain #SoupSessions. If you are using #SoupSessionAsync or
#SoupSessionSync, the default value is 0 (meaning idle
connections will never time out).</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="local-address"
                version="2.42"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Sets the #SoupAddress to use for the client side of
the connection.

Use this property if you want for instance to bind the
local socket to a specific IP address.</doc>
        <type name="Address"/>
      </property>
      <property name="max-conns" writable="1" transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="max-conns-per-host"
                writable="1"
                transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="proxy-resolver"
                version="2.42"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">A #GProxyResolver to use with this session. Setting this
will clear the #SoupSession:proxy-uri property, and remove
any &lt;type&gt;SoupProxyURIResolver&lt;/type&gt; features that have
been added to the session.

By default, in a plain #SoupSession, this is set to the
default #GProxyResolver, but you can set it to %NULL if you
don't want to use proxies, or set it to your own
#GProxyResolver if you want to control what proxies get
used.</doc>
        <type name="Gio.ProxyResolver"/>
      </property>
      <property name="proxy-uri" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">A proxy to use for all http and https requests in this
session. Setting this will clear the
#SoupSession:proxy-resolver property, and remove any
&lt;type&gt;SoupProxyURIResolver&lt;/type&gt; features that have been
added to the session. Setting this property will also
cancel all currently pending messages.

Note that #SoupSession will normally handle looking up the
user's proxy settings for you; you should only use
#SoupSession:proxy-uri if you need to override the user's
normal proxy settings.

Also note that this proxy will be used for
&lt;emphasis&gt;all&lt;/emphasis&gt; requests; even requests to
&lt;literal&gt;localhost&lt;/literal&gt;. If you need more control over
proxies, you can create a #GSimpleProxyResolver and set the
#SoupSession:proxy-resolver property.</doc>
        <type name="URI"/>
      </property>
      <property name="remove-feature-by-type"
                version="2.24"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Remove feature objects from the session. (Shortcut for
calling soup_session_remove_feature_by_type().)</doc>
        <type name="GType" c:type="GType"/>
      </property>
      <property name="ssl-ca-file"
                deprecated="1"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">File containing SSL CA certificates.

If the specified file does not exist or cannot be read,
then libsoup will print a warning, and then behave as
though it had read in a empty CA file, meaning that all SSL
certificates will be considered invalid.</doc>
        <doc-deprecated xml:space="preserve">use #SoupSession:ssl-use-system-ca-file, or
else #SoupSession:tls-database with a #GTlsFileDatabase
(which allows you to do explicit error handling).</doc-deprecated>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="ssl-strict"
                version="2.30"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Normally, if #SoupSession:tls-database is set (including if
it was set via #SoupSession:ssl-use-system-ca-file or
#SoupSession:ssl-ca-file), then libsoup will reject any
certificate that is invalid (ie, expired) or that is not
signed by one of the given CA certificates, and the
#SoupMessage will fail with the status
%SOUP_STATUS_SSL_FAILED.

If you set #SoupSession:ssl-strict to %FALSE, then all
certificates will be accepted, and you will need to call
soup_message_get_https_status() to distinguish valid from
invalid certificates. (This can be used, eg, if you want to
accept invalid certificates after giving some sort of
warning.)

For a plain #SoupSession, if the session has no CA file or
TLS database, and this property is %TRUE, then all
certificates will be rejected. However, beware that the
deprecated #SoupSession subclasses (#SoupSessionAsync and
#SoupSessionSync) have the opposite behavior: if there is
no CA file or TLS database, then all certificates are always
accepted, and this property has no effect.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="ssl-use-system-ca-file"
                version="2.38"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Setting this to %TRUE is equivalent to setting
#SoupSession:tls-database to the default system CA database.
(and likewise, setting #SoupSession:tls-database to the
default database by hand will cause this property to
become %TRUE).

Setting this to %FALSE (when it was previously %TRUE) will
clear the #SoupSession:tls-database field.

See #SoupSession:ssl-strict for more information on how
https certificate validation is handled.

Note that the default value of %TRUE only applies to plain
#SoupSessions. If you are using #SoupSessionAsync or
#SoupSessionSync, the default value is %FALSE, for backward
compatibility.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="timeout" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The timeout (in seconds) for socket I/O operations
(including connecting to a server, and waiting for a reply
to an HTTP request).

Although you can change this property at any time, it will
only affect newly-created connections, not currently-open
ones. You can call soup_session_abort() after setting this
if you want to ensure that all future connections will have
this timeout value.

Note that the default value of 60 seconds only applies to
plain #SoupSessions. If you are using #SoupSessionAsync or
#SoupSessionSync, the default value is 0 (meaning socket I/O
will not time out).

Not to be confused with #SoupSession:idle-timeout (which is
the length of time that idle persistent connections will be
kept open).</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="tls-database"
                version="2.38"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Sets the #GTlsDatabase to use for validating SSL/TLS
certificates.

Note that setting the #SoupSession:ssl-ca-file or
#SoupSession:ssl-use-system-ca-file property will cause
this property to be set to a #GTlsDatabase corresponding to
the indicated file or system default.

See #SoupSession:ssl-strict for more information on how
https certificate validation is handled.

If you are using a plain #SoupSession then
#SoupSession:ssl-use-system-ca-file will be %TRUE by
default, and so this property will be a copy of the system
CA database. If you are using #SoupSessionAsync or
#SoupSessionSync, this property will be %NULL by default.</doc>
        <type name="Gio.TlsDatabase"/>
      </property>
      <property name="tls-interaction"
                version="2.48"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">A #GTlsInteraction object that will be passed on to any
#GTlsConnections created by the session. (This can be used to
provide client-side certificates, for example.)</doc>
        <type name="Gio.TlsInteraction"/>
      </property>
      <property name="use-ntlm"
                deprecated="1"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Whether or not to use NTLM authentication.</doc>
        <doc-deprecated xml:space="preserve">use soup_session_add_feature_by_type() with
#SOUP_TYPE_AUTH_NTLM.</doc-deprecated>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="use-thread-context"
                version="2.38"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If %TRUE (which it always is on a plain #SoupSession),
asynchronous HTTP requests in this session will run in
whatever the thread-default #GMainContext is at the time
they are started, rather than always occurring in
#SoupSession:async-context.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="user-agent" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">If non-%NULL, the value to use for the "User-Agent" header
on #SoupMessage&lt;!-- --&gt;s sent from this session.

RFC 2616 says: "The User-Agent request-header field
contains information about the user agent originating the
request. This is for statistical purposes, the tracing of
protocol violations, and automated recognition of user
agents for the sake of tailoring responses to avoid
particular user agent limitations. User agents SHOULD
include this field with requests."

The User-Agent header contains a list of one or more
product tokens, separated by whitespace, with the most
significant product token coming first. The tokens must be
brief, ASCII, and mostly alphanumeric (although "-", "_",
and "." are also allowed), and may optionally include a "/"
followed by a version string. You may also put comments,
enclosed in parentheses, between or after the tokens.

If you set a #SoupSession:user_agent property that has trailing
whitespace, #SoupSession will append its own product token
(eg, "&lt;literal&gt;libsoup/2.3.2&lt;/literal&gt;") to the end of the
header for you.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <glib:signal name="authenticate" when="first">
        <doc xml:space="preserve">Emitted when the session requires authentication. If
credentials are available call soup_auth_authenticate() on
@auth. If these credentials fail, the signal will be
emitted again, with @retrying set to %TRUE, which will
continue until you return without calling
soup_auth_authenticate() on @auth.

Note that this may be emitted before @msg's body has been
fully read.

If you call soup_session_pause_message() on @msg before
returning, then you can authenticate @auth asynchronously
(as long as you g_object_ref() it to make sure it doesn't
get destroyed), and then unpause @msg when you are ready
for it to continue.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">the #SoupMessage being sent</doc>
            <type name="Message"/>
          </parameter>
          <parameter name="auth" transfer-ownership="none">
            <doc xml:space="preserve">the #SoupAuth to authenticate</doc>
            <type name="Auth"/>
          </parameter>
          <parameter name="retrying" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if this is the second (or later) attempt</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="connection-created" when="first" version="2.30">
        <doc xml:space="preserve">Emitted when a new connection is created. This is an
internal signal intended only to be used for debugging
purposes, and may go away in the future.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the connection</doc>
            <type name="GObject.Object"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="request-queued" when="first" version="2.24">
        <doc xml:space="preserve">Emitted when a request is queued on @session. (Note that
"queued" doesn't just mean soup_session_queue_message();
soup_session_send_message() implicitly queues the message
as well.)

When sending a request, first #SoupSession::request_queued
is emitted, indicating that the session has become aware of
the request.

Once a connection is available to send the request on, the
session emits #SoupSession::request_started. Then, various
#SoupMessage signals are emitted as the message is
processed. If the message is requeued, it will emit
#SoupMessage::restarted, which will then be followed by
another #SoupSession::request_started and another set of
#SoupMessage signals when the message is re-sent.

Eventually, the message will emit #SoupMessage::finished.
Normally, this signals the completion of message
processing. However, it is possible that the application
will requeue the message from the "finished" handler (or
equivalently, from the soup_session_queue_message()
callback). In that case, the process will loop back to
#SoupSession::request_started.

Eventually, a message will reach "finished" and not be
requeued. At that point, the session will emit
#SoupSession::request_unqueued to indicate that it is done
with the message.

To sum up: #SoupSession::request_queued and
#SoupSession::request_unqueued are guaranteed to be emitted
exactly once, but #SoupSession::request_started and
#SoupMessage::finished (and all of the other #SoupMessage
signals) may be invoked multiple times for a given message.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">the request that was queued</doc>
            <type name="Message"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="request-started"
                   when="first"
                   deprecated="1"
                   deprecated-version="2.50.">
        <doc xml:space="preserve">Emitted just before a request is sent. See
#SoupSession::request_queued for a detailed description of
the message lifecycle within a session.</doc>
        <doc-deprecated xml:space="preserve">Use #SoupMessage::starting instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">the request being sent</doc>
            <type name="Message"/>
          </parameter>
          <parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">the socket the request is being sent on</doc>
            <type name="Socket"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="request-unqueued" when="first" version="2.24">
        <doc xml:space="preserve">Emitted when a request is removed from @session's queue,
indicating that @session is done with it. See
#SoupSession::request_queued for a detailed description of the
message lifecycle within a session.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">the request that was unqueued</doc>
            <type name="Message"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="tunneling" when="first" version="2.30">
        <doc xml:space="preserve">Emitted when an SSL tunnel is being created on a proxy
connection. This is an internal signal intended only to be
used for debugging purposes, and may go away in the future.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the connection</doc>
            <type name="GObject.Object"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <class name="SessionAsync"
           c:symbol-prefix="session_async"
           c:type="SoupSessionAsync"
           parent="Session"
           glib:type-name="SoupSessionAsync"
           glib:get-type="soup_session_async_get_type"
           glib:type-struct="SessionAsyncClass">
      <constructor name="new"
                   c:identifier="soup_session_async_new"
                   deprecated="1">
        <doc xml:space="preserve">Creates an asynchronous #SoupSession with the default options.</doc>
        <doc-deprecated xml:space="preserve">#SoupSessionAsync is deprecated; use a plain
#SoupSession, created with soup_session_new(). See the &lt;link
linkend="libsoup-session-porting"&gt;porting guide&lt;/link&gt;.</doc-deprecated>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new session.</doc>
          <type name="Session" c:type="SoupSession*"/>
        </return-value>
      </constructor>
      <constructor name="new_with_options"
                   c:identifier="soup_session_async_new_with_options"
                   introspectable="0"
                   deprecated="1">
        <doc xml:space="preserve">Creates an asynchronous #SoupSession with the specified options.</doc>
        <doc-deprecated xml:space="preserve">#SoupSessionAsync is deprecated; use a plain
#SoupSession, created with soup_session_new_with_options(). See the
&lt;link linkend="libsoup-session-porting"&gt;porting guide&lt;/link&gt;.</doc-deprecated>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new session.</doc>
          <type name="Session" c:type="SoupSession*"/>
        </return-value>
        <parameters>
          <parameter name="optname1" transfer-ownership="none">
            <doc xml:space="preserve">name of first property to set</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">value of @optname1, followed by additional property/value pairs</doc>
            <varargs/>
          </parameter>
        </parameters>
      </constructor>
      <field name="parent">
        <type name="Session" c:type="SoupSession"/>
      </field>
    </class>
    <record name="SessionAsyncClass"
            c:type="SoupSessionAsyncClass"
            glib:is-gtype-struct-for="SessionAsync">
      <field name="parent_class">
        <type name="SessionClass" c:type="SoupSessionClass"/>
      </field>
      <field name="_libsoup_reserved1" introspectable="0">
        <callback name="_libsoup_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_libsoup_reserved2" introspectable="0">
        <callback name="_libsoup_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_libsoup_reserved3" introspectable="0">
        <callback name="_libsoup_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_libsoup_reserved4" introspectable="0">
        <callback name="_libsoup_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <callback name="SessionCallback" c:type="SoupSessionCallback">
      <doc xml:space="preserve">Prototype for the callback passed to soup_session_queue_message(),
qv.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="session" transfer-ownership="none">
          <doc xml:space="preserve">the session</doc>
          <type name="Session" c:type="SoupSession*"/>
        </parameter>
        <parameter name="msg" transfer-ownership="none">
          <doc xml:space="preserve">the message that has finished</doc>
          <type name="Message" c:type="SoupMessage*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:space="preserve">the data passed to soup_session_queue_message</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="SessionClass"
            c:type="SoupSessionClass"
            glib:is-gtype-struct-for="Session">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="request_started">
        <callback name="request_started">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="session" transfer-ownership="none">
              <type name="Session" c:type="SoupSession*"/>
            </parameter>
            <parameter name="msg" transfer-ownership="none">
              <type name="Message" c:type="SoupMessage*"/>
            </parameter>
            <parameter name="socket" transfer-ownership="none">
              <type name="Socket" c:type="SoupSocket*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="authenticate">
        <callback name="authenticate">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="session" transfer-ownership="none">
              <type name="Session" c:type="SoupSession*"/>
            </parameter>
            <parameter name="msg" transfer-ownership="none">
              <type name="Message" c:type="SoupMessage*"/>
            </parameter>
            <parameter name="auth" transfer-ownership="none">
              <type name="Auth" c:type="SoupAuth*"/>
            </parameter>
            <parameter name="retrying" transfer-ownership="none">
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="queue_message">
        <callback name="queue_message">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="session" transfer-ownership="none">
              <doc xml:space="preserve">a #SoupSession</doc>
              <type name="Session" c:type="SoupSession*"/>
            </parameter>
            <parameter name="msg" transfer-ownership="full">
              <doc xml:space="preserve">the message to queue</doc>
              <type name="Message" c:type="SoupMessage*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1"
                       scope="async"
                       closure="3">
              <doc xml:space="preserve">a #SoupSessionCallback which will
be called after the message completes or when an unrecoverable error occurs.</doc>
              <type name="SessionCallback" c:type="SoupSessionCallback"/>
            </parameter>
            <parameter name="user_data"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1"
                       closure="3">
              <doc xml:space="preserve">a pointer passed to @callback.</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="requeue_message">
        <callback name="requeue_message">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="session" transfer-ownership="none">
              <doc xml:space="preserve">a #SoupSession</doc>
              <type name="Session" c:type="SoupSession*"/>
            </parameter>
            <parameter name="msg" transfer-ownership="none">
              <doc xml:space="preserve">the message to requeue</doc>
              <type name="Message" c:type="SoupMessage*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="send_message">
        <callback name="send_message">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the HTTP status code of the response</doc>
            <type name="guint" c:type="guint"/>
          </return-value>
          <parameters>
            <parameter name="session" transfer-ownership="none">
              <doc xml:space="preserve">a #SoupSession</doc>
              <type name="Session" c:type="SoupSession*"/>
            </parameter>
            <parameter name="msg" transfer-ownership="none">
              <doc xml:space="preserve">the message to send</doc>
              <type name="Message" c:type="SoupMessage*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="cancel_message">
        <callback name="cancel_message">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="session" transfer-ownership="none">
              <doc xml:space="preserve">a #SoupSession</doc>
              <type name="Session" c:type="SoupSession*"/>
            </parameter>
            <parameter name="msg" transfer-ownership="none">
              <doc xml:space="preserve">the message to cancel</doc>
              <type name="Message" c:type="SoupMessage*"/>
            </parameter>
            <parameter name="status_code" transfer-ownership="none">
              <doc xml:space="preserve">status code to set on @msg (generally
%SOUP_STATUS_CANCELLED)</doc>
              <type name="guint" c:type="guint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="auth_required">
        <callback name="auth_required">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="session" transfer-ownership="none">
              <type name="Session" c:type="SoupSession*"/>
            </parameter>
            <parameter name="msg" transfer-ownership="none">
              <type name="Message" c:type="SoupMessage*"/>
            </parameter>
            <parameter name="auth" transfer-ownership="none">
              <type name="Auth" c:type="SoupAuth*"/>
            </parameter>
            <parameter name="retrying" transfer-ownership="none">
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="flush_queue">
        <callback name="flush_queue">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="session" transfer-ownership="none">
              <type name="Session" c:type="SoupSession*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="kick">
        <callback name="kick">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="session" transfer-ownership="none">
              <type name="Session" c:type="SoupSession*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_libsoup_reserved4" introspectable="0">
        <callback name="_libsoup_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <interface name="SessionFeature"
               c:symbol-prefix="session_feature"
               c:type="SoupSessionFeature"
               version="2.24"
               glib:type-name="SoupSessionFeature"
               glib:get-type="soup_session_feature_get_type"
               glib:type-struct="SessionFeatureInterface">
      <doc xml:space="preserve">An object that implement some sort of optional feature for
#SoupSession.</doc>
      <virtual-method name="add_feature" invoker="add_feature" version="2.34">
        <doc xml:space="preserve">Adds a "sub-feature" of type @type to the base feature @feature.
This is used for features that can be extended with multiple
different types. Eg, the authentication manager can be extended
with subtypes of #SoupAuth.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @feature accepted @type as a subfeature.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="feature" transfer-ownership="none">
            <doc xml:space="preserve">the "base" feature</doc>
            <type name="SessionFeature" c:type="SoupSessionFeature*"/>
          </instance-parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">the #GType of a "sub-feature"</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="attach" invoker="attach">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="feature" transfer-ownership="none">
            <type name="SessionFeature" c:type="SoupSessionFeature*"/>
          </instance-parameter>
          <parameter name="session" transfer-ownership="none">
            <type name="Session" c:type="SoupSession*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="detach" invoker="detach">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="feature" transfer-ownership="none">
            <type name="SessionFeature" c:type="SoupSessionFeature*"/>
          </instance-parameter>
          <parameter name="session" transfer-ownership="none">
            <type name="Session" c:type="SoupSession*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="has_feature" invoker="has_feature" version="2.34">
        <doc xml:space="preserve">Tests if @feature has a "sub-feature" of type @type. See
soup_session_feature_add_feature().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @feature has a subfeature of type @type</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="feature" transfer-ownership="none">
            <doc xml:space="preserve">the "base" feature</doc>
            <type name="SessionFeature" c:type="SoupSessionFeature*"/>
          </instance-parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">the #GType of a "sub-feature"</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="remove_feature"
                      invoker="remove_feature"
                      version="2.34">
        <doc xml:space="preserve">Removes the "sub-feature" of type @type from the base feature
@feature. See soup_session_feature_add_feature().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @type was removed from @feature</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="feature" transfer-ownership="none">
            <doc xml:space="preserve">the "base" feature</doc>
            <type name="SessionFeature" c:type="SoupSessionFeature*"/>
          </instance-parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">the #GType of a "sub-feature"</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="request_queued">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="feature" transfer-ownership="none">
            <type name="SessionFeature" c:type="SoupSessionFeature*"/>
          </instance-parameter>
          <parameter name="session" transfer-ownership="none">
            <type name="Session" c:type="SoupSession*"/>
          </parameter>
          <parameter name="msg" transfer-ownership="none">
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="request_started">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="feature" transfer-ownership="none">
            <type name="SessionFeature" c:type="SoupSessionFeature*"/>
          </instance-parameter>
          <parameter name="session" transfer-ownership="none">
            <type name="Session" c:type="SoupSession*"/>
          </parameter>
          <parameter name="msg" transfer-ownership="none">
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
          <parameter name="socket" transfer-ownership="none">
            <type name="Socket" c:type="SoupSocket*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="request_unqueued">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="feature" transfer-ownership="none">
            <type name="SessionFeature" c:type="SoupSessionFeature*"/>
          </instance-parameter>
          <parameter name="session" transfer-ownership="none">
            <type name="Session" c:type="SoupSession*"/>
          </parameter>
          <parameter name="msg" transfer-ownership="none">
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="add_feature"
              c:identifier="soup_session_feature_add_feature"
              version="2.34">
        <doc xml:space="preserve">Adds a "sub-feature" of type @type to the base feature @feature.
This is used for features that can be extended with multiple
different types. Eg, the authentication manager can be extended
with subtypes of #SoupAuth.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @feature accepted @type as a subfeature.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="feature" transfer-ownership="none">
            <doc xml:space="preserve">the "base" feature</doc>
            <type name="SessionFeature" c:type="SoupSessionFeature*"/>
          </instance-parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">the #GType of a "sub-feature"</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
      <method name="attach" c:identifier="soup_session_feature_attach">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="feature" transfer-ownership="none">
            <type name="SessionFeature" c:type="SoupSessionFeature*"/>
          </instance-parameter>
          <parameter name="session" transfer-ownership="none">
            <type name="Session" c:type="SoupSession*"/>
          </parameter>
        </parameters>
      </method>
      <method name="detach" c:identifier="soup_session_feature_detach">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="feature" transfer-ownership="none">
            <type name="SessionFeature" c:type="SoupSessionFeature*"/>
          </instance-parameter>
          <parameter name="session" transfer-ownership="none">
            <type name="Session" c:type="SoupSession*"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_feature"
              c:identifier="soup_session_feature_has_feature"
              version="2.34">
        <doc xml:space="preserve">Tests if @feature has a "sub-feature" of type @type. See
soup_session_feature_add_feature().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @feature has a subfeature of type @type</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="feature" transfer-ownership="none">
            <doc xml:space="preserve">the "base" feature</doc>
            <type name="SessionFeature" c:type="SoupSessionFeature*"/>
          </instance-parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">the #GType of a "sub-feature"</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_feature"
              c:identifier="soup_session_feature_remove_feature"
              version="2.34">
        <doc xml:space="preserve">Removes the "sub-feature" of type @type from the base feature
@feature. See soup_session_feature_add_feature().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @type was removed from @feature</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="feature" transfer-ownership="none">
            <doc xml:space="preserve">the "base" feature</doc>
            <type name="SessionFeature" c:type="SoupSessionFeature*"/>
          </instance-parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">the #GType of a "sub-feature"</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
    </interface>
    <record name="SessionFeatureInterface"
            c:type="SoupSessionFeatureInterface"
            glib:is-gtype-struct-for="SessionFeature"
            version="2.24">
      <doc xml:space="preserve">The interface implemented by #SoupSessionFeature&lt;!-- --&gt;s.</doc>
      <field name="parent">
        <doc xml:space="preserve">The parent interface.</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="attach">
        <callback name="attach">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="feature" transfer-ownership="none">
              <type name="SessionFeature" c:type="SoupSessionFeature*"/>
            </parameter>
            <parameter name="session" transfer-ownership="none">
              <type name="Session" c:type="SoupSession*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="detach">
        <callback name="detach">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="feature" transfer-ownership="none">
              <type name="SessionFeature" c:type="SoupSessionFeature*"/>
            </parameter>
            <parameter name="session" transfer-ownership="none">
              <type name="Session" c:type="SoupSession*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="request_queued">
        <callback name="request_queued">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="feature" transfer-ownership="none">
              <type name="SessionFeature" c:type="SoupSessionFeature*"/>
            </parameter>
            <parameter name="session" transfer-ownership="none">
              <type name="Session" c:type="SoupSession*"/>
            </parameter>
            <parameter name="msg" transfer-ownership="none">
              <type name="Message" c:type="SoupMessage*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="request_started">
        <callback name="request_started">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="feature" transfer-ownership="none">
              <type name="SessionFeature" c:type="SoupSessionFeature*"/>
            </parameter>
            <parameter name="session" transfer-ownership="none">
              <type name="Session" c:type="SoupSession*"/>
            </parameter>
            <parameter name="msg" transfer-ownership="none">
              <type name="Message" c:type="SoupMessage*"/>
            </parameter>
            <parameter name="socket" transfer-ownership="none">
              <type name="Socket" c:type="SoupSocket*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="request_unqueued">
        <callback name="request_unqueued">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="feature" transfer-ownership="none">
              <type name="SessionFeature" c:type="SoupSessionFeature*"/>
            </parameter>
            <parameter name="session" transfer-ownership="none">
              <type name="Session" c:type="SoupSession*"/>
            </parameter>
            <parameter name="msg" transfer-ownership="none">
              <type name="Message" c:type="SoupMessage*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="add_feature">
        <callback name="add_feature">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if @feature accepted @type as a subfeature.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="feature" transfer-ownership="none">
              <doc xml:space="preserve">the "base" feature</doc>
              <type name="SessionFeature" c:type="SoupSessionFeature*"/>
            </parameter>
            <parameter name="type" transfer-ownership="none">
              <doc xml:space="preserve">the #GType of a "sub-feature"</doc>
              <type name="GType" c:type="GType"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="remove_feature">
        <callback name="remove_feature">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if @type was removed from @feature</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="feature" transfer-ownership="none">
              <doc xml:space="preserve">the "base" feature</doc>
              <type name="SessionFeature" c:type="SoupSessionFeature*"/>
            </parameter>
            <parameter name="type" transfer-ownership="none">
              <doc xml:space="preserve">the #GType of a "sub-feature"</doc>
              <type name="GType" c:type="GType"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="has_feature">
        <callback name="has_feature">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if @feature has a subfeature of type @type</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="feature" transfer-ownership="none">
              <doc xml:space="preserve">the "base" feature</doc>
              <type name="SessionFeature" c:type="SoupSessionFeature*"/>
            </parameter>
            <parameter name="type" transfer-ownership="none">
              <doc xml:space="preserve">the #GType of a "sub-feature"</doc>
              <type name="GType" c:type="GType"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <class name="SessionSync"
           c:symbol-prefix="session_sync"
           c:type="SoupSessionSync"
           parent="Session"
           glib:type-name="SoupSessionSync"
           glib:get-type="soup_session_sync_get_type"
           glib:type-struct="SessionSyncClass">
      <constructor name="new"
                   c:identifier="soup_session_sync_new"
                   deprecated="1">
        <doc xml:space="preserve">Creates an synchronous #SoupSession with the default options.</doc>
        <doc-deprecated xml:space="preserve">#SoupSessionSync is deprecated; use a plain
#SoupSession, created with soup_session_new(). See the &lt;link
linkend="libsoup-session-porting"&gt;porting guide&lt;/link&gt;.</doc-deprecated>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new session.</doc>
          <type name="Session" c:type="SoupSession*"/>
        </return-value>
      </constructor>
      <constructor name="new_with_options"
                   c:identifier="soup_session_sync_new_with_options"
                   introspectable="0"
                   deprecated="1">
        <doc xml:space="preserve">Creates an synchronous #SoupSession with the specified options.</doc>
        <doc-deprecated xml:space="preserve">#SoupSessionSync is deprecated; use a plain
#SoupSession, created with soup_session_new_with_options(). See the
&lt;link linkend="libsoup-session-porting"&gt;porting guide&lt;/link&gt;.</doc-deprecated>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new session.</doc>
          <type name="Session" c:type="SoupSession*"/>
        </return-value>
        <parameters>
          <parameter name="optname1" transfer-ownership="none">
            <doc xml:space="preserve">name of first property to set</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">value of @optname1, followed by additional property/value pairs</doc>
            <varargs/>
          </parameter>
        </parameters>
      </constructor>
      <field name="parent">
        <type name="Session" c:type="SoupSession"/>
      </field>
    </class>
    <record name="SessionSyncClass"
            c:type="SoupSessionSyncClass"
            glib:is-gtype-struct-for="SessionSync">
      <field name="parent_class">
        <type name="SessionClass" c:type="SoupSessionClass"/>
      </field>
      <field name="_libsoup_reserved1" introspectable="0">
        <callback name="_libsoup_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_libsoup_reserved2" introspectable="0">
        <callback name="_libsoup_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_libsoup_reserved3" introspectable="0">
        <callback name="_libsoup_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_libsoup_reserved4" introspectable="0">
        <callback name="_libsoup_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <class name="Socket"
           c:symbol-prefix="socket"
           c:type="SoupSocket"
           parent="GObject.Object"
           glib:type-name="SoupSocket"
           glib:get-type="soup_socket_get_type"
           glib:type-struct="SocketClass">
      <implements name="Gio.Initable"/>
      <constructor name="new"
                   c:identifier="soup_socket_new"
                   introspectable="0">
        <doc xml:space="preserve">Creates a new (disconnected) socket</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new socket</doc>
          <type name="Socket" c:type="SoupSocket*"/>
        </return-value>
        <parameters>
          <parameter name="optname1" transfer-ownership="none">
            <doc xml:space="preserve">name of first property to set (or %NULL)</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">value of @optname1, followed by additional property/value pairs</doc>
            <varargs/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="disconnected">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sock" transfer-ownership="none">
            <type name="Socket" c:type="SoupSocket*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="new_connection">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="listener" transfer-ownership="none">
            <type name="Socket" c:type="SoupSocket*"/>
          </instance-parameter>
          <parameter name="new_sock" transfer-ownership="none">
            <type name="Socket" c:type="SoupSocket*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="readable">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sock" transfer-ownership="none">
            <type name="Socket" c:type="SoupSocket*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="writable">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sock" transfer-ownership="none">
            <type name="Socket" c:type="SoupSocket*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="connect_async" c:identifier="soup_socket_connect_async">
        <doc xml:space="preserve">Begins asynchronously connecting to @sock's remote address. The
socket will call @callback when it succeeds or fails (but not
before returning from this function).

If @cancellable is non-%NULL, it can be used to cancel the
connection. @callback will still be invoked in this case, with a
status of %SOUP_STATUS_CANCELLED.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sock" transfer-ownership="none">
            <doc xml:space="preserve">a client #SoupSocket (which must not already be connected)</doc>
            <type name="Socket" c:type="SoupSocket*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">callback to call after connecting</doc>
            <type name="SocketCallback" c:type="SoupSocketCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="connect_sync" c:identifier="soup_socket_connect_sync">
        <doc xml:space="preserve">Attempt to synchronously connect @sock to its remote address.

If @cancellable is non-%NULL, it can be used to cancel the
connection, in which case soup_socket_connect_sync() will return
%SOUP_STATUS_CANCELLED.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a success or failure code.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="sock" transfer-ownership="none">
            <doc xml:space="preserve">a client #SoupSocket (which must not already be connected)</doc>
            <type name="Socket" c:type="SoupSocket*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="disconnect" c:identifier="soup_socket_disconnect">
        <doc xml:space="preserve">Disconnects @sock. Any further read or write attempts on it will
fail.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sock" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSocket</doc>
            <type name="Socket" c:type="SoupSocket*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_fd" c:identifier="soup_socket_get_fd">
        <doc xml:space="preserve">Gets @sock's underlying file descriptor.

Note that fiddling with the file descriptor may break the
#SoupSocket.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@sock's file descriptor.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="sock" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSocket</doc>
            <type name="Socket" c:type="SoupSocket*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_local_address"
              c:identifier="soup_socket_get_local_address">
        <doc xml:space="preserve">Returns the #SoupAddress corresponding to the local end of @sock.

Calling this method on an unconnected socket is considered to be
an error, and produces undefined results.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #SoupAddress</doc>
          <type name="Address" c:type="SoupAddress*"/>
        </return-value>
        <parameters>
          <instance-parameter name="sock" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSocket</doc>
            <type name="Socket" c:type="SoupSocket*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_remote_address"
              c:identifier="soup_socket_get_remote_address">
        <doc xml:space="preserve">Returns the #SoupAddress corresponding to the remote end of @sock.

Calling this method on an unconnected socket is considered to be
an error, and produces undefined results.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #SoupAddress</doc>
          <type name="Address" c:type="SoupAddress*"/>
        </return-value>
        <parameters>
          <instance-parameter name="sock" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSocket</doc>
            <type name="Socket" c:type="SoupSocket*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_connected" c:identifier="soup_socket_is_connected">
        <doc xml:space="preserve">Tests if @sock is connected to another host</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE or %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="sock" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSocket</doc>
            <type name="Socket" c:type="SoupSocket*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_ssl" c:identifier="soup_socket_is_ssl">
        <doc xml:space="preserve">Tests if @sock is doing (or has attempted to do) SSL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @sock has SSL credentials set</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="sock" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSocket</doc>
            <type name="Socket" c:type="SoupSocket*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="listen" c:identifier="soup_socket_listen">
        <doc xml:space="preserve">Makes @sock start listening on its local address. When connections
come in, @sock will emit #SoupSocket::new_connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether or not @sock is now listening.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="sock" transfer-ownership="none">
            <doc xml:space="preserve">a server #SoupSocket (which must not already be connected or
listening)</doc>
            <type name="Socket" c:type="SoupSocket*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="read" c:identifier="soup_socket_read" throws="1">
        <doc xml:space="preserve">Attempts to read up to @len bytes from @sock into @buffer. If some
data is successfully read, soup_socket_read() will return
%SOUP_SOCKET_OK, and *@nread will contain the number of bytes
actually read (which may be less than @len).

If @sock is non-blocking, and no data is available, the return
value will be %SOUP_SOCKET_WOULD_BLOCK. In this case, the caller
can connect to the #SoupSocket::readable signal to know when there
is more data to read. (NB: You MUST read all available data off the
socket first. #SoupSocket::readable is only emitted after
soup_socket_read() returns %SOUP_SOCKET_WOULD_BLOCK, and it is only
emitted once. See the documentation for #SoupSocket:non-blocking.)</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #SoupSocketIOStatus, as described above (or
%SOUP_SOCKET_EOF if the socket is no longer connected, or
%SOUP_SOCKET_ERROR on any other error, in which case @error will
also be set).</doc>
          <type name="SocketIOStatus" c:type="SoupSocketIOStatus"/>
        </return-value>
        <parameters>
          <instance-parameter name="sock" transfer-ownership="none">
            <doc xml:space="preserve">the socket</doc>
            <type name="Socket" c:type="SoupSocket*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">buffer to read
  into</doc>
            <array length="1" zero-terminated="0" c:type="gpointer">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">size of @buffer in bytes</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="nread"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">on return, the number of bytes read into @buffer</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_until"
              c:identifier="soup_socket_read_until"
              throws="1">
        <doc xml:space="preserve">Like soup_socket_read(), but reads no further than the first
occurrence of @boundary. (If the boundary is found, it will be
included in the returned data, and *@got_boundary will be set to
%TRUE.) Any data after the boundary will returned in future reads.

soup_socket_read_until() will almost always return fewer than @len
bytes: if the boundary is found, then it will only return the bytes
up until the end of the boundary, and if the boundary is not found,
then it will leave the last &lt;literal&gt;(boundary_len - 1)&lt;/literal&gt;
bytes in its internal buffer, in case they form the start of the
boundary string. Thus, @len normally needs to be at least 1 byte
longer than @boundary_len if you want to make any progress at all.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">as for soup_socket_read()</doc>
          <type name="SocketIOStatus" c:type="SoupSocketIOStatus"/>
        </return-value>
        <parameters>
          <instance-parameter name="sock" transfer-ownership="none">
            <doc xml:space="preserve">the socket</doc>
            <type name="Socket" c:type="SoupSocket*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">buffer to read
  into</doc>
            <array length="1" zero-terminated="0" c:type="gpointer">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">size of @buffer in bytes</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="boundary" transfer-ownership="none">
            <doc xml:space="preserve">boundary to read until</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
          <parameter name="boundary_len" transfer-ownership="none">
            <doc xml:space="preserve">length of @boundary in bytes</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="nread"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">on return, the number of bytes read into @buffer</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
          <parameter name="got_boundary" transfer-ownership="none">
            <doc xml:space="preserve">on return, whether or not the data in @buffer
ends with the boundary string</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="start_proxy_ssl"
              c:identifier="soup_socket_start_proxy_ssl">
        <doc xml:space="preserve">Starts using SSL on @socket, expecting to find a host named
@ssl_host.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">success or failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="sock" transfer-ownership="none">
            <doc xml:space="preserve">the socket</doc>
            <type name="Socket" c:type="SoupSocket*"/>
          </instance-parameter>
          <parameter name="ssl_host" transfer-ownership="none">
            <doc xml:space="preserve">hostname of the SSL server</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="start_ssl" c:identifier="soup_socket_start_ssl">
        <doc xml:space="preserve">Starts using SSL on @socket.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">success or failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="sock" transfer-ownership="none">
            <doc xml:space="preserve">the socket</doc>
            <type name="Socket" c:type="SoupSocket*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="write" c:identifier="soup_socket_write" throws="1">
        <doc xml:space="preserve">Attempts to write @len bytes from @buffer to @sock. If some data is
successfully written, the return status will be %SOUP_SOCKET_OK,
and *@nwrote will contain the number of bytes actually written
(which may be less than @len).

If @sock is non-blocking, and no data could be written right away,
the return value will be %SOUP_SOCKET_WOULD_BLOCK. In this case,
the caller can connect to the #SoupSocket::writable signal to know
when more data can be written. (NB: #SoupSocket::writable is only
emitted after soup_socket_write() returns %SOUP_SOCKET_WOULD_BLOCK,
and it is only emitted once. See the documentation for
#SoupSocket:non-blocking.)</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #SoupSocketIOStatus, as described above (or
%SOUP_SOCKET_EOF or %SOUP_SOCKET_ERROR. @error will be set if the
return value is %SOUP_SOCKET_ERROR.)</doc>
          <type name="SocketIOStatus" c:type="SoupSocketIOStatus"/>
        </return-value>
        <parameters>
          <instance-parameter name="sock" transfer-ownership="none">
            <doc xml:space="preserve">the socket</doc>
            <type name="Socket" c:type="SoupSocket*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">data to write</doc>
            <array length="1" zero-terminated="0" c:type="gconstpointer">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">size of @buffer, in bytes</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="nwrote"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">on return, number of bytes written</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <property name="async-context"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <property name="fd"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="gsocket"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="Gio.Socket"/>
      </property>
      <property name="iostream"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="Gio.IOStream"/>
      </property>
      <property name="ipv6-only" writable="1" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="is-server" transfer-ownership="none">
        <doc xml:space="preserve">Whether or not the socket is a server socket.

Note that for "ordinary" #SoupSockets this will be set for
both listening sockets and the sockets emitted by
#SoupSocket::new-connection, but for sockets created by
setting #SoupSocket:fd, it will only be set for listening
sockets.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="local-address"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="Address"/>
      </property>
      <property name="non-blocking" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Whether or not the socket uses non-blocking I/O.

#SoupSocket's I/O methods are designed around the idea of
using a single codepath for both synchronous and
asynchronous I/O. If you want to read off a #SoupSocket,
the "correct" way to do it is to call soup_socket_read() or
soup_socket_read_until() repeatedly until you have read
everything you want. If it returns %SOUP_SOCKET_WOULD_BLOCK
at any point, stop reading and wait for it to emit the
#SoupSocket::readable signal. Then go back to the
reading-as-much-as-you-can loop. Likewise, for writing to a
#SoupSocket, you should call soup_socket_write() either
until you have written everything, or it returns
%SOUP_SOCKET_WOULD_BLOCK (in which case you wait for
#SoupSocket::writable and then go back into the loop).

Code written this way will work correctly with both
blocking and non-blocking sockets; blocking sockets will
simply never return %SOUP_SOCKET_WOULD_BLOCK, and so the
code that handles that case just won't get used for them.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="remote-address"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="Address"/>
      </property>
      <property name="socket-properties"
                introspectable="0"
                readable="0"
                writable="1"
                transfer-ownership="none">
        <type/>
      </property>
      <property name="ssl-creds" writable="1" transfer-ownership="none">
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <property name="ssl-fallback"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="ssl-strict"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="timeout" writable="1" transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <property name="tls-certificate" transfer-ownership="none">
        <type name="Gio.TlsCertificate"/>
      </property>
      <property name="tls-errors" transfer-ownership="none">
        <type name="Gio.TlsCertificateFlags"/>
      </property>
      <property name="trusted-certificate" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="use-thread-context"
                version="2.38"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Use g_main_context_get_thread_default().</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <glib:signal name="disconnected" when="last">
        <doc xml:space="preserve">Emitted when the socket is disconnected, for whatever
reason.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="event" when="last" version="2.38">
        <doc xml:space="preserve">Emitted when a network-related event occurs. See
#GSocketClient::event for more details.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="event" transfer-ownership="none">
            <doc xml:space="preserve">the event that occurred</doc>
            <type name="Gio.SocketClientEvent"/>
          </parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the current connection state</doc>
            <type name="Gio.IOStream"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="new-connection" when="first">
        <doc xml:space="preserve">Emitted when a listening socket (set up with
soup_socket_listen()) receives a new connection.

You must ref the @new if you want to keep it; otherwise it
will be destroyed after the signal is emitted.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="new" transfer-ownership="none">
            <doc xml:space="preserve">the new socket</doc>
            <type name="Socket"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="readable" when="last">
        <doc xml:space="preserve">Emitted when an async socket is readable. See
soup_socket_read(), soup_socket_read_until() and
#SoupSocket:non-blocking.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="writable" when="last">
        <doc xml:space="preserve">Emitted when an async socket is writable. See
soup_socket_write() and #SoupSocket:non-blocking.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
    </class>
    <callback name="SocketCallback" c:type="SoupSocketCallback">
      <doc xml:space="preserve">The callback function passed to soup_socket_connect_async().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="sock" transfer-ownership="none">
          <doc xml:space="preserve">the #SoupSocket</doc>
          <type name="Socket" c:type="SoupSocket*"/>
        </parameter>
        <parameter name="status" transfer-ownership="none">
          <doc xml:space="preserve">an HTTP status code indicating success or failure</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:space="preserve">the data passed to soup_socket_connect_async()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="SocketClass"
            c:type="SoupSocketClass"
            glib:is-gtype-struct-for="Socket">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="readable">
        <callback name="readable">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="sock" transfer-ownership="none">
              <type name="Socket" c:type="SoupSocket*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="writable">
        <callback name="writable">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="sock" transfer-ownership="none">
              <type name="Socket" c:type="SoupSocket*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="disconnected">
        <callback name="disconnected">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="sock" transfer-ownership="none">
              <type name="Socket" c:type="SoupSocket*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="new_connection">
        <callback name="new_connection">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="listener" transfer-ownership="none">
              <type name="Socket" c:type="SoupSocket*"/>
            </parameter>
            <parameter name="new_sock" transfer-ownership="none">
              <type name="Socket" c:type="SoupSocket*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_libsoup_reserved1" introspectable="0">
        <callback name="_libsoup_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_libsoup_reserved2" introspectable="0">
        <callback name="_libsoup_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_libsoup_reserved3" introspectable="0">
        <callback name="_libsoup_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_libsoup_reserved4" introspectable="0">
        <callback name="_libsoup_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="SocketIOStatus"
                 glib:type-name="SoupSocketIOStatus"
                 glib:get-type="soup_socket_io_status_get_type"
                 c:type="SoupSocketIOStatus">
      <doc xml:space="preserve">Return value from the #SoupSocket IO methods.</doc>
      <member name="ok" value="0" c:identifier="SOUP_SOCKET_OK" glib:nick="ok">
        <doc xml:space="preserve">Success</doc>
      </member>
      <member name="would_block"
              value="1"
              c:identifier="SOUP_SOCKET_WOULD_BLOCK"
              glib:nick="would-block">
        <doc xml:space="preserve">Cannot read/write any more at this time</doc>
      </member>
      <member name="eof"
              value="2"
              c:identifier="SOUP_SOCKET_EOF"
              glib:nick="eof">
        <doc xml:space="preserve">End of file</doc>
      </member>
      <member name="error"
              value="3"
              c:identifier="SOUP_SOCKET_ERROR"
              glib:nick="error">
        <doc xml:space="preserve">Other error</doc>
      </member>
    </enumeration>
    <enumeration name="Status"
                 glib:type-name="SoupStatus"
                 glib:get-type="soup_status_get_type"
                 c:type="SoupStatus">
      <doc xml:space="preserve">These represent the known HTTP status code values, plus various
network and internal errors.

Note that no libsoup functions take or return this type directly;
any function that works with status codes will accept unrecognized
status codes as well.

Prior to 2.44 this type was called
&lt;literal&gt;SoupKnownStatusCode&lt;/literal&gt;, but the individual values
have always had the names they have now.</doc>
      <member name="none"
              value="0"
              c:identifier="SOUP_STATUS_NONE"
              glib:nick="none">
        <doc xml:space="preserve">No status available. (Eg, the message has not
been sent yet)</doc>
      </member>
      <member name="cancelled"
              value="1"
              c:identifier="SOUP_STATUS_CANCELLED"
              glib:nick="cancelled">
        <doc xml:space="preserve">Message was cancelled locally</doc>
      </member>
      <member name="cant_resolve"
              value="2"
              c:identifier="SOUP_STATUS_CANT_RESOLVE"
              glib:nick="cant-resolve">
        <doc xml:space="preserve">Unable to resolve destination host name</doc>
      </member>
      <member name="cant_resolve_proxy"
              value="3"
              c:identifier="SOUP_STATUS_CANT_RESOLVE_PROXY"
              glib:nick="cant-resolve-proxy">
        <doc xml:space="preserve">Unable to resolve proxy host name</doc>
      </member>
      <member name="cant_connect"
              value="4"
              c:identifier="SOUP_STATUS_CANT_CONNECT"
              glib:nick="cant-connect">
        <doc xml:space="preserve">Unable to connect to remote host</doc>
      </member>
      <member name="cant_connect_proxy"
              value="5"
              c:identifier="SOUP_STATUS_CANT_CONNECT_PROXY"
              glib:nick="cant-connect-proxy">
        <doc xml:space="preserve">Unable to connect to proxy</doc>
      </member>
      <member name="ssl_failed"
              value="6"
              c:identifier="SOUP_STATUS_SSL_FAILED"
              glib:nick="ssl-failed">
        <doc xml:space="preserve">SSL/TLS negotiation failed</doc>
      </member>
      <member name="io_error"
              value="7"
              c:identifier="SOUP_STATUS_IO_ERROR"
              glib:nick="io-error">
        <doc xml:space="preserve">A network error occurred, or the other end
closed the connection unexpectedly</doc>
      </member>
      <member name="malformed"
              value="8"
              c:identifier="SOUP_STATUS_MALFORMED"
              glib:nick="malformed">
        <doc xml:space="preserve">Malformed data (usually a programmer error)</doc>
      </member>
      <member name="try_again"
              value="9"
              c:identifier="SOUP_STATUS_TRY_AGAIN"
              glib:nick="try-again">
        <doc xml:space="preserve">Used internally</doc>
      </member>
      <member name="too_many_redirects"
              value="10"
              c:identifier="SOUP_STATUS_TOO_MANY_REDIRECTS"
              glib:nick="too-many-redirects">
        <doc xml:space="preserve">There were too many redirections</doc>
      </member>
      <member name="tls_failed"
              value="11"
              c:identifier="SOUP_STATUS_TLS_FAILED"
              glib:nick="tls-failed">
        <doc xml:space="preserve">Used internally</doc>
      </member>
      <member name="continue"
              value="100"
              c:identifier="SOUP_STATUS_CONTINUE"
              glib:nick="continue">
        <doc xml:space="preserve">100 Continue (HTTP)</doc>
      </member>
      <member name="switching_protocols"
              value="101"
              c:identifier="SOUP_STATUS_SWITCHING_PROTOCOLS"
              glib:nick="switching-protocols">
        <doc xml:space="preserve">101 Switching Protocols (HTTP)</doc>
      </member>
      <member name="processing"
              value="102"
              c:identifier="SOUP_STATUS_PROCESSING"
              glib:nick="processing">
        <doc xml:space="preserve">102 Processing (WebDAV)</doc>
      </member>
      <member name="ok"
              value="200"
              c:identifier="SOUP_STATUS_OK"
              glib:nick="ok">
        <doc xml:space="preserve">200 Success (HTTP). Also used by many lower-level
soup routines to indicate success.</doc>
      </member>
      <member name="created"
              value="201"
              c:identifier="SOUP_STATUS_CREATED"
              glib:nick="created">
        <doc xml:space="preserve">201 Created (HTTP)</doc>
      </member>
      <member name="accepted"
              value="202"
              c:identifier="SOUP_STATUS_ACCEPTED"
              glib:nick="accepted">
        <doc xml:space="preserve">202 Accepted (HTTP)</doc>
      </member>
      <member name="non_authoritative"
              value="203"
              c:identifier="SOUP_STATUS_NON_AUTHORITATIVE"
              glib:nick="non-authoritative">
        <doc xml:space="preserve">203 Non-Authoritative Information
(HTTP)</doc>
      </member>
      <member name="no_content"
              value="204"
              c:identifier="SOUP_STATUS_NO_CONTENT"
              glib:nick="no-content">
        <doc xml:space="preserve">204 No Content (HTTP)</doc>
      </member>
      <member name="reset_content"
              value="205"
              c:identifier="SOUP_STATUS_RESET_CONTENT"
              glib:nick="reset-content">
        <doc xml:space="preserve">205 Reset Content (HTTP)</doc>
      </member>
      <member name="partial_content"
              value="206"
              c:identifier="SOUP_STATUS_PARTIAL_CONTENT"
              glib:nick="partial-content">
        <doc xml:space="preserve">206 Partial Content (HTTP)</doc>
      </member>
      <member name="multi_status"
              value="207"
              c:identifier="SOUP_STATUS_MULTI_STATUS"
              glib:nick="multi-status">
        <doc xml:space="preserve">207 Multi-Status (WebDAV)</doc>
      </member>
      <member name="multiple_choices"
              value="300"
              c:identifier="SOUP_STATUS_MULTIPLE_CHOICES"
              glib:nick="multiple-choices">
        <doc xml:space="preserve">300 Multiple Choices (HTTP)</doc>
      </member>
      <member name="moved_permanently"
              value="301"
              c:identifier="SOUP_STATUS_MOVED_PERMANENTLY"
              glib:nick="moved-permanently">
        <doc xml:space="preserve">301 Moved Permanently (HTTP)</doc>
      </member>
      <member name="found"
              value="302"
              c:identifier="SOUP_STATUS_FOUND"
              glib:nick="found">
        <doc xml:space="preserve">302 Found (HTTP)</doc>
      </member>
      <member name="moved_temporarily"
              value="302"
              c:identifier="SOUP_STATUS_MOVED_TEMPORARILY"
              glib:nick="moved-temporarily">
        <doc xml:space="preserve">302 Moved Temporarily (old name,
RFC 2068)</doc>
      </member>
      <member name="see_other"
              value="303"
              c:identifier="SOUP_STATUS_SEE_OTHER"
              glib:nick="see-other">
        <doc xml:space="preserve">303 See Other (HTTP)</doc>
      </member>
      <member name="not_modified"
              value="304"
              c:identifier="SOUP_STATUS_NOT_MODIFIED"
              glib:nick="not-modified">
        <doc xml:space="preserve">304 Not Modified (HTTP)</doc>
      </member>
      <member name="use_proxy"
              value="305"
              c:identifier="SOUP_STATUS_USE_PROXY"
              glib:nick="use-proxy">
        <doc xml:space="preserve">305 Use Proxy (HTTP)</doc>
      </member>
      <member name="not_appearing_in_this_protocol"
              value="306"
              c:identifier="SOUP_STATUS_NOT_APPEARING_IN_THIS_PROTOCOL"
              glib:nick="not-appearing-in-this-protocol">
        <doc xml:space="preserve">306 [Unused] (HTTP)</doc>
      </member>
      <member name="temporary_redirect"
              value="307"
              c:identifier="SOUP_STATUS_TEMPORARY_REDIRECT"
              glib:nick="temporary-redirect">
        <doc xml:space="preserve">307 Temporary Redirect (HTTP)</doc>
      </member>
      <member name="bad_request"
              value="400"
              c:identifier="SOUP_STATUS_BAD_REQUEST"
              glib:nick="bad-request">
        <doc xml:space="preserve">400 Bad Request (HTTP)</doc>
      </member>
      <member name="unauthorized"
              value="401"
              c:identifier="SOUP_STATUS_UNAUTHORIZED"
              glib:nick="unauthorized">
        <doc xml:space="preserve">401 Unauthorized (HTTP)</doc>
      </member>
      <member name="payment_required"
              value="402"
              c:identifier="SOUP_STATUS_PAYMENT_REQUIRED"
              glib:nick="payment-required">
        <doc xml:space="preserve">402 Payment Required (HTTP)</doc>
      </member>
      <member name="forbidden"
              value="403"
              c:identifier="SOUP_STATUS_FORBIDDEN"
              glib:nick="forbidden">
        <doc xml:space="preserve">403 Forbidden (HTTP)</doc>
      </member>
      <member name="not_found"
              value="404"
              c:identifier="SOUP_STATUS_NOT_FOUND"
              glib:nick="not-found">
        <doc xml:space="preserve">404 Not Found (HTTP)</doc>
      </member>
      <member name="method_not_allowed"
              value="405"
              c:identifier="SOUP_STATUS_METHOD_NOT_ALLOWED"
              glib:nick="method-not-allowed">
        <doc xml:space="preserve">405 Method Not Allowed (HTTP)</doc>
      </member>
      <member name="not_acceptable"
              value="406"
              c:identifier="SOUP_STATUS_NOT_ACCEPTABLE"
              glib:nick="not-acceptable">
        <doc xml:space="preserve">406 Not Acceptable (HTTP)</doc>
      </member>
      <member name="proxy_authentication_required"
              value="407"
              c:identifier="SOUP_STATUS_PROXY_AUTHENTICATION_REQUIRED"
              glib:nick="proxy-authentication-required">
        <doc xml:space="preserve">407 Proxy Authentication
Required (HTTP)</doc>
      </member>
      <member name="proxy_unauthorized"
              value="407"
              c:identifier="SOUP_STATUS_PROXY_UNAUTHORIZED"
              glib:nick="proxy-unauthorized">
        <doc xml:space="preserve">shorter alias for
%SOUP_STATUS_PROXY_AUTHENTICATION_REQUIRED</doc>
      </member>
      <member name="request_timeout"
              value="408"
              c:identifier="SOUP_STATUS_REQUEST_TIMEOUT"
              glib:nick="request-timeout">
        <doc xml:space="preserve">408 Request Timeout (HTTP)</doc>
      </member>
      <member name="conflict"
              value="409"
              c:identifier="SOUP_STATUS_CONFLICT"
              glib:nick="conflict">
        <doc xml:space="preserve">409 Conflict (HTTP)</doc>
      </member>
      <member name="gone"
              value="410"
              c:identifier="SOUP_STATUS_GONE"
              glib:nick="gone">
        <doc xml:space="preserve">410 Gone (HTTP)</doc>
      </member>
      <member name="length_required"
              value="411"
              c:identifier="SOUP_STATUS_LENGTH_REQUIRED"
              glib:nick="length-required">
        <doc xml:space="preserve">411 Length Required (HTTP)</doc>
      </member>
      <member name="precondition_failed"
              value="412"
              c:identifier="SOUP_STATUS_PRECONDITION_FAILED"
              glib:nick="precondition-failed">
        <doc xml:space="preserve">412 Precondition Failed (HTTP)</doc>
      </member>
      <member name="request_entity_too_large"
              value="413"
              c:identifier="SOUP_STATUS_REQUEST_ENTITY_TOO_LARGE"
              glib:nick="request-entity-too-large">
        <doc xml:space="preserve">413 Request Entity Too Large
(HTTP)</doc>
      </member>
      <member name="request_uri_too_long"
              value="414"
              c:identifier="SOUP_STATUS_REQUEST_URI_TOO_LONG"
              glib:nick="request-uri-too-long">
        <doc xml:space="preserve">414 Request-URI Too Long (HTTP)</doc>
      </member>
      <member name="unsupported_media_type"
              value="415"
              c:identifier="SOUP_STATUS_UNSUPPORTED_MEDIA_TYPE"
              glib:nick="unsupported-media-type">
        <doc xml:space="preserve">415 Unsupported Media Type
(HTTP)</doc>
      </member>
      <member name="requested_range_not_satisfiable"
              value="416"
              c:identifier="SOUP_STATUS_REQUESTED_RANGE_NOT_SATISFIABLE"
              glib:nick="requested-range-not-satisfiable">
        <doc xml:space="preserve">416 Requested Range
Not Satisfiable (HTTP)</doc>
      </member>
      <member name="invalid_range"
              value="416"
              c:identifier="SOUP_STATUS_INVALID_RANGE"
              glib:nick="invalid-range">
        <doc xml:space="preserve">shorter alias for
%SOUP_STATUS_REQUESTED_RANGE_NOT_SATISFIABLE</doc>
      </member>
      <member name="expectation_failed"
              value="417"
              c:identifier="SOUP_STATUS_EXPECTATION_FAILED"
              glib:nick="expectation-failed">
        <doc xml:space="preserve">417 Expectation Failed (HTTP)</doc>
      </member>
      <member name="unprocessable_entity"
              value="422"
              c:identifier="SOUP_STATUS_UNPROCESSABLE_ENTITY"
              glib:nick="unprocessable-entity">
        <doc xml:space="preserve">422 Unprocessable Entity
(WebDAV)</doc>
      </member>
      <member name="locked"
              value="423"
              c:identifier="SOUP_STATUS_LOCKED"
              glib:nick="locked">
        <doc xml:space="preserve">423 Locked (WebDAV)</doc>
      </member>
      <member name="failed_dependency"
              value="424"
              c:identifier="SOUP_STATUS_FAILED_DEPENDENCY"
              glib:nick="failed-dependency">
        <doc xml:space="preserve">424 Failed Dependency (WebDAV)</doc>
      </member>
      <member name="internal_server_error"
              value="500"
              c:identifier="SOUP_STATUS_INTERNAL_SERVER_ERROR"
              glib:nick="internal-server-error">
        <doc xml:space="preserve">500 Internal Server Error
(HTTP)</doc>
      </member>
      <member name="not_implemented"
              value="501"
              c:identifier="SOUP_STATUS_NOT_IMPLEMENTED"
              glib:nick="not-implemented">
        <doc xml:space="preserve">501 Not Implemented (HTTP)</doc>
      </member>
      <member name="bad_gateway"
              value="502"
              c:identifier="SOUP_STATUS_BAD_GATEWAY"
              glib:nick="bad-gateway">
        <doc xml:space="preserve">502 Bad Gateway (HTTP)</doc>
      </member>
      <member name="service_unavailable"
              value="503"
              c:identifier="SOUP_STATUS_SERVICE_UNAVAILABLE"
              glib:nick="service-unavailable">
        <doc xml:space="preserve">503 Service Unavailable (HTTP)</doc>
      </member>
      <member name="gateway_timeout"
              value="504"
              c:identifier="SOUP_STATUS_GATEWAY_TIMEOUT"
              glib:nick="gateway-timeout">
        <doc xml:space="preserve">504 Gateway Timeout (HTTP)</doc>
      </member>
      <member name="http_version_not_supported"
              value="505"
              c:identifier="SOUP_STATUS_HTTP_VERSION_NOT_SUPPORTED"
              glib:nick="http-version-not-supported">
        <doc xml:space="preserve">505 HTTP Version Not
Supported (HTTP)</doc>
      </member>
      <member name="insufficient_storage"
              value="507"
              c:identifier="SOUP_STATUS_INSUFFICIENT_STORAGE"
              glib:nick="insufficient-storage">
        <doc xml:space="preserve">507 Insufficient Storage
(WebDAV)</doc>
      </member>
      <member name="not_extended"
              value="510"
              c:identifier="SOUP_STATUS_NOT_EXTENDED"
              glib:nick="not-extended">
        <doc xml:space="preserve">510 Not Extended (RFC 2774)</doc>
      </member>
      <function name="get_phrase" c:identifier="soup_status_get_phrase">
        <doc xml:space="preserve">Looks up the stock HTTP description of @status_code. This is used
by soup_message_set_status() to get the correct text to go with a
given status code.

&lt;emphasis&gt;There is no reason for you to ever use this
function.&lt;/emphasis&gt; If you wanted the textual description for the
#SoupMessage:status_code of a given #SoupMessage, you should just
look at the message's #SoupMessage:reason_phrase. However, you
should only do that for use in debugging messages; HTTP reason
phrases are not localized, and are not generally very descriptive
anyway, and so they should never be presented to the user directly.
Instead, you should create you own error messages based on the
status code, and on what you were trying to do.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the (terse, English) description of @status_code</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <parameter name="status_code" transfer-ownership="none">
            <doc xml:space="preserve">an HTTP status code</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </function>
      <function name="proxify"
                c:identifier="soup_status_proxify"
                version="2.26">
        <doc xml:space="preserve">Turns %SOUP_STATUS_CANT_RESOLVE into
%SOUP_STATUS_CANT_RESOLVE_PROXY and %SOUP_STATUS_CANT_CONNECT into
%SOUP_STATUS_CANT_CONNECT_PROXY. Other status codes are passed
through unchanged.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the "proxified" equivalent of @status_code.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <parameter name="status_code" transfer-ownership="none">
            <doc xml:space="preserve">a status code</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </function>
    </enumeration>
    <enumeration name="TLDError"
                 version="2.40"
                 glib:type-name="SoupTLDError"
                 glib:get-type="soup_tld_error_get_type"
                 c:type="SoupTLDError"
                 glib:error-domain="soup_tld_error_quark">
      <doc xml:space="preserve">Error codes for %SOUP_TLD_ERROR.</doc>
      <member name="invalid_hostname"
              value="0"
              c:identifier="SOUP_TLD_ERROR_INVALID_HOSTNAME"
              glib:nick="invalid-hostname">
        <doc xml:space="preserve">A hostname was syntactically
  invalid.</doc>
      </member>
      <member name="is_ip_address"
              value="1"
              c:identifier="SOUP_TLD_ERROR_IS_IP_ADDRESS"
              glib:nick="is-ip-address">
        <doc xml:space="preserve">The passed-in "hostname" was
  actually an IP address (and thus has no base domain or
  public suffix).</doc>
      </member>
      <member name="not_enough_domains"
              value="2"
              c:identifier="SOUP_TLD_ERROR_NOT_ENOUGH_DOMAINS"
              glib:nick="not-enough-domains">
        <doc xml:space="preserve">The passed-in hostname
  did not have enough components. Eg, calling
  soup_tld_get_base_domain() on &lt;literal&gt;"co.uk"&lt;/literal&gt;.</doc>
      </member>
      <member name="no_base_domain"
              value="3"
              c:identifier="SOUP_TLD_ERROR_NO_BASE_DOMAIN"
              glib:nick="no-base-domain">
        <doc xml:space="preserve">The passed-in hostname has
  no recognized public suffix.</doc>
      </member>
      <function name="quark" c:identifier="soup_tld_error_quark">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <constant name="TYPES_H" value="1" c:type="SOUP_TYPES_H">
      <type name="gint" c:type="gint"/>
    </constant>
    <record name="URI"
            c:type="SoupURI"
            glib:type-name="SoupURI"
            glib:get-type="soup_uri_get_type"
            c:symbol-prefix="uri">
      <doc xml:space="preserve">A #SoupURI represents a (parsed) URI. #SoupURI supports RFC 3986
(URI Generic Syntax), and can parse any valid URI. However, libsoup
only uses "http" and "https" URIs internally; You can use
SOUP_URI_VALID_FOR_HTTP() to test if a #SoupURI is a valid HTTP
URI.

@scheme will always be set in any URI. It is an interned string and
is always all lowercase. (If you parse a URI with a non-lowercase
scheme, it will be converted to lowercase.) The macros
%SOUP_URI_SCHEME_HTTP and %SOUP_URI_SCHEME_HTTPS provide the
interned values for "http" and "https" and can be compared against
URI @scheme values.

@user and @password are parsed as defined in the older URI specs
(ie, separated by a colon; RFC 3986 only talks about a single
"userinfo" field). Note that @password is not included in the
output of soup_uri_to_string(). libsoup does not normally use these
fields; authentication is handled via #SoupSession signals.

@host contains the hostname, and @port the port specified in the
URI. If the URI doesn't contain a hostname, @host will be %NULL,
and if it doesn't specify a port, @port may be 0. However, for
"http" and "https" URIs, @host is guaranteed to be non-%NULL
(trying to parse an http URI with no @host will return %NULL), and
@port will always be non-0 (because libsoup knows the default value
to use when it is not specified in the URI).

@path is always non-%NULL. For http/https URIs, @path will never be
an empty string either; if the input URI has no path, the parsed
#SoupURI will have a @path of "/".

@query and @fragment are optional for all URI types.
soup_form_decode() may be useful for parsing @query.

Note that @path, @query, and @fragment may contain
%&lt;!-- --&gt;-encoded characters. soup_uri_new() calls
soup_uri_normalize() on them, but not soup_uri_decode(). This is
necessary to ensure that soup_uri_to_string() will generate a URI
that has exactly the same meaning as the original. (In theory,
#SoupURI should leave @user, @password, and @host partially-encoded
as well, but this would be more annoying than useful.)</doc>
      <field name="scheme" writable="1">
        <doc xml:space="preserve">the URI scheme (eg, "http")</doc>
        <type name="utf8" c:type="const char*"/>
      </field>
      <field name="user" writable="1">
        <doc xml:space="preserve">a username, or %NULL</doc>
        <type name="utf8" c:type="char*"/>
      </field>
      <field name="password" writable="1">
        <doc xml:space="preserve">a password, or %NULL</doc>
        <type name="utf8" c:type="char*"/>
      </field>
      <field name="host" writable="1">
        <doc xml:space="preserve">the hostname or IP address</doc>
        <type name="utf8" c:type="char*"/>
      </field>
      <field name="port" writable="1">
        <doc xml:space="preserve">the port number on @host</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="path" writable="1">
        <doc xml:space="preserve">the path on @host</doc>
        <type name="utf8" c:type="char*"/>
      </field>
      <field name="query" writable="1">
        <doc xml:space="preserve">a query for @path, or %NULL</doc>
        <type name="utf8" c:type="char*"/>
      </field>
      <field name="fragment" writable="1">
        <doc xml:space="preserve">a fragment identifier within @path, or %NULL</doc>
        <type name="utf8" c:type="char*"/>
      </field>
      <constructor name="new" c:identifier="soup_uri_new">
        <doc xml:space="preserve">Parses an absolute URI.

You can also pass %NULL for @uri_string if you want to get back an
"empty" #SoupURI that you can fill in by hand. (You will need to
call at least soup_uri_set_scheme() and soup_uri_set_path(), since
those fields are required.)</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a #SoupURI, or %NULL if the given string
 was found to be invalid.</doc>
          <type name="URI" c:type="SoupURI*"/>
        </return-value>
        <parameters>
          <parameter name="uri_string"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a URI</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="copy" c:identifier="soup_uri_copy">
        <doc xml:space="preserve">Copies @uri</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a copy of @uri, which must be freed with soup_uri_free()</doc>
          <type name="URI" c:type="SoupURI*"/>
        </return-value>
        <parameters>
          <instance-parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupURI</doc>
            <type name="URI" c:type="SoupURI*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="copy_host"
              c:identifier="soup_uri_copy_host"
              version="2.28">
        <doc xml:space="preserve">Makes a copy of @uri, considering only the protocol, host, and port</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #SoupURI</doc>
          <type name="URI" c:type="SoupURI*"/>
        </return-value>
        <parameters>
          <instance-parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupURI</doc>
            <type name="URI" c:type="SoupURI*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="equal" c:identifier="soup_uri_equal">
        <doc xml:space="preserve">Tests whether or not @uri1 and @uri2 are equal in all parts</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE or %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="uri1" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupURI</doc>
            <type name="URI" c:type="SoupURI*"/>
          </instance-parameter>
          <parameter name="uri2" transfer-ownership="none">
            <doc xml:space="preserve">another #SoupURI</doc>
            <type name="URI" c:type="SoupURI*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="soup_uri_free">
        <doc xml:space="preserve">Frees @uri.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupURI</doc>
            <type name="URI" c:type="SoupURI*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_fragment"
              c:identifier="soup_uri_get_fragment"
              version="2.32">
        <doc xml:space="preserve">Gets @uri's fragment.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@uri's fragment.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupURI</doc>
            <type name="URI" c:type="SoupURI*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_host" c:identifier="soup_uri_get_host" version="2.32">
        <doc xml:space="preserve">Gets @uri's host.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@uri's host.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupURI</doc>
            <type name="URI" c:type="SoupURI*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_password"
              c:identifier="soup_uri_get_password"
              version="2.32">
        <doc xml:space="preserve">Gets @uri's password.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@uri's password.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupURI</doc>
            <type name="URI" c:type="SoupURI*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_path" c:identifier="soup_uri_get_path" version="2.32">
        <doc xml:space="preserve">Gets @uri's path.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@uri's path.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupURI</doc>
            <type name="URI" c:type="SoupURI*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_port" c:identifier="soup_uri_get_port" version="2.32">
        <doc xml:space="preserve">Gets @uri's port.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@uri's port.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupURI</doc>
            <type name="URI" c:type="SoupURI*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_query"
              c:identifier="soup_uri_get_query"
              version="2.32">
        <doc xml:space="preserve">Gets @uri's query.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@uri's query.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupURI</doc>
            <type name="URI" c:type="SoupURI*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_scheme"
              c:identifier="soup_uri_get_scheme"
              version="2.32">
        <doc xml:space="preserve">Gets @uri's scheme.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@uri's scheme.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupURI</doc>
            <type name="URI" c:type="SoupURI*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_user" c:identifier="soup_uri_get_user" version="2.32">
        <doc xml:space="preserve">Gets @uri's user.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@uri's user.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupURI</doc>
            <type name="URI" c:type="SoupURI*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="host_equal"
              c:identifier="soup_uri_host_equal"
              version="2.28">
        <doc xml:space="preserve">Compares @v1 and @v2, considering only the scheme, host, and port.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether or not the URIs are equal in scheme, host,
and port.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="v1" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupURI with a non-%NULL @host member</doc>
            <type name="URI" c:type="gconstpointer"/>
          </instance-parameter>
          <parameter name="v2" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupURI with a non-%NULL @host member</doc>
            <type name="URI" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="host_hash"
              c:identifier="soup_uri_host_hash"
              version="2.28">
        <doc xml:space="preserve">Hashes @key, considering only the scheme, host, and port.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a hash</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupURI with a non-%NULL @host member</doc>
            <type name="URI" c:type="gconstpointer"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="new_with_base" c:identifier="soup_uri_new_with_base">
        <doc xml:space="preserve">Parses @uri_string relative to @base.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a parsed #SoupURI.</doc>
          <type name="URI" c:type="SoupURI*"/>
        </return-value>
        <parameters>
          <instance-parameter name="base" transfer-ownership="none">
            <doc xml:space="preserve">a base URI</doc>
            <type name="URI" c:type="SoupURI*"/>
          </instance-parameter>
          <parameter name="uri_string" transfer-ownership="none">
            <doc xml:space="preserve">the URI</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_fragment" c:identifier="soup_uri_set_fragment">
        <doc xml:space="preserve">Sets @uri's fragment to @fragment.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupURI</doc>
            <type name="URI" c:type="SoupURI*"/>
          </instance-parameter>
          <parameter name="fragment"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the fragment</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_host" c:identifier="soup_uri_set_host">
        <doc xml:space="preserve">Sets @uri's host to @host.

If @host is an IPv6 IP address, it should not include the brackets
required by the URI syntax; they will be added automatically when
converting @uri to a string.

http and https URIs should not have a %NULL @host.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupURI</doc>
            <type name="URI" c:type="SoupURI*"/>
          </instance-parameter>
          <parameter name="host"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the hostname or IP address, or %NULL</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_password" c:identifier="soup_uri_set_password">
        <doc xml:space="preserve">Sets @uri's password to @password.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupURI</doc>
            <type name="URI" c:type="SoupURI*"/>
          </instance-parameter>
          <parameter name="password"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the password, or %NULL</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_path" c:identifier="soup_uri_set_path">
        <doc xml:space="preserve">Sets @uri's path to @path.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupURI</doc>
            <type name="URI" c:type="SoupURI*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the non-%NULL path</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_port" c:identifier="soup_uri_set_port">
        <doc xml:space="preserve">Sets @uri's port to @port. If @port is 0, @uri will not have an
explicitly-specified port.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupURI</doc>
            <type name="URI" c:type="SoupURI*"/>
          </instance-parameter>
          <parameter name="port" transfer-ownership="none">
            <doc xml:space="preserve">the port, or 0</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_query" c:identifier="soup_uri_set_query">
        <doc xml:space="preserve">Sets @uri's query to @query.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupURI</doc>
            <type name="URI" c:type="SoupURI*"/>
          </instance-parameter>
          <parameter name="query"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the query</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_query_from_fields"
              c:identifier="soup_uri_set_query_from_fields"
              introspectable="0">
        <doc xml:space="preserve">Sets @uri's query to the result of encoding the given form fields
and values according to the * HTML form rules. See
soup_form_encode() for more information.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupURI</doc>
            <type name="URI" c:type="SoupURI*"/>
          </instance-parameter>
          <parameter name="first_field" transfer-ownership="none">
            <doc xml:space="preserve">name of the first form field to encode into query</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">value of @first_field, followed by additional field names
and values, terminated by %NULL.</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="set_query_from_form"
              c:identifier="soup_uri_set_query_from_form">
        <doc xml:space="preserve">Sets @uri's query to the result of encoding @form according to the
HTML form rules. See soup_form_encode_hash() for more information.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupURI</doc>
            <type name="URI" c:type="SoupURI*"/>
          </instance-parameter>
          <parameter name="form" transfer-ownership="none">
            <doc xml:space="preserve">a #GHashTable containing HTML form
information</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="utf8"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="set_scheme" c:identifier="soup_uri_set_scheme">
        <doc xml:space="preserve">Sets @uri's scheme to @scheme. This will also set @uri's port to
the default port for @scheme, if known.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupURI</doc>
            <type name="URI" c:type="SoupURI*"/>
          </instance-parameter>
          <parameter name="scheme" transfer-ownership="none">
            <doc xml:space="preserve">the URI scheme</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_user" c:identifier="soup_uri_set_user">
        <doc xml:space="preserve">Sets @uri's user to @user.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupURI</doc>
            <type name="URI" c:type="SoupURI*"/>
          </instance-parameter>
          <parameter name="user"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the username, or %NULL</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_string" c:identifier="soup_uri_to_string">
        <doc xml:space="preserve">Returns a string representing @uri.

If @just_path_and_query is %TRUE, this concatenates the path and query
together. That is, it constructs the string that would be needed in
the Request-Line of an HTTP request for @uri.

Note that the output will never contain a password, even if @uri
does.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a string representing @uri, which the caller must free.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupURI</doc>
            <type name="URI" c:type="SoupURI*"/>
          </instance-parameter>
          <parameter name="just_path_and_query" transfer-ownership="none">
            <doc xml:space="preserve">if %TRUE, output just the path and query portions</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="uses_default_port"
              c:identifier="soup_uri_uses_default_port">
        <doc xml:space="preserve">Tests if @uri uses the default port for its scheme. (Eg, 80 for
http.) (This only works for http, https and ftp; libsoup does not know
the default ports of other protocols.)</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE or %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupURI</doc>
            <type name="URI" c:type="SoupURI*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="decode" c:identifier="soup_uri_decode">
        <doc xml:space="preserve">Fully %&lt;!-- --&gt;-decodes @part.

In the past, this would return %NULL if @part contained invalid
percent-encoding, but now it just ignores the problem (as
soup_uri_new() already did).</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the decoded URI part.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <parameter name="part" transfer-ownership="none">
            <doc xml:space="preserve">a URI part</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </function>
      <function name="encode" c:identifier="soup_uri_encode">
        <doc xml:space="preserve">This %&lt;!-- --&gt;-encodes the given URI part and returns the escaped
version in allocated memory, which the caller must free when it is
done.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the encoded URI part</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <parameter name="part" transfer-ownership="none">
            <doc xml:space="preserve">a URI part</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="escape_extra"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">additional reserved characters to
escape (or %NULL)</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </function>
      <function name="normalize" c:identifier="soup_uri_normalize">
        <doc xml:space="preserve">%&lt;!-- --&gt;-decodes any "unreserved" characters (or characters in
@unescape_extra) in @part.

"Unreserved" characters are those that are not allowed to be used
for punctuation according to the URI spec. For example, letters are
unreserved, so soup_uri_normalize() will turn
&lt;literal&gt;http://example.com/foo/b%&lt;!-- --&gt;61r&lt;/literal&gt; into
&lt;literal&gt;http://example.com/foo/bar&lt;/literal&gt;, which is guaranteed
to mean the same thing. However, "/" is "reserved", so
&lt;literal&gt;http://example.com/foo%&lt;!-- --&gt;2Fbar&lt;/literal&gt; would not
be changed, because it might mean something different to the
server.

In the past, this would return %NULL if @part contained invalid
percent-encoding, but now it just ignores the problem (as
soup_uri_new() already did).</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the normalized URI part</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <parameter name="part" transfer-ownership="none">
            <doc xml:space="preserve">a URI part</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="unescape_extra" transfer-ownership="none">
            <doc xml:space="preserve">reserved characters to unescape (or %NULL)</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <constant name="URI_H" value="1" c:type="SOUP_URI_H">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="VALUE_UTILS_H" value="1" c:type="SOUP_VALUE_UTILS_H">
      <type name="gint" c:type="gint"/>
    </constant>
    <enumeration name="WebsocketCloseCode"
                 version="2.50"
                 glib:type-name="SoupWebsocketCloseCode"
                 glib:get-type="soup_websocket_close_code_get_type"
                 c:type="SoupWebsocketCloseCode">
      <doc xml:space="preserve">Pre-defined close codes that can be passed to
soup_websocket_connection_close() or received from
soup_websocket_connection_get_close_code(). (However, other codes
are also allowed.)</doc>
      <member name="normal"
              value="1000"
              c:identifier="SOUP_WEBSOCKET_CLOSE_NORMAL"
              glib:nick="normal">
        <doc xml:space="preserve">a normal, non-error close</doc>
      </member>
      <member name="going_away"
              value="1001"
              c:identifier="SOUP_WEBSOCKET_CLOSE_GOING_AWAY"
              glib:nick="going-away">
        <doc xml:space="preserve">the client/server is going away</doc>
      </member>
      <member name="protocol_error"
              value="1002"
              c:identifier="SOUP_WEBSOCKET_CLOSE_PROTOCOL_ERROR"
              glib:nick="protocol-error">
        <doc xml:space="preserve">a protocol error occurred</doc>
      </member>
      <member name="unsupported_data"
              value="1003"
              c:identifier="SOUP_WEBSOCKET_CLOSE_UNSUPPORTED_DATA"
              glib:nick="unsupported-data">
        <doc xml:space="preserve">the endpoint received data
  of a type that it does not support.</doc>
      </member>
      <member name="no_status"
              value="1005"
              c:identifier="SOUP_WEBSOCKET_CLOSE_NO_STATUS"
              glib:nick="no-status">
        <doc xml:space="preserve">reserved value indicating that
  no close code was present; must not be sent.</doc>
      </member>
      <member name="abnormal"
              value="1006"
              c:identifier="SOUP_WEBSOCKET_CLOSE_ABNORMAL"
              glib:nick="abnormal">
        <doc xml:space="preserve">reserved value indicating that
  the connection was closed abnormally; must not be sent.</doc>
      </member>
      <member name="bad_data"
              value="1007"
              c:identifier="SOUP_WEBSOCKET_CLOSE_BAD_DATA"
              glib:nick="bad-data">
        <doc xml:space="preserve">the endpoint received data that
  was invalid (eg, non-UTF-8 data in a text message).</doc>
      </member>
      <member name="policy_violation"
              value="1008"
              c:identifier="SOUP_WEBSOCKET_CLOSE_POLICY_VIOLATION"
              glib:nick="policy-violation">
        <doc xml:space="preserve">generic error code
  indicating some sort of policy violation.</doc>
      </member>
      <member name="too_big"
              value="1009"
              c:identifier="SOUP_WEBSOCKET_CLOSE_TOO_BIG"
              glib:nick="too-big">
        <doc xml:space="preserve">the endpoint received a message
  that is too big to process.</doc>
      </member>
      <member name="no_extension"
              value="1010"
              c:identifier="SOUP_WEBSOCKET_CLOSE_NO_EXTENSION"
              glib:nick="no-extension">
        <doc xml:space="preserve">the client is closing the
  connection because the server failed to negotiate a required
  extension.</doc>
      </member>
      <member name="server_error"
              value="1011"
              c:identifier="SOUP_WEBSOCKET_CLOSE_SERVER_ERROR"
              glib:nick="server-error">
        <doc xml:space="preserve">the server is closing the
  connection because it was unable to fulfill the request.</doc>
      </member>
      <member name="tls_handshake"
              value="1015"
              c:identifier="SOUP_WEBSOCKET_CLOSE_TLS_HANDSHAKE"
              glib:nick="tls-handshake">
        <doc xml:space="preserve">reserved value indicating that
  the TLS handshake failed; must not be sent.</doc>
      </member>
    </enumeration>
    <class name="WebsocketConnection"
           c:symbol-prefix="websocket_connection"
           c:type="SoupWebsocketConnection"
           version="2.50"
           parent="GObject.Object"
           glib:type-name="SoupWebsocketConnection"
           glib:get-type="soup_websocket_connection_get_type"
           glib:type-struct="WebsocketConnectionClass">
      <doc xml:space="preserve">A class representing a WebSocket connection.</doc>
      <constructor name="new"
                   c:identifier="soup_websocket_connection_new"
                   version="2.50">
        <doc xml:space="preserve">Creates a #SoupWebsocketConnection on @stream. This should be
called after completing the handshake to begin using the WebSocket
protocol.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #SoupWebsocketConnection</doc>
          <type name="WebsocketConnection" c:type="SoupWebsocketConnection*"/>
        </return-value>
        <parameters>
          <parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOStream connected to the WebSocket server</doc>
            <type name="Gio.IOStream" c:type="GIOStream*"/>
          </parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">the URI of the connection</doc>
            <type name="URI" c:type="SoupURI*"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">the type of connection (client/side)</doc>
            <type name="WebsocketConnectionType"
                  c:type="SoupWebsocketConnectionType"/>
          </parameter>
          <parameter name="origin"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the Origin of the client</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="protocol"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the subprotocol in use</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="closed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="WebsocketConnection"
                  c:type="SoupWebsocketConnection*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="closing">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="WebsocketConnection"
                  c:type="SoupWebsocketConnection*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="error">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="WebsocketConnection"
                  c:type="SoupWebsocketConnection*"/>
          </instance-parameter>
          <parameter name="error" transfer-ownership="none">
            <type name="GLib.Error" c:type="GError*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="message">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="WebsocketConnection"
                  c:type="SoupWebsocketConnection*"/>
          </instance-parameter>
          <parameter name="type" transfer-ownership="none">
            <type name="WebsocketDataType" c:type="SoupWebsocketDataType"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <type name="GLib.Bytes" c:type="GBytes*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="close"
              c:identifier="soup_websocket_connection_close"
              version="2.50">
        <doc xml:space="preserve">Close the connection in an orderly fashion.

Note that until the #SoupWebsocketConnection::closed signal fires, the connection
is not yet completely closed. The close message is not even sent until the
main loop runs.

The @code and @data are sent to the peer along with the close request.
Note that the @data must be UTF-8 valid.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the WebSocket</doc>
            <type name="WebsocketConnection"
                  c:type="SoupWebsocketConnection*"/>
          </instance-parameter>
          <parameter name="code" transfer-ownership="none">
            <doc xml:space="preserve">close code</doc>
            <type name="gushort" c:type="gushort"/>
          </parameter>
          <parameter name="data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">close data</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_close_code"
              c:identifier="soup_websocket_connection_get_close_code"
              version="2.50">
        <doc xml:space="preserve">Get the close code received from the WebSocket peer.

This only becomes valid once the WebSocket is in the
%SOUP_WEBSOCKET_STATE_CLOSED state. The value will often be in the
#SoupWebsocketCloseCode enumeration, but may also be an application
defined close code.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the close code or zero.</doc>
          <type name="gushort" c:type="gushort"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the WebSocket</doc>
            <type name="WebsocketConnection"
                  c:type="SoupWebsocketConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_close_data"
              c:identifier="soup_websocket_connection_get_close_data"
              version="2.50">
        <doc xml:space="preserve">Get the close data received from the WebSocket peer.

This only becomes valid once the WebSocket is in the
%SOUP_WEBSOCKET_STATE_CLOSED state. The data may be freed once
the main loop is run, so copy it if you need to keep it around.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the close data or %NULL</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the WebSocket</doc>
            <type name="WebsocketConnection"
                  c:type="SoupWebsocketConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_connection_type"
              c:identifier="soup_websocket_connection_get_connection_type"
              version="2.50">
        <doc xml:space="preserve">Get the connection type (client/server) of the connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the connection type</doc>
          <type name="WebsocketConnectionType"
                c:type="SoupWebsocketConnectionType"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the WebSocket</doc>
            <type name="WebsocketConnection"
                  c:type="SoupWebsocketConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_io_stream"
              c:identifier="soup_websocket_connection_get_io_stream"
              version="2.50">
        <doc xml:space="preserve">Get the I/O stream the WebSocket is communicating over.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the WebSocket's I/O stream.</doc>
          <type name="Gio.IOStream" c:type="GIOStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the WebSocket</doc>
            <type name="WebsocketConnection"
                  c:type="SoupWebsocketConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_origin"
              c:identifier="soup_websocket_connection_get_origin"
              version="2.50">
        <doc xml:space="preserve">Get the origin of the WebSocket.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the origin, or %NULL</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the WebSocket</doc>
            <type name="WebsocketConnection"
                  c:type="SoupWebsocketConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_protocol"
              c:identifier="soup_websocket_connection_get_protocol"
              version="2.50">
        <doc xml:space="preserve">Get the protocol chosen via negotiation with the peer.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the chosen protocol, or %NULL</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the WebSocket</doc>
            <type name="WebsocketConnection"
                  c:type="SoupWebsocketConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_state"
              c:identifier="soup_websocket_connection_get_state"
              version="2.50">
        <doc xml:space="preserve">Get the current state of the WebSocket.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the state</doc>
          <type name="WebsocketState" c:type="SoupWebsocketState"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the WebSocket</doc>
            <type name="WebsocketConnection"
                  c:type="SoupWebsocketConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_uri"
              c:identifier="soup_websocket_connection_get_uri"
              version="2.50">
        <doc xml:space="preserve">Get the URI of the WebSocket.

For servers this represents the address of the WebSocket, and
for clients it is the address connected to.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the URI</doc>
          <type name="URI" c:type="SoupURI*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the WebSocket</doc>
            <type name="WebsocketConnection"
                  c:type="SoupWebsocketConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="send_binary"
              c:identifier="soup_websocket_connection_send_binary"
              version="2.50">
        <doc xml:space="preserve">Send a binary message to the peer.

The message is queued to be sent and will be sent when the main loop
is run.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the WebSocket</doc>
            <type name="WebsocketConnection"
                  c:type="SoupWebsocketConnection*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">the message contents</doc>
            <array length="1" zero-terminated="0" c:type="gconstpointer">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">the length of @data</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_text"
              c:identifier="soup_websocket_connection_send_text"
              version="2.50">
        <doc xml:space="preserve">Send a text (UTF-8) message to the peer.

The message is queued to be sent and will be sent when the main loop
is run.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the WebSocket</doc>
            <type name="WebsocketConnection"
                  c:type="SoupWebsocketConnection*"/>
          </instance-parameter>
          <parameter name="text" transfer-ownership="none">
            <doc xml:space="preserve">the message contents</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <property name="connection-type"
                version="2.50"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The type of connection (client/server).</doc>
        <type name="WebsocketConnectionType"/>
      </property>
      <property name="io-stream"
                version="2.50"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The underlying IO stream the WebSocket is communicating
over.

The input and output streams must be pollable streams.</doc>
        <type name="Gio.IOStream"/>
      </property>
      <property name="origin"
                version="2.50"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The client's Origin.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="protocol"
                version="2.50"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The chosen protocol, or %NULL if a protocol was not agreed
upon.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="state" version="2.50" transfer-ownership="none">
        <doc xml:space="preserve">The current state of the WebSocket.</doc>
        <type name="WebsocketState"/>
      </property>
      <property name="uri"
                version="2.50"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The URI of the WebSocket.

For servers this represents the address of the WebSocket,
and for clients it is the address connected to.</doc>
        <type name="URI"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="pv" readable="0" private="1">
        <type name="WebsocketConnectionPrivate"
              c:type="SoupWebsocketConnectionPrivate*"/>
      </field>
      <glib:signal name="closed" when="first" version="2.50">
        <doc xml:space="preserve">Emitted when the connection has completely closed, either
due to an orderly close from the peer, one initiated via
soup_websocket_connection_close() or a fatal error
condition that caused a close.

This signal will be emitted once.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="closing" when="last" version="2.50">
        <doc xml:space="preserve">This signal will be emitted during an orderly close.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="error" when="first" version="2.50">
        <doc xml:space="preserve">Emitted when an error occurred on the WebSocket. This may
be fired multiple times. Fatal errors will be followed by
the #SoupWebsocketConnection::closed signal being emitted.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="error" transfer-ownership="none">
            <doc xml:space="preserve">the error that occured</doc>
            <type name="GLib.Error"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="message" when="first" version="2.50">
        <doc xml:space="preserve">Emitted when we receive a message from the peer.

As a convenience, the @message data will always be
NUL-terminated, but the NUL byte will not be included in
the length count.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">the type of message contents</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">the message data</doc>
            <type name="GLib.Bytes"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="WebsocketConnectionClass"
            c:type="SoupWebsocketConnectionClass"
            glib:is-gtype-struct-for="WebsocketConnection"
            version="2.50">
      <doc xml:space="preserve">The abstract base class for #SoupWebsocketConnection</doc>
      <field name="parent">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="message">
        <callback name="message">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="WebsocketConnection"
                    c:type="SoupWebsocketConnection*"/>
            </parameter>
            <parameter name="type" transfer-ownership="none">
              <type name="WebsocketDataType" c:type="SoupWebsocketDataType"/>
            </parameter>
            <parameter name="message" transfer-ownership="none">
              <type name="GLib.Bytes" c:type="GBytes*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="error">
        <callback name="error">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="WebsocketConnection"
                    c:type="SoupWebsocketConnection*"/>
            </parameter>
            <parameter name="error" transfer-ownership="none">
              <type name="GLib.Error" c:type="GError*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="closing">
        <callback name="closing">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="WebsocketConnection"
                    c:type="SoupWebsocketConnection*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="closed">
        <callback name="closed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="WebsocketConnection"
                    c:type="SoupWebsocketConnection*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <record name="WebsocketConnectionPrivate"
            c:type="SoupWebsocketConnectionPrivate"
            disguised="1">
    </record>
    <enumeration name="WebsocketConnectionType"
                 version="2.50"
                 glib:type-name="SoupWebsocketConnectionType"
                 glib:get-type="soup_websocket_connection_type_get_type"
                 c:type="SoupWebsocketConnectionType">
      <doc xml:space="preserve">The type of a #SoupWebsocketConnection.</doc>
      <member name="unknown"
              value="0"
              c:identifier="SOUP_WEBSOCKET_CONNECTION_UNKNOWN"
              glib:nick="unknown">
        <doc xml:space="preserve">unknown/invalid connection</doc>
      </member>
      <member name="client"
              value="1"
              c:identifier="SOUP_WEBSOCKET_CONNECTION_CLIENT"
              glib:nick="client">
        <doc xml:space="preserve">a client-side connection</doc>
      </member>
      <member name="server"
              value="2"
              c:identifier="SOUP_WEBSOCKET_CONNECTION_SERVER"
              glib:nick="server">
        <doc xml:space="preserve">a server-side connection</doc>
      </member>
    </enumeration>
    <enumeration name="WebsocketDataType"
                 version="2.50"
                 glib:type-name="SoupWebsocketDataType"
                 glib:get-type="soup_websocket_data_type_get_type"
                 c:type="SoupWebsocketDataType">
      <doc xml:space="preserve">The type of data contained in a #SoupWebsocketConnection::message
signal.</doc>
      <member name="text"
              value="1"
              c:identifier="SOUP_WEBSOCKET_DATA_TEXT"
              glib:nick="text">
        <doc xml:space="preserve">UTF-8 text</doc>
      </member>
      <member name="binary"
              value="2"
              c:identifier="SOUP_WEBSOCKET_DATA_BINARY"
              glib:nick="binary">
        <doc xml:space="preserve">binary data</doc>
      </member>
    </enumeration>
    <enumeration name="WebsocketError"
                 version="2.50"
                 glib:type-name="SoupWebsocketError"
                 glib:get-type="soup_websocket_error_get_type"
                 c:type="SoupWebsocketError">
      <doc xml:space="preserve">WebSocket-related errors.</doc>
      <member name="failed"
              value="0"
              c:identifier="SOUP_WEBSOCKET_ERROR_FAILED"
              glib:nick="failed">
        <doc xml:space="preserve">a generic error</doc>
      </member>
      <member name="not_websocket"
              value="1"
              c:identifier="SOUP_WEBSOCKET_ERROR_NOT_WEBSOCKET"
              glib:nick="not-websocket">
        <doc xml:space="preserve">attempted to handshake with a
  server that does not appear to understand WebSockets.</doc>
      </member>
      <member name="bad_handshake"
              value="2"
              c:identifier="SOUP_WEBSOCKET_ERROR_BAD_HANDSHAKE"
              glib:nick="bad-handshake">
        <doc xml:space="preserve">the WebSocket handshake failed
  because some detail was invalid (eg, incorrect accept key).</doc>
      </member>
      <member name="bad_origin"
              value="3"
              c:identifier="SOUP_WEBSOCKET_ERROR_BAD_ORIGIN"
              glib:nick="bad-origin">
        <doc xml:space="preserve">the WebSocket handshake failed
  because the "Origin" header was not an allowed value.</doc>
      </member>
      <function name="get_quark" c:identifier="soup_websocket_error_get_quark">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <enumeration name="WebsocketState"
                 version="2.50"
                 glib:type-name="SoupWebsocketState"
                 glib:get-type="soup_websocket_state_get_type"
                 c:type="SoupWebsocketState">
      <doc xml:space="preserve">The state of the WebSocket connection.</doc>
      <member name="open"
              value="1"
              c:identifier="SOUP_WEBSOCKET_STATE_OPEN"
              glib:nick="open">
        <doc xml:space="preserve">the connection is ready to send messages</doc>
      </member>
      <member name="closing"
              value="2"
              c:identifier="SOUP_WEBSOCKET_STATE_CLOSING"
              glib:nick="closing">
        <doc xml:space="preserve">the connection is in the process of
  closing down; messages may be received, but not sent</doc>
      </member>
      <member name="closed"
              value="3"
              c:identifier="SOUP_WEBSOCKET_STATE_CLOSED"
              glib:nick="closed">
        <doc xml:space="preserve">the connection is completely closed down</doc>
      </member>
    </enumeration>
    <enumeration name="XMLRPCError"
                 glib:type-name="SoupXMLRPCError"
                 glib:get-type="soup_xmlrpc_error_get_type"
                 c:type="SoupXMLRPCError"
                 glib:error-domain="soup_xmlrpc_error_quark">
      <member name="arguments"
              value="0"
              c:identifier="SOUP_XMLRPC_ERROR_ARGUMENTS"
              glib:nick="arguments">
      </member>
      <member name="retval"
              value="1"
              c:identifier="SOUP_XMLRPC_ERROR_RETVAL"
              glib:nick="retval">
      </member>
      <function name="quark" c:identifier="soup_xmlrpc_error_quark">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <enumeration name="XMLRPCFault"
                 glib:type-name="SoupXMLRPCFault"
                 glib:get-type="soup_xmlrpc_fault_get_type"
                 c:type="SoupXMLRPCFault">
      <doc xml:space="preserve">Pre-defined XML-RPC fault codes from &lt;ulink
url="http://xmlrpc-epi.sourceforge.net/specs/rfc.fault_codes.php"&gt;http://xmlrpc-epi.sourceforge.net/specs/rfc.fault_codes.php&lt;/ulink&gt;.
These are an extension, not part of the XML-RPC spec; you can't
assume servers will use them.</doc>
      <member name="parse_error_not_well_formed"
              value="-32700"
              c:identifier="SOUP_XMLRPC_FAULT_PARSE_ERROR_NOT_WELL_FORMED"
              glib:nick="parse-error-not-well-formed">
        <doc xml:space="preserve">request was not
  well-formed</doc>
      </member>
      <member name="parse_error_unsupported_encoding"
              value="-32701"
              c:identifier="SOUP_XMLRPC_FAULT_PARSE_ERROR_UNSUPPORTED_ENCODING"
              glib:nick="parse-error-unsupported-encoding">
        <doc xml:space="preserve">request was in
  an unsupported encoding</doc>
      </member>
      <member name="parse_error_invalid_character_for_encoding"
              value="-32702"
              c:identifier="SOUP_XMLRPC_FAULT_PARSE_ERROR_INVALID_CHARACTER_FOR_ENCODING"
              glib:nick="parse-error-invalid-character-for-encoding">
        <doc xml:space="preserve">request contained an invalid character</doc>
      </member>
      <member name="server_error_invalid_xml_rpc"
              value="-32600"
              c:identifier="SOUP_XMLRPC_FAULT_SERVER_ERROR_INVALID_XML_RPC"
              glib:nick="server-error-invalid-xml-rpc">
        <doc xml:space="preserve">request was not
  valid XML-RPC</doc>
      </member>
      <member name="server_error_requested_method_not_found"
              value="-32601"
              c:identifier="SOUP_XMLRPC_FAULT_SERVER_ERROR_REQUESTED_METHOD_NOT_FOUND"
              glib:nick="server-error-requested-method-not-found">
        <doc xml:space="preserve">method
  not found</doc>
      </member>
      <member name="server_error_invalid_method_parameters"
              value="-32602"
              c:identifier="SOUP_XMLRPC_FAULT_SERVER_ERROR_INVALID_METHOD_PARAMETERS"
              glib:nick="server-error-invalid-method-parameters">
        <doc xml:space="preserve">invalid
  parameters</doc>
      </member>
      <member name="server_error_internal_xml_rpc_error"
              value="-32603"
              c:identifier="SOUP_XMLRPC_FAULT_SERVER_ERROR_INTERNAL_XML_RPC_ERROR"
              glib:nick="server-error-internal-xml-rpc-error">
        <doc xml:space="preserve">internal
  error</doc>
      </member>
      <member name="application_error"
              value="-32500"
              c:identifier="SOUP_XMLRPC_FAULT_APPLICATION_ERROR"
              glib:nick="application-error">
        <doc xml:space="preserve">start of reserved range for
  application error codes</doc>
      </member>
      <member name="system_error"
              value="-32400"
              c:identifier="SOUP_XMLRPC_FAULT_SYSTEM_ERROR"
              glib:nick="system-error">
        <doc xml:space="preserve">start of reserved range for
  system error codes</doc>
      </member>
      <member name="transport_error"
              value="-32300"
              c:identifier="SOUP_XMLRPC_FAULT_TRANSPORT_ERROR"
              glib:nick="transport-error">
        <doc xml:space="preserve">start of reserved range for
  transport error codes</doc>
      </member>
      <function name="quark" c:identifier="soup_xmlrpc_fault_quark">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <constant name="XMLRPC_H" value="1" c:type="SOUP_XMLRPC_H">
      <type name="gint" c:type="gint"/>
    </constant>
    <function name="add_completion"
              c:identifier="soup_add_completion"
              version="2.24"
              introspectable="0">
      <doc xml:space="preserve">Adds @function to be executed from inside @async_context with the
default priority. Use this when you want to complete an action in
@async_context's main loop, as soon as possible.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a #GSource, which can be removed from @async_context
with g_source_destroy().</doc>
        <type name="GLib.Source" c:type="GSource*"/>
      </return-value>
      <parameters>
        <parameter name="async_context"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">the #GMainContext to dispatch the I/O
watch in, or %NULL for the default context</doc>
          <type name="GLib.MainContext" c:type="GMainContext*"/>
        </parameter>
        <parameter name="function" transfer-ownership="none" closure="2">
          <doc xml:space="preserve">the callback to invoke</doc>
          <type name="GLib.SourceFunc" c:type="GSourceFunc"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:space="preserve">user data to pass to @function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="add_idle" c:identifier="soup_add_idle" introspectable="0">
      <doc xml:space="preserve">Adds an idle event as with g_idle_add(), but using the given
@async_context.

If you want @function to run "right away", use
soup_add_completion(), since that sets a higher priority on the
#GSource than soup_add_idle() does.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a #GSource, which can be removed from @async_context
with g_source_destroy().</doc>
        <type name="GLib.Source" c:type="GSource*"/>
      </return-value>
      <parameters>
        <parameter name="async_context"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">the #GMainContext to dispatch the I/O
watch in, or %NULL for the default context</doc>
          <type name="GLib.MainContext" c:type="GMainContext*"/>
        </parameter>
        <parameter name="function" transfer-ownership="none" closure="2">
          <doc xml:space="preserve">the callback to invoke at idle time</doc>
          <type name="GLib.SourceFunc" c:type="GSourceFunc"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:space="preserve">user data to pass to @function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="add_io_watch"
              c:identifier="soup_add_io_watch"
              introspectable="0">
      <doc xml:space="preserve">Adds an I/O watch as with g_io_add_watch(), but using the given
@async_context.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a #GSource, which can be removed from @async_context
with g_source_destroy().</doc>
        <type name="GLib.Source" c:type="GSource*"/>
      </return-value>
      <parameters>
        <parameter name="async_context"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">the #GMainContext to dispatch the I/O
watch in, or %NULL for the default context</doc>
          <type name="GLib.MainContext" c:type="GMainContext*"/>
        </parameter>
        <parameter name="chan" transfer-ownership="none">
          <doc xml:space="preserve">the #GIOChannel to watch</doc>
          <type name="GLib.IOChannel" c:type="GIOChannel*"/>
        </parameter>
        <parameter name="condition" transfer-ownership="none">
          <doc xml:space="preserve">the condition to watch for</doc>
          <type name="GLib.IOCondition" c:type="GIOCondition"/>
        </parameter>
        <parameter name="function" transfer-ownership="none" closure="4">
          <doc xml:space="preserve">the callback to invoke when @condition occurs</doc>
          <type name="GLib.IOFunc" c:type="GIOFunc"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:space="preserve">user data to pass to @function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="add_timeout"
              c:identifier="soup_add_timeout"
              introspectable="0">
      <doc xml:space="preserve">Adds a timeout as with g_timeout_add(), but using the given
@async_context.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a #GSource, which can be removed from @async_context
with g_source_destroy().</doc>
        <type name="GLib.Source" c:type="GSource*"/>
      </return-value>
      <parameters>
        <parameter name="async_context"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">the #GMainContext to dispatch the I/O
watch in, or %NULL for the default context</doc>
          <type name="GLib.MainContext" c:type="GMainContext*"/>
        </parameter>
        <parameter name="interval" transfer-ownership="none">
          <doc xml:space="preserve">the timeout interval, in milliseconds</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="function" transfer-ownership="none" closure="3">
          <doc xml:space="preserve">the callback to invoke at timeout time</doc>
          <type name="GLib.SourceFunc" c:type="GSourceFunc"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:space="preserve">user data to pass to @function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="cookie_parse"
              c:identifier="soup_cookie_parse"
              moved-to="Cookie.parse"
              version="2.24">
      <doc xml:space="preserve">Parses @header and returns a #SoupCookie. (If @header contains
multiple cookies, only the first one will be parsed.)

If @header does not have "path" or "domain" attributes, they will
be defaulted from @origin. If @origin is %NULL, path will default
to "/", but domain will be left as %NULL. Note that this is not a
valid state for a #SoupCookie, and you will need to fill in some
appropriate string for the domain if you want to actually make use
of the cookie.</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">a new #SoupCookie, or %NULL if it could
not be parsed, or contained an illegal "domain" attribute for a
cookie originating from @origin.</doc>
        <type name="Cookie" c:type="SoupCookie*"/>
      </return-value>
      <parameters>
        <parameter name="header" transfer-ownership="none">
          <doc xml:space="preserve">a cookie string (eg, the value of a Set-Cookie header)</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="origin" transfer-ownership="none">
          <doc xml:space="preserve">origin of the cookie, or %NULL</doc>
          <type name="URI" c:type="SoupURI*"/>
        </parameter>
      </parameters>
    </function>
    <function name="cookies_free"
              c:identifier="soup_cookies_free"
              version="2.24"
              introspectable="0">
      <doc xml:space="preserve">Frees @cookies.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="cookies" transfer-ownership="none">
          <doc xml:space="preserve">a #GSList of #SoupCookie</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="Cookie"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="cookies_from_request"
              c:identifier="soup_cookies_from_request"
              version="2.24">
      <doc xml:space="preserve">Parses @msg's Cookie request header and returns a #GSList of
#SoupCookie&lt;!-- --&gt;s. As the "Cookie" header, unlike "Set-Cookie",
only contains cookie names and values, none of the other
#SoupCookie fields will be filled in. (Thus, you can't generally
pass a cookie returned from this method directly to
soup_cookies_to_response().)</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a #GSList
of #SoupCookie&lt;!-- --&gt;s, which can be freed with
soup_cookies_free().</doc>
        <type name="GLib.SList" c:type="GSList*">
          <type name="Cookie"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="msg" transfer-ownership="none">
          <doc xml:space="preserve">a #SoupMessage containing a "Cookie" request header</doc>
          <type name="Message" c:type="SoupMessage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="cookies_from_response"
              c:identifier="soup_cookies_from_response"
              version="2.24">
      <doc xml:space="preserve">Parses @msg's Set-Cookie response headers and returns a #GSList of
#SoupCookie&lt;!-- --&gt;s. Cookies that do not specify "path" or
"domain" attributes will have their values defaulted from @msg.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a #GSList
of #SoupCookie&lt;!-- --&gt;s, which can be freed with
soup_cookies_free().</doc>
        <type name="GLib.SList" c:type="GSList*">
          <type name="Cookie"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="msg" transfer-ownership="none">
          <doc xml:space="preserve">a #SoupMessage containing a "Set-Cookie" response header</doc>
          <type name="Message" c:type="SoupMessage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="cookies_to_cookie_header"
              c:identifier="soup_cookies_to_cookie_header"
              version="2.24">
      <doc xml:space="preserve">Serializes a #GSList of #SoupCookie into a string suitable for
setting as the value of the "Cookie" header.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the serialization of @cookies</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="cookies" transfer-ownership="none">
          <doc xml:space="preserve">a #GSList of #SoupCookie</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="Cookie"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="cookies_to_request"
              c:identifier="soup_cookies_to_request"
              version="2.24">
      <doc xml:space="preserve">Adds the name and value of each cookie in @cookies to @msg's
"Cookie" request. (If @msg already has a "Cookie" request header,
these cookies will be appended to the cookies already present. Be
careful that you do not append the same cookies twice, eg, when
requeuing a message.)</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="cookies" transfer-ownership="none">
          <doc xml:space="preserve">a #GSList of #SoupCookie</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="Cookie"/>
          </type>
        </parameter>
        <parameter name="msg" transfer-ownership="none">
          <doc xml:space="preserve">a #SoupMessage</doc>
          <type name="Message" c:type="SoupMessage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="cookies_to_response"
              c:identifier="soup_cookies_to_response"
              version="2.24">
      <doc xml:space="preserve">Appends a "Set-Cookie" response header to @msg for each cookie in
@cookies. (This is in addition to any other "Set-Cookie" headers
@msg may already have.)</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="cookies" transfer-ownership="none">
          <doc xml:space="preserve">a #GSList of #SoupCookie</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="Cookie"/>
          </type>
        </parameter>
        <parameter name="msg" transfer-ownership="none">
          <doc xml:space="preserve">a #SoupMessage</doc>
          <type name="Message" c:type="SoupMessage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="form_decode" c:identifier="soup_form_decode">
      <doc xml:space="preserve">Decodes @form, which is an urlencoded dataset as defined in the
HTML 4.01 spec.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a hash
table containing the name/value pairs from @encoded_form, which you
can free with g_hash_table_destroy().</doc>
        <type name="GLib.HashTable" c:type="GHashTable*">
          <type name="utf8"/>
          <type name="utf8"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="encoded_form" transfer-ownership="none">
          <doc xml:space="preserve">data of type "application/x-www-form-urlencoded"</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="form_decode_multipart"
              c:identifier="soup_form_decode_multipart"
              version="2.26">
      <doc xml:space="preserve">Decodes the "multipart/form-data" request in @msg; this is a
convenience method for the case when you have a single file upload
control in a form. (Or when you don't have any file upload
controls, but are still using "multipart/form-data" anyway.) Pass
the name of the file upload control in @file_control_name, and
soup_form_decode_multipart() will extract the uploaded file data
into @filename, @content_type, and @file. All of the other form
control data will be returned (as strings, as with
soup_form_decode()) in the returned #GHashTable.

You may pass %NULL for @filename, @content_type and/or @file if you do not
care about those fields. soup_form_decode_multipart() may also
return %NULL in those fields if the client did not provide that
information. You must free the returned filename and content-type
with g_free(), and the returned file data with soup_buffer_free().

If you have a form with more than one file upload control, you will
need to decode it manually, using soup_multipart_new_from_message()
and soup_multipart_get_part().</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">
a hash table containing the name/value pairs (other than
@file_control_name) from @msg, which you can free with
g_hash_table_destroy(). On error, it will return %NULL.</doc>
        <type name="GLib.HashTable" c:type="GHashTable*">
          <type name="utf8"/>
          <type name="utf8"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="msg" transfer-ownership="none">
          <doc xml:space="preserve">a #SoupMessage containing a "multipart/form-data" request body</doc>
          <type name="Message" c:type="SoupMessage*"/>
        </parameter>
        <parameter name="file_control_name"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">the name of the HTML file upload control, or %NULL</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="filename"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   optional="1"
                   allow-none="1">
          <doc xml:space="preserve">return location for the name of the uploaded file, or %NULL</doc>
          <type name="utf8" c:type="char**"/>
        </parameter>
        <parameter name="content_type"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   optional="1"
                   allow-none="1">
          <doc xml:space="preserve">return location for the MIME type of the uploaded file, or %NULL</doc>
          <type name="utf8" c:type="char**"/>
        </parameter>
        <parameter name="file"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   optional="1"
                   allow-none="1">
          <doc xml:space="preserve">return location for the uploaded file data, or %NULL</doc>
          <type name="Buffer" c:type="SoupBuffer**"/>
        </parameter>
      </parameters>
    </function>
    <function name="form_encode"
              c:identifier="soup_form_encode"
              introspectable="0">
      <doc xml:space="preserve">Encodes the given field names and values into a value of type
"application/x-www-form-urlencoded", as defined in the HTML 4.01
spec.

This method requires you to know the names of the form fields (or
at the very least, the total number of fields) at compile time; for
working with dynamic forms, use soup_form_encode_hash() or
soup_form_encode_datalist().</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the encoded form</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="first_field" transfer-ownership="none">
          <doc xml:space="preserve">name of the first form field</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">value of @first_field, followed by additional field names
and values, terminated by %NULL.</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="form_encode_datalist"
              c:identifier="soup_form_encode_datalist">
      <doc xml:space="preserve">Encodes @form_data_set into a value of type
"application/x-www-form-urlencoded", as defined in the HTML 4.01
spec. Unlike soup_form_encode_hash(), this preserves the ordering
of the form elements, which may be required in some situations.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the encoded form</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="form_data_set" transfer-ownership="none">
          <doc xml:space="preserve">a datalist containing name/value pairs</doc>
          <type name="GLib.Data" c:type="GData**"/>
        </parameter>
      </parameters>
    </function>
    <function name="form_encode_hash" c:identifier="soup_form_encode_hash">
      <doc xml:space="preserve">Encodes @form_data_set into a value of type
"application/x-www-form-urlencoded", as defined in the HTML 4.01
spec.

Note that the HTML spec states that "The control names/values are
listed in the order they appear in the document." Since this method
takes a hash table, it cannot enforce that; if you care about the
ordering of the form fields, use soup_form_encode_datalist().</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the encoded form</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="form_data_set" transfer-ownership="none">
          <doc xml:space="preserve">a hash table containing
name/value pairs (as strings)</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="utf8"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="form_encode_valist"
              c:identifier="soup_form_encode_valist"
              introspectable="0">
      <doc xml:space="preserve">See soup_form_encode(). This is mostly an internal method, used by
various other methods such as soup_uri_set_query_from_fields() and
soup_form_request_new().</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the encoded form</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="first_field" transfer-ownership="none">
          <doc xml:space="preserve">name of the first form field</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="args" transfer-ownership="none">
          <doc xml:space="preserve">pointer to additional values, as in soup_form_encode()</doc>
          <type name="va_list" c:type="va_list"/>
        </parameter>
      </parameters>
    </function>
    <function name="form_request_new"
              c:identifier="soup_form_request_new"
              introspectable="0">
      <doc xml:space="preserve">Creates a new %SoupMessage and sets it up to send the given data
to @uri via @method. (That is, if @method is "GET", it will encode
the form data into @uri's query field, and if @method is "POST", it
will encode it into the %SoupMessage's request_body.)</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the new %SoupMessage</doc>
        <type name="Message" c:type="SoupMessage*"/>
      </return-value>
      <parameters>
        <parameter name="method" transfer-ownership="none">
          <doc xml:space="preserve">the HTTP method, either "GET" or "POST"</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="uri" transfer-ownership="none">
          <doc xml:space="preserve">the URI to send the form data to</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="first_field" transfer-ownership="none">
          <doc xml:space="preserve">name of the first form field</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">value of @first_field, followed by additional field names
and values, terminated by %NULL.</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="form_request_new_from_datalist"
              c:identifier="soup_form_request_new_from_datalist">
      <doc xml:space="preserve">Creates a new %SoupMessage and sets it up to send @form_data_set to
@uri via @method, as with soup_form_request_new().</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the new %SoupMessage</doc>
        <type name="Message" c:type="SoupMessage*"/>
      </return-value>
      <parameters>
        <parameter name="method" transfer-ownership="none">
          <doc xml:space="preserve">the HTTP method, either "GET" or "POST"</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="uri" transfer-ownership="none">
          <doc xml:space="preserve">the URI to send the form data to</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="form_data_set" transfer-ownership="none">
          <doc xml:space="preserve">the data to send to @uri</doc>
          <type name="GLib.Data" c:type="GData**"/>
        </parameter>
      </parameters>
    </function>
    <function name="form_request_new_from_hash"
              c:identifier="soup_form_request_new_from_hash">
      <doc xml:space="preserve">Creates a new %SoupMessage and sets it up to send @form_data_set to
@uri via @method, as with soup_form_request_new().</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the new %SoupMessage</doc>
        <type name="Message" c:type="SoupMessage*"/>
      </return-value>
      <parameters>
        <parameter name="method" transfer-ownership="none">
          <doc xml:space="preserve">the HTTP method, either "GET" or "POST"</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="uri" transfer-ownership="none">
          <doc xml:space="preserve">the URI to send the form data to</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="form_data_set" transfer-ownership="none">
          <doc xml:space="preserve">the data to send to @uri</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="utf8"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="form_request_new_from_multipart"
              c:identifier="soup_form_request_new_from_multipart"
              version="2.26">
      <doc xml:space="preserve">Creates a new %SoupMessage and sets it up to send @multipart to
@uri via POST.

To send a &lt;literal&gt;"multipart/form-data"&lt;/literal&gt; POST, first
create a #SoupMultipart, using %SOUP_FORM_MIME_TYPE_MULTIPART as
the MIME type. Then use soup_multipart_append_form_string() and
soup_multipart_append_form_file() to add the value of each form
control to the multipart. (These are just convenience methods, and
you can use soup_multipart_append_part() if you need greater
control over the part headers.) Finally, call
soup_form_request_new_from_multipart() to serialize the multipart
structure and create a #SoupMessage.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the new %SoupMessage</doc>
        <type name="Message" c:type="SoupMessage*"/>
      </return-value>
      <parameters>
        <parameter name="uri" transfer-ownership="none">
          <doc xml:space="preserve">the URI to send the form data to</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="multipart" transfer-ownership="none">
          <doc xml:space="preserve">a "multipart/form-data" #SoupMultipart</doc>
          <type name="Multipart" c:type="SoupMultipart*"/>
        </parameter>
      </parameters>
    </function>
    <function name="header_contains" c:identifier="soup_header_contains">
      <doc xml:space="preserve">Parses @header to see if it contains the token @token (matched
case-insensitively). Note that this can't be used with lists
that have qvalues.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">whether or not @header contains @token</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="header" transfer-ownership="none">
          <doc xml:space="preserve">An HTTP header suitable for parsing with
soup_header_parse_list()</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="token" transfer-ownership="none">
          <doc xml:space="preserve">a token</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="header_free_list"
              c:identifier="soup_header_free_list"
              introspectable="0">
      <doc xml:space="preserve">Frees @list.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="list" transfer-ownership="none">
          <doc xml:space="preserve">a #GSList returned from soup_header_parse_list() or
soup_header_parse_quality_list()</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="header_free_param_list"
              c:identifier="soup_header_free_param_list">
      <doc xml:space="preserve">Frees @param_list.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="param_list" transfer-ownership="none">
          <doc xml:space="preserve">a #GHashTable returned from soup_header_parse_param_list()
or soup_header_parse_semi_param_list()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="utf8"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="header_g_string_append_param"
              c:identifier="soup_header_g_string_append_param"
              version="2.26">
      <doc xml:space="preserve">Appends something like &lt;literal&gt;@name=@value&lt;/literal&gt; to @string,
taking care to quote @value if needed, and if so, to escape any
quotes or backslashes in @value.

Alternatively, if @value is a non-ASCII UTF-8 string, it will be
appended using RFC5987 syntax. Although in theory this is supposed
to work anywhere in HTTP that uses this style of parameter, in
reality, it can only be used portably with the Content-Disposition
"filename" parameter.

If @value is %NULL, this will just append @name to @string.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:space="preserve">a #GString being used to construct an HTTP header value</doc>
          <type name="GLib.String" c:type="GString*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">a parameter name</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">a parameter value, or %NULL</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="header_g_string_append_param_quoted"
              c:identifier="soup_header_g_string_append_param_quoted"
              version="2.30">
      <doc xml:space="preserve">Appends something like &lt;literal&gt;@name="@value"&lt;/literal&gt; to
@string, taking care to escape any quotes or backslashes in @value.

If @value is (non-ASCII) UTF-8, this will instead use RFC 5987
encoding, just like soup_header_g_string_append_param().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:space="preserve">a #GString being used to construct an HTTP header value</doc>
          <type name="GLib.String" c:type="GString*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">a parameter name</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">a parameter value</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="header_parse_list" c:identifier="soup_header_parse_list">
      <doc xml:space="preserve">Parses a header whose content is described by RFC2616 as
"#something", where "something" does not itself contain commas,
except as part of quoted-strings.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a #GSList of
list elements, as allocated strings</doc>
        <type name="GLib.SList" c:type="GSList*">
          <type name="utf8"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="header" transfer-ownership="none">
          <doc xml:space="preserve">a header value</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="header_parse_param_list"
              c:identifier="soup_header_parse_param_list">
      <doc xml:space="preserve">Parses a header which is a comma-delimited list of something like:
&lt;literal&gt;token [ "=" ( token | quoted-string ) ]&lt;/literal&gt;.

Tokens that don't have an associated value will still be added to
the resulting hash table, but with a %NULL value.

This also handles RFC5987 encoding (which in HTTP is mostly used
for giving UTF8-encoded filenames in the Content-Disposition
header).</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a
#GHashTable of list elements, which can be freed with
soup_header_free_param_list().</doc>
        <type name="GLib.HashTable" c:type="GHashTable*">
          <type name="utf8"/>
          <type name="utf8"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="header" transfer-ownership="none">
          <doc xml:space="preserve">a header value</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="header_parse_quality_list"
              c:identifier="soup_header_parse_quality_list">
      <doc xml:space="preserve">Parses a header whose content is a list of items with optional
"qvalue"s (eg, Accept, Accept-Charset, Accept-Encoding,
Accept-Language, TE).

If @unacceptable is not %NULL, then on return, it will contain the
items with qvalue 0. Either way, those items will be removed from
the main list.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a #GSList of
acceptable values (as allocated strings), highest-qvalue first.</doc>
        <type name="GLib.SList" c:type="GSList*">
          <type name="utf8"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="header" transfer-ownership="none">
          <doc xml:space="preserve">a header value</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="unacceptable"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   optional="1"
                   allow-none="1">
          <doc xml:space="preserve">on
return, will contain a list of unacceptable values</doc>
          <type name="GLib.SList" c:type="GSList**">
            <type name="utf8"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="header_parse_semi_param_list"
              c:identifier="soup_header_parse_semi_param_list"
              version="2.24">
      <doc xml:space="preserve">Parses a header which is a semicolon-delimited list of something
like: &lt;literal&gt;token [ "=" ( token | quoted-string ) ]&lt;/literal&gt;.

Tokens that don't have an associated value will still be added to
the resulting hash table, but with a %NULL value.

This also handles RFC5987 encoding (which in HTTP is mostly used
for giving UTF8-encoded filenames in the Content-Disposition
header).</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a
#GHashTable of list elements, which can be freed with
soup_header_free_param_list().</doc>
        <type name="GLib.HashTable" c:type="GHashTable*">
          <type name="utf8"/>
          <type name="utf8"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="header" transfer-ownership="none">
          <doc xml:space="preserve">a header value</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="headers_parse"
              c:identifier="soup_headers_parse"
              version="2.26">
      <doc xml:space="preserve">Parses the headers of an HTTP request or response in @str and
stores the results in @dest. Beware that @dest may be modified even
on failure.

This is a low-level method; normally you would use
soup_headers_parse_request() or soup_headers_parse_response().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">success or failure</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">the header string (including the Request-Line or Status-Line,
  but not the trailing blank line)</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">length of @str</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="dest" transfer-ownership="none">
          <doc xml:space="preserve">#SoupMessageHeaders to store the header values in</doc>
          <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
        </parameter>
      </parameters>
    </function>
    <function name="headers_parse_request"
              c:identifier="soup_headers_parse_request">
      <doc xml:space="preserve">Parses the headers of an HTTP request in @str and stores the
results in @req_method, @req_path, @ver, and @req_headers.

Beware that @req_headers may be modified even on failure.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%SOUP_STATUS_OK if the headers could be parsed, or an
HTTP error to be returned to the client if they could not be.</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">the headers (up to, but not including, the trailing blank line)</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">length of @str</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="req_headers" transfer-ownership="none">
          <doc xml:space="preserve">#SoupMessageHeaders to store the header values in</doc>
          <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
        </parameter>
        <parameter name="req_method"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   optional="1"
                   allow-none="1">
          <doc xml:space="preserve">if non-%NULL, will be filled in with the
request method</doc>
          <type name="utf8" c:type="char**"/>
        </parameter>
        <parameter name="req_path"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   optional="1"
                   allow-none="1">
          <doc xml:space="preserve">if non-%NULL, will be filled in with the
request path</doc>
          <type name="utf8" c:type="char**"/>
        </parameter>
        <parameter name="ver"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   optional="1"
                   allow-none="1">
          <doc xml:space="preserve">if non-%NULL, will be filled in with the HTTP
version</doc>
          <type name="HTTPVersion" c:type="SoupHTTPVersion*"/>
        </parameter>
      </parameters>
    </function>
    <function name="headers_parse_response"
              c:identifier="soup_headers_parse_response">
      <doc xml:space="preserve">Parses the headers of an HTTP response in @str and stores the
results in @ver, @status_code, @reason_phrase, and @headers.

Beware that @headers may be modified even on failure.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">success or failure.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">the headers (up to, but not including, the trailing blank line)</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">length of @str</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="headers" transfer-ownership="none">
          <doc xml:space="preserve">#SoupMessageHeaders to store the header values in</doc>
          <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
        </parameter>
        <parameter name="ver"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   optional="1"
                   allow-none="1">
          <doc xml:space="preserve">if non-%NULL, will be filled in with the HTTP
version</doc>
          <type name="HTTPVersion" c:type="SoupHTTPVersion*"/>
        </parameter>
        <parameter name="status_code"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   optional="1"
                   allow-none="1">
          <doc xml:space="preserve">if non-%NULL, will be filled in with
the status code</doc>
          <type name="guint" c:type="guint*"/>
        </parameter>
        <parameter name="reason_phrase"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   optional="1"
                   allow-none="1">
          <doc xml:space="preserve">if non-%NULL, will be filled in with
the reason phrase</doc>
          <type name="utf8" c:type="char**"/>
        </parameter>
      </parameters>
    </function>
    <function name="headers_parse_status_line"
              c:identifier="soup_headers_parse_status_line">
      <doc xml:space="preserve">Parses the HTTP Status-Line string in @status_line into @ver,
@status_code, and @reason_phrase. @status_line must be terminated by
either "\0" or "\r\n".</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @status_line was parsed successfully.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="status_line" transfer-ownership="none">
          <doc xml:space="preserve">an HTTP Status-Line</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="ver"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   optional="1"
                   allow-none="1">
          <doc xml:space="preserve">if non-%NULL, will be filled in with the HTTP
version</doc>
          <type name="HTTPVersion" c:type="SoupHTTPVersion*"/>
        </parameter>
        <parameter name="status_code"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   optional="1"
                   allow-none="1">
          <doc xml:space="preserve">if non-%NULL, will be filled in with
the status code</doc>
          <type name="guint" c:type="guint*"/>
        </parameter>
        <parameter name="reason_phrase"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   optional="1"
                   allow-none="1">
          <doc xml:space="preserve">if non-%NULL, will be filled in with
the reason phrase</doc>
          <type name="utf8" c:type="char**"/>
        </parameter>
      </parameters>
    </function>
    <function name="http_error_quark" c:identifier="soup_http_error_quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="message_headers_iter_init"
              c:identifier="soup_message_headers_iter_init"
              moved-to="MessageHeadersIter.init">
      <doc xml:space="preserve">Initializes @iter for iterating @hdrs.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="iter"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve">a pointer to a %SoupMessageHeadersIter
structure</doc>
          <type name="MessageHeadersIter" c:type="SoupMessageHeadersIter*"/>
        </parameter>
        <parameter name="hdrs" transfer-ownership="none">
          <doc xml:space="preserve">a %SoupMessageHeaders</doc>
          <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
        </parameter>
      </parameters>
    </function>
    <function name="request_error_quark"
              c:identifier="soup_request_error_quark"
              moved-to="RequestError.quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="requester_error_quark"
              c:identifier="soup_requester_error_quark"
              moved-to="RequesterError.quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="status_get_phrase"
              c:identifier="soup_status_get_phrase"
              moved-to="Status.get_phrase">
      <doc xml:space="preserve">Looks up the stock HTTP description of @status_code. This is used
by soup_message_set_status() to get the correct text to go with a
given status code.

&lt;emphasis&gt;There is no reason for you to ever use this
function.&lt;/emphasis&gt; If you wanted the textual description for the
#SoupMessage:status_code of a given #SoupMessage, you should just
look at the message's #SoupMessage:reason_phrase. However, you
should only do that for use in debugging messages; HTTP reason
phrases are not localized, and are not generally very descriptive
anyway, and so they should never be presented to the user directly.
Instead, you should create you own error messages based on the
status code, and on what you were trying to do.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the (terse, English) description of @status_code</doc>
        <type name="utf8" c:type="const char*"/>
      </return-value>
      <parameters>
        <parameter name="status_code" transfer-ownership="none">
          <doc xml:space="preserve">an HTTP status code</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="status_proxify"
              c:identifier="soup_status_proxify"
              moved-to="Status.proxify"
              version="2.26">
      <doc xml:space="preserve">Turns %SOUP_STATUS_CANT_RESOLVE into
%SOUP_STATUS_CANT_RESOLVE_PROXY and %SOUP_STATUS_CANT_CONNECT into
%SOUP_STATUS_CANT_CONNECT_PROXY. Other status codes are passed
through unchanged.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the "proxified" equivalent of @status_code.</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="status_code" transfer-ownership="none">
          <doc xml:space="preserve">a status code</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="str_case_equal" c:identifier="soup_str_case_equal">
      <doc xml:space="preserve">Compares @v1 and @v2 in a case-insensitive manner</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if they are equal (modulo case)</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="v1" transfer-ownership="none">
          <doc xml:space="preserve">an ASCII string</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
        <parameter name="v2" transfer-ownership="none">
          <doc xml:space="preserve">another ASCII string</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="str_case_hash" c:identifier="soup_str_case_hash">
      <doc xml:space="preserve">Hashes @key in a case-insensitive manner.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the hash code.</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="key" transfer-ownership="none">
          <doc xml:space="preserve">ASCII string to hash</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="tld_domain_is_public_suffix"
              c:identifier="soup_tld_domain_is_public_suffix"
              version="2.40">
      <doc xml:space="preserve">Looks whether the @domain passed as argument is a public domain
suffix (.org, .com, .co.uk, etc) or not.

Prior to libsoup 2.46, this function required that @domain be in
UTF-8 if it was an IDN. From 2.46 on, the name can be in either
UTF-8 or ASCII format (and the return value will be in the same
format).</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if it is a public domain, %FALSE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve">a domain name</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="tld_error_quark"
              c:identifier="soup_tld_error_quark"
              moved-to="TLDError.quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="tld_get_base_domain"
              c:identifier="soup_tld_get_base_domain"
              version="2.40"
              throws="1">
      <doc xml:space="preserve">Finds the base domain for a given @hostname. The base domain is
composed by the top level domain (such as .org, .com, .co.uk, etc)
plus the second level domain, for example for myhost.mydomain.com
it will return mydomain.com.

Note that %NULL will be returned for private URLs (those not ending
with any well known TLD) because choosing a base domain for them
would be totally arbitrary.

Prior to libsoup 2.46, this function required that @hostname be in
UTF-8 if it was an IDN. From 2.46 on, the name can be in either
UTF-8 or ASCII format (and the return value will be in the same
format).</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a pointer to the start of the base domain in @hostname. If
an error occurs, %NULL will be returned and @error set.</doc>
        <type name="utf8" c:type="const char*"/>
      </return-value>
      <parameters>
        <parameter name="hostname" transfer-ownership="none">
          <doc xml:space="preserve">a hostname</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="uri_decode"
              c:identifier="soup_uri_decode"
              moved-to="URI.decode">
      <doc xml:space="preserve">Fully %&lt;!-- --&gt;-decodes @part.

In the past, this would return %NULL if @part contained invalid
percent-encoding, but now it just ignores the problem (as
soup_uri_new() already did).</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the decoded URI part.</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="part" transfer-ownership="none">
          <doc xml:space="preserve">a URI part</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="uri_encode"
              c:identifier="soup_uri_encode"
              moved-to="URI.encode">
      <doc xml:space="preserve">This %&lt;!-- --&gt;-encodes the given URI part and returns the escaped
version in allocated memory, which the caller must free when it is
done.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the encoded URI part</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="part" transfer-ownership="none">
          <doc xml:space="preserve">a URI part</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="escape_extra"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">additional reserved characters to
escape (or %NULL)</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="uri_normalize"
              c:identifier="soup_uri_normalize"
              moved-to="URI.normalize">
      <doc xml:space="preserve">%&lt;!-- --&gt;-decodes any "unreserved" characters (or characters in
@unescape_extra) in @part.

"Unreserved" characters are those that are not allowed to be used
for punctuation according to the URI spec. For example, letters are
unreserved, so soup_uri_normalize() will turn
&lt;literal&gt;http://example.com/foo/b%&lt;!-- --&gt;61r&lt;/literal&gt; into
&lt;literal&gt;http://example.com/foo/bar&lt;/literal&gt;, which is guaranteed
to mean the same thing. However, "/" is "reserved", so
&lt;literal&gt;http://example.com/foo%&lt;!-- --&gt;2Fbar&lt;/literal&gt; would not
be changed, because it might mean something different to the
server.

In the past, this would return %NULL if @part contained invalid
percent-encoding, but now it just ignores the problem (as
soup_uri_new() already did).</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the normalized URI part</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="part" transfer-ownership="none">
          <doc xml:space="preserve">a URI part</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="unescape_extra" transfer-ownership="none">
          <doc xml:space="preserve">reserved characters to unescape (or %NULL)</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_array_append"
              c:identifier="soup_value_array_append"
              introspectable="0">
      <doc xml:space="preserve">Appends the provided value of type @type to @array as with
g_value_array_append(). (The provided data is copied rather than
being inserted directly.)</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="array" transfer-ownership="none">
          <doc xml:space="preserve">a #GValueArray</doc>
          <type name="GObject.ValueArray" c:type="GValueArray*"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">a #GType</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">a value of type @type</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="value_array_append_vals"
              c:identifier="soup_value_array_append_vals"
              introspectable="0">
      <doc xml:space="preserve">Appends the provided values into @array as with
g_value_array_append(). (The provided data is copied rather than
being inserted directly.)</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="array" transfer-ownership="none">
          <doc xml:space="preserve">a #GValueArray</doc>
          <type name="GObject.ValueArray" c:type="GValueArray*"/>
        </parameter>
        <parameter name="first_type" transfer-ownership="none">
          <doc xml:space="preserve">the type of the first value to add</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">the first value to add, followed by other type/value
pairs, terminated by %G_TYPE_INVALID</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="value_array_from_args"
              c:identifier="soup_value_array_from_args"
              introspectable="0">
      <doc xml:space="preserve">Creates a #GValueArray from the provided arguments, which must
consist of pairs of a #GType and a value of that type, terminated
by %G_TYPE_INVALID. (The array will contain copies of the provided
data rather than pointing to the passed-in data directly.)</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">a new #GValueArray, or %NULL if an error
occurred.</doc>
        <type name="GObject.ValueArray" c:type="GValueArray*"/>
      </return-value>
      <parameters>
        <parameter name="args" transfer-ownership="none">
          <doc xml:space="preserve">arguments to create a #GValueArray from</doc>
          <type name="va_list" c:type="va_list"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_array_get_nth"
              c:identifier="soup_value_array_get_nth"
              introspectable="0">
      <doc xml:space="preserve">Gets the @index_ element of @array and stores its value into the
provided location.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @array contained a value with index @index_
and type @type, %FALSE if not.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="array" transfer-ownership="none">
          <doc xml:space="preserve">a #GValueArray</doc>
          <type name="GObject.ValueArray" c:type="GValueArray*"/>
        </parameter>
        <parameter name="index_" transfer-ownership="none">
          <doc xml:space="preserve">the index to look up</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">a #GType</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">a value of type pointer-to-@type</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="value_array_insert"
              c:identifier="soup_value_array_insert"
              introspectable="0">
      <doc xml:space="preserve">Inserts the provided value of type @type into @array as with
g_value_array_insert(). (The provided data is copied rather than
being inserted directly.)</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="array" transfer-ownership="none">
          <doc xml:space="preserve">a #GValueArray</doc>
          <type name="GObject.ValueArray" c:type="GValueArray*"/>
        </parameter>
        <parameter name="index_" transfer-ownership="none">
          <doc xml:space="preserve">the index to insert at</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">a #GType</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">a value of type @type</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="value_array_new" c:identifier="soup_value_array_new">
      <doc xml:space="preserve">Creates a new %GValueArray. (This is just a wrapper around
g_value_array_new(), for naming consistency purposes.)</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a new %GValueArray</doc>
        <type name="GObject.ValueArray" c:type="GValueArray*"/>
      </return-value>
    </function>
    <function name="value_array_new_with_vals"
              c:identifier="soup_value_array_new_with_vals"
              introspectable="0">
      <doc xml:space="preserve">Creates a new %GValueArray and copies the provided values
into it.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a new %GValueArray</doc>
        <type name="GObject.ValueArray" c:type="GValueArray*"/>
      </return-value>
      <parameters>
        <parameter name="first_type" transfer-ownership="none">
          <doc xml:space="preserve">the type of the first value to add</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">the first value to add, followed by other type/value
pairs, terminated by %G_TYPE_INVALID</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="value_array_to_args"
              c:identifier="soup_value_array_to_args"
              introspectable="0">
      <doc xml:space="preserve">Extracts a #GValueArray into the provided arguments, which must
consist of pairs of a #GType and a value of pointer-to-that-type,
terminated by %G_TYPE_INVALID. The returned values will point to the
same memory as the values in the array.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">success or failure</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="array" transfer-ownership="none">
          <doc xml:space="preserve">a #GValueArray</doc>
          <type name="GObject.ValueArray" c:type="GValueArray*"/>
        </parameter>
        <parameter name="args" transfer-ownership="none">
          <doc xml:space="preserve">arguments to extract @array into</doc>
          <type name="va_list" c:type="va_list"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_hash_insert"
              c:identifier="soup_value_hash_insert"
              introspectable="0">
      <doc xml:space="preserve">Inserts the provided value of type @type into @hash. (Unlike with
g_hash_table_insert(), both the key and the value are copied).</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="hash" transfer-ownership="none">
          <doc xml:space="preserve">a value hash</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:space="preserve">the key</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">a #GType</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">a value of type @type</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="value_hash_insert_vals"
              c:identifier="soup_value_hash_insert_vals"
              introspectable="0">
      <doc xml:space="preserve">Inserts the given data into @hash. As with
soup_value_hash_insert(), the keys and values are copied rather
than being inserted directly.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="hash" transfer-ownership="none">
          <doc xml:space="preserve">a value hash</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </parameter>
        <parameter name="first_key" transfer-ownership="none">
          <doc xml:space="preserve">the key for the first value</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">the type of @first_key, followed by the value, followed
by additional key/type/value triplets, terminated by %NULL</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="value_hash_insert_value"
              c:identifier="soup_value_hash_insert_value">
      <doc xml:space="preserve">Inserts @value into @hash. (Unlike with g_hash_table_insert(), both
the key and the value are copied).</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="hash" transfer-ownership="none">
          <doc xml:space="preserve">a value hash</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:space="preserve">the key</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">a value</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_hash_lookup"
              c:identifier="soup_value_hash_lookup"
              introspectable="0">
      <doc xml:space="preserve">Looks up @key in @hash and stores its value into the provided
location.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @hash contained a value with key @key and
type @type, %FALSE if not.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="hash" transfer-ownership="none">
          <doc xml:space="preserve">a value hash</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:space="preserve">the key to look up</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">a #GType</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">a value of type pointer-to-@type</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="value_hash_lookup_vals"
              c:identifier="soup_value_hash_lookup_vals"
              introspectable="0">
      <doc xml:space="preserve">Looks up a number of keys in @hash and returns their values.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if all of the keys were found, %FALSE
if any were missing; note that you will generally need to
initialize each destination variable to a reasonable default
value, since there is no way to tell which keys were found
and which were not.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="hash" transfer-ownership="none">
          <doc xml:space="preserve">a value hash</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </parameter>
        <parameter name="first_key" transfer-ownership="none">
          <doc xml:space="preserve">the first key to look up</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">the type of @first_key, a pointer to that type, and
then additional key/type/pointer triplets, terminated
by %NULL.</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="value_hash_new" c:identifier="soup_value_hash_new">
      <doc xml:space="preserve">Creates a #GHashTable whose keys are strings and whose values
are #GValue.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a new
empty #GHashTable</doc>
        <type name="GLib.HashTable" c:type="GHashTable*">
          <type name="utf8"/>
          <type name="GObject.Value"/>
        </type>
      </return-value>
    </function>
    <function name="value_hash_new_with_vals"
              c:identifier="soup_value_hash_new_with_vals"
              introspectable="0">
      <doc xml:space="preserve">Creates a #GHashTable whose keys are strings and whose values
are #GValue, and initializes it with the provided data. As
with soup_value_hash_insert(), the keys and values are copied
rather than being inserted directly.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a new
#GHashTable, initialized with the given values</doc>
        <type name="GLib.HashTable" c:type="GHashTable*">
          <type name="utf8"/>
          <type name="GObject.Value"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="first_key" transfer-ownership="none">
          <doc xml:space="preserve">the key for the first value</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">the type of @first_key, followed by the value, followed
by additional key/type/value triplets, terminated by %NULL</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="websocket_client_prepare_handshake"
              c:identifier="soup_websocket_client_prepare_handshake"
              version="2.50">
      <doc xml:space="preserve">Adds the necessary headers to @msg to request a WebSocket
handshake. The message body and non-WebSocket-related headers are
not modified.

This is a low-level function; if you use
soup_session_websocket_connect_async() to create a WebSocket
connection, it will call this for you.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="msg" transfer-ownership="none">
          <doc xml:space="preserve">a #SoupMessage</doc>
          <type name="Message" c:type="SoupMessage*"/>
        </parameter>
        <parameter name="origin"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">the "Origin" header to set</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="protocols"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">list of
  protocols to offer</doc>
          <array c:type="char**">
            <type name="utf8" c:type="char*"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="websocket_client_verify_handshake"
              c:identifier="soup_websocket_client_verify_handshake"
              version="2.50"
              throws="1">
      <doc xml:space="preserve">Looks at the response status code and headers in @msg and
determines if they contain a valid WebSocket handshake response
(given the handshake request in @msg's request headers).

This is a low-level function; if you use
soup_session_websocket_connect_async() to create a WebSocket
connection, it will call this for you.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @msg contains a completed valid WebSocket
  handshake, %FALSE and an error if not.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="msg" transfer-ownership="none">
          <doc xml:space="preserve">#SoupMessage containing both client and server sides of a
  WebSocket handshake</doc>
          <type name="Message" c:type="SoupMessage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="websocket_error_get_quark"
              c:identifier="soup_websocket_error_get_quark"
              moved-to="WebsocketError.get_quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="websocket_server_check_handshake"
              c:identifier="soup_websocket_server_check_handshake"
              version="2.50"
              throws="1">
      <doc xml:space="preserve">Examines the method and request headers in @msg and determines
whether @msg contains a valid handshake request.

If @origin is non-%NULL, then only requests containing a matching
"Origin" header will be accepted. If @protocols is non-%NULL, then
only requests containing a compatible "Sec-WebSocket-Protocols"
header will be accepted.

Normally soup_websocket_server_process_handshake() will take care
of this for you, and if you use soup_server_add_websocket_handler()
to handle accepting WebSocket connections, it will call that for
you. However, this function may be useful if you need to perform
more complicated validation; eg, accepting multiple different Origins,
or handling different protocols depending on the path.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @msg contained a valid WebSocket handshake,
  %FALSE and an error if not.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="msg" transfer-ownership="none">
          <doc xml:space="preserve">#SoupMessage containing the client side of a WebSocket handshake</doc>
          <type name="Message" c:type="SoupMessage*"/>
        </parameter>
        <parameter name="origin"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">expected Origin header</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="protocols"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">allowed WebSocket
  protocols.</doc>
          <array c:type="char**">
            <type name="utf8" c:type="char*"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="websocket_server_process_handshake"
              c:identifier="soup_websocket_server_process_handshake"
              version="2.50">
      <doc xml:space="preserve">Examines the method and request headers in @msg and (assuming @msg
contains a valid handshake request), fills in the handshake
response.

If @origin is non-%NULL, then only requests containing a matching
"Origin" header will be accepted. If @protocols is non-%NULL, then
only requests containing a compatible "Sec-WebSocket-Protocols"
header will be accepted.

This is a low-level function; if you use
soup_server_add_websocket_handler() to handle accepting WebSocket
connections, it will call this for you.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @msg contained a valid WebSocket handshake
  request and was updated to contain a handshake response. %FALSE
  and an error if not.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="msg" transfer-ownership="none">
          <doc xml:space="preserve">#SoupMessage containing the client side of a WebSocket handshake</doc>
          <type name="Message" c:type="SoupMessage*"/>
        </parameter>
        <parameter name="origin"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">expected Origin header</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="protocols"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">allowed WebSocket
  protocols.</doc>
          <array c:type="char**">
            <type name="utf8" c:type="char*"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="xmlrpc_build_fault"
              c:identifier="soup_xmlrpc_build_fault"
              introspectable="0">
      <doc xml:space="preserve">This creates an XML-RPC fault response and returns it as a string.
(To create a successful response, use
soup_xmlrpc_build_method_response().)</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the text of the fault</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="fault_code" transfer-ownership="none">
          <doc xml:space="preserve">the fault code</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="fault_format" transfer-ownership="none">
          <doc xml:space="preserve">a printf()-style format string</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">the parameters to @fault_format</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="xmlrpc_build_method_call"
              c:identifier="soup_xmlrpc_build_method_call">
      <doc xml:space="preserve">This creates an XML-RPC methodCall and returns it as a string.
This is the low-level method that soup_xmlrpc_request_new() is
built on.

@params is an array of #GValue representing the parameters to
@method. (It is *not* a #GValueArray, although if you have a
#GValueArray, you can just pass its &lt;literal&gt;values&lt;/literal&gt;f and
&lt;literal&gt;n_values&lt;/literal&gt; fields.)

The correspondence between glib types and XML-RPC types is:

  int: #int (%G_TYPE_INT)
  boolean: #gboolean (%G_TYPE_BOOLEAN)
  string: #char* (%G_TYPE_STRING)
  double: #double (%G_TYPE_DOUBLE)
  datetime.iso8601: #SoupDate (%SOUP_TYPE_DATE)
  base64: #GByteArray (%SOUP_TYPE_BYTE_ARRAY)
  struct: #GHashTable (%G_TYPE_HASH_TABLE)
  array: #GValueArray (%G_TYPE_VALUE_ARRAY)

For structs, use a #GHashTable that maps strings to #GValue;
soup_value_hash_new() and related methods can help with this.</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">the text of the methodCall, or %NULL on
error</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="method_name" transfer-ownership="none">
          <doc xml:space="preserve">the name of the XML-RPC method</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="params" transfer-ownership="none">
          <doc xml:space="preserve">arguments to @method</doc>
          <array length="2" zero-terminated="0" c:type="GValue*">
            <type name="GObject.Value" c:type="GValue"/>
          </array>
        </parameter>
        <parameter name="n_params" transfer-ownership="none">
          <doc xml:space="preserve">length of @params</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="xmlrpc_build_method_response"
              c:identifier="soup_xmlrpc_build_method_response">
      <doc xml:space="preserve">This creates a (successful) XML-RPC methodResponse and returns it
as a string. To create a fault response, use
soup_xmlrpc_build_fault().

The glib type to XML-RPC type mapping is as with
soup_xmlrpc_build_method_call(), qv.</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">the text of the methodResponse, or %NULL
on error</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">the return value</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="xmlrpc_error_quark"
              c:identifier="soup_xmlrpc_error_quark"
              moved-to="XMLRPCError.quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="xmlrpc_extract_method_call"
              c:identifier="soup_xmlrpc_extract_method_call"
              introspectable="0">
      <doc xml:space="preserve">Parses @method_call to get the name and parameters, and puts
the parameters into variables of the appropriate types.

The parameters are handled similarly to
@soup_xmlrpc_build_method_call, with pairs of types and values,
terminated by %G_TYPE_INVALID, except that values are pointers to
variables of the indicated type, rather than values of the type.

See also soup_xmlrpc_parse_method_call(), which can be used if
you don't know the types of the parameters.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">success or failure.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="method_call" transfer-ownership="none">
          <doc xml:space="preserve">the XML-RPC methodCall string</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:space="preserve">the length of @method_call, or -1 if it is NUL-terminated</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="method_name"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">on return, the methodName from @method_call</doc>
          <type name="utf8" c:type="char**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">return types and locations for parameters</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="xmlrpc_extract_method_response"
              c:identifier="soup_xmlrpc_extract_method_response"
              introspectable="0">
      <doc xml:space="preserve">Parses @method_response and extracts the return value into
a variable of the correct type.

If @method_response is a fault, the return value will be unset,
and @error will be set to an error of type %SOUP_XMLRPC_FAULT, with
the error #code containing the fault code, and the error #message
containing the fault string. (If @method_response cannot be parsed
at all, soup_xmlrpc_extract_method_response() will return %FALSE,
but @error will be unset.)</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if a return value was parsed, %FALSE if the
response was of the wrong type, or contained a fault.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="method_response" transfer-ownership="none">
          <doc xml:space="preserve">the XML-RPC methodResponse string</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:space="preserve">the length of @method_response, or -1 if it is NUL-terminated</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve">error return value</doc>
          <type name="GLib.Error" c:type="GError**"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">the expected type of the return value</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">location for return value</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="xmlrpc_fault_quark"
              c:identifier="soup_xmlrpc_fault_quark"
              moved-to="XMLRPCFault.quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="xmlrpc_parse_method_call"
              c:identifier="soup_xmlrpc_parse_method_call">
      <doc xml:space="preserve">Parses @method_call to get the name and parameters, and returns the
parameter values in a #GValueArray; see also
soup_xmlrpc_extract_method_call(), which is more convenient if you
know in advance what the types of the parameters will be.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">success or failure.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="method_call" transfer-ownership="none">
          <doc xml:space="preserve">the XML-RPC methodCall string</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:space="preserve">the length of @method_call, or -1 if it is NUL-terminated</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="method_name"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">on return, the methodName from @method_call</doc>
          <type name="utf8" c:type="char**"/>
        </parameter>
        <parameter name="params"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">on return, the parameters from @method_call</doc>
          <type name="GObject.ValueArray" c:type="GValueArray**"/>
        </parameter>
      </parameters>
    </function>
    <function name="xmlrpc_parse_method_response"
              c:identifier="soup_xmlrpc_parse_method_response"
              throws="1">
      <doc xml:space="preserve">Parses @method_response and returns the return value in @value. If
@method_response is a fault, @value will be unchanged, and @error
will be set to an error of type %SOUP_XMLRPC_FAULT, with the error
#code containing the fault code, and the error #message containing
the fault string. (If @method_response cannot be parsed at all,
soup_xmlrpc_parse_method_response() will return %FALSE, but @error
will be unset.)</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if a return value was parsed, %FALSE if the
response could not be parsed, or contained a fault.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="method_response" transfer-ownership="none">
          <doc xml:space="preserve">the XML-RPC methodResponse string</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:space="preserve">the length of @method_response, or -1 if it is NUL-terminated</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="value"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve">on return, the return value from @method_call</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="xmlrpc_request_new"
              c:identifier="soup_xmlrpc_request_new"
              introspectable="0">
      <doc xml:space="preserve">Creates an XML-RPC methodCall and returns a #SoupMessage, ready
to send, for that method call.

The parameters are passed as type/value pairs; ie, first a #GType,
and then a value of the appropriate type, finally terminated by
%G_TYPE_INVALID.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a #SoupMessage encoding the
indicated XML-RPC request.</doc>
        <type name="Message" c:type="SoupMessage*"/>
      </return-value>
      <parameters>
        <parameter name="uri" transfer-ownership="none">
          <doc xml:space="preserve">URI of the XML-RPC service</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="method_name" transfer-ownership="none">
          <doc xml:space="preserve">the name of the XML-RPC method to invoke at @uri</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">parameters for @method</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="xmlrpc_set_fault"
              c:identifier="soup_xmlrpc_set_fault"
              introspectable="0">
      <doc xml:space="preserve">Sets the status code and response body of @msg to indicate an
unsuccessful XML-RPC call, with the error described by @fault_code
and @fault_format.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="msg" transfer-ownership="none">
          <doc xml:space="preserve">an XML-RPC request</doc>
          <type name="Message" c:type="SoupMessage*"/>
        </parameter>
        <parameter name="fault_code" transfer-ownership="none">
          <doc xml:space="preserve">the fault code</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="fault_format" transfer-ownership="none">
          <doc xml:space="preserve">a printf()-style format string</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">the parameters to @fault_format</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="xmlrpc_set_response"
              c:identifier="soup_xmlrpc_set_response"
              introspectable="0">
      <doc xml:space="preserve">Sets the status code and response body of @msg to indicate a
successful XML-RPC call, with a return value given by @type and the
following varargs argument, of the type indicated by @type.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="msg" transfer-ownership="none">
          <doc xml:space="preserve">an XML-RPC request</doc>
          <type name="Message" c:type="SoupMessage*"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">the type of the response value</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">the response value</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
  </namespace>
</repository>
